<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KevinSwift">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="KevinSwift">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KevinSwift">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>KevinSwift</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KevinSwift</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
            相册
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/angularjs脏检查机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/angularjs脏检查机制/" itemprop="url">angular学习(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T14:32:10+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>angular js是一个MVVM框架，通过ng-app指令定义一个angular js的应用程序，<br>AngularJS 模块（Module） 定义了 AngularJS 应用。<br>AngularJS 控制器（Controller） 用于控制 AngularJS 应用。<br>ng-app指令指明了应用, ng-controller 指明了控制器。<br>ng-model来进行双向绑定<br>表达式可以写在双大括号内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ng-app=&quot;LoginModel&quot; ng-controller=&quot;LoginCtrl&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var app = angular.module(&apos;LoginModel&apos;, []); //可以通过依赖注入来注入服务</span><br><span class="line">app.controller(&apos;LoginCtrl&apos;, function($scope,httpService) &#123;</span><br><span class="line">    $scope.firstName= &quot;John&quot;;</span><br><span class="line">    $scope.lastName= &quot;Doe&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//定义http公共服务</span><br><span class="line">//定义公有的http服务</span><br><span class="line">LoginModel.factory(&quot;httpService&quot;,</span><br><span class="line">    function ($http, $q) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            post: function (suburl, params) &#123;</span><br><span class="line">                var defer = $q.defer();</span><br><span class="line">                $http(&#123;</span><br><span class="line">                    method: &apos;POST&apos;,</span><br><span class="line">                    params: params,</span><br><span class="line">                    url: &quot;http://dodo.hznu.edu.cn/&quot; + suburl,</span><br><span class="line">                &#125;).success(function (data) &#123;</span><br><span class="line">                    if (data.retcode == 0) &#123;</span><br><span class="line">                        defer.resolve(data.items);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        defer.reject(data.message);</span><br><span class="line">                &#125;).error(function (data) &#123;</span><br><span class="line">                    defer.reject(data);</span><br><span class="line">                &#125;);</span><br><span class="line">                return defer.promise;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>
<p>$scope是当前的控制域，在当前控制域当中可以获得双向绑定的一些值和定义函数ng-click,ng-model等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$scope.user = &#123;&#125;;</span><br><span class="line">$scope.submit = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="angular-js脏检查机制"><a href="#angular-js脏检查机制" class="headerlink" title="angular js脏检查机制"></a>angular js脏检查机制</h3><p>监控对象的属性<br>$watch和$digest是相辅相成的，两者构成了angular作用域的核心，数据变化的响应</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>angular在scope模型上设置了一个一个监听队列，用来监听数据变化并且更新view,每次绑定一个东西<br>到view上的时候，angular 就会往$watch队列中插入一个$watch,用来检测他监控的model里面是否有变化的东西，<br>当浏览器接收到可以被angular context处理的事件时，$digest循环就会触发，遍历所有的$watch,最后更新dom.</p>
<p>$watch绑定要检查的值<br>当一个作用域创建的时候，angular会去解析模板中当前作用域下的模板结构，并且自动将插值，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;text&#125;&#125;</span><br><span class="line">ng-click = &quot;update&quot;</span><br></pre></td></tr></table></figure></p>
<p>找出来，利用$watch建立绑定，并且push到当前作用域上的$$watcher队列<br>当使用$wacth绑定了要检查的属性之后，当这个属性值发生变化了，触发$digest循环，angular会去遍历这个数组，并且用$dirty去记录$$watcher里面记录的哪些$scope的属性值发生变化，当有变化的时候，dirty设置为true,一轮脏检查执行完，会再检查dirty,如果dirty为true的话，会再次调用自己，知道dirty为true.但是为了防止死循环，一般设置当递归发生了10次或者以上，直接抛出一个错误，并且跳出循环。<br>当递归流程执行完，$digest还将变化后的$scope重新渲染到界面，$apply函数</p>
<h3 id="脏检查的实现："><a href="#脏检查的实现：" class="headerlink" title="脏检查的实现："></a>脏检查的实现：</h3><p>bind(),apply(),$scope构造函数以及构造函数的原型方法$watch(),$digest()<br>实现的四步骤<br>1.实现数据的单向绑定<br>2.实现$watch()监听数据变化<br>3.实现$digest()循环遍历每一个watch对象<br>4.实例化$scope</p>
<h3 id="触发脏检查时间"><a href="#触发脏检查时间" class="headerlink" title="触发脏检查时间"></a>触发脏检查时间</h3><p>只有当UI事件，ajax请求或者timeout延迟事件，才会触发脏检查<br>angular 每一个绑定到UI的数据，都有一个$watch对象，</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>界面到数据的修改，是由ajax,UI事件，或者timeout等回调事件来做。<br>数据到界面的呈现是由脏检查机制来做的。</p>
<p><a href="https://blog.csdn.net/u013451157/article/details/61414988" target="_blank" rel="noopener">参考博客</a><br><a href="https://juejin.im/post/5b193353f265da6e0d7a2dcd" target="_blank" rel="noopener">掘金链接</a><br>angularjs常用函数：$apply,$watch和$digest<br>$digest是一个内部函数，正常的代码都是无法应用到的，想要主动触发他，就要调用scope.$apply函数，是触发angularjs”脏检查机制”的常用公开接口，$digest循环包括2个while循环，分别是，处理$evalAsync的异步运算队列，处理$watch的watchers队列，当该循环触发后，会遍历当前$scope及其所有的子$scope上已经注册的所有watcher函数，遍历一遍所有的watcher被称为一轮脏检查，执行完一轮脏检查后，如果任何一个watcher所监听的值改变了，就会重新再进行一轮脏检查，直到所有的函数都报告其所监听的值都不再改变了。当循环结束后，才把模型的变化结果更新到DOM上去，这样做是为了防止频繁的更新。<br>表达式，angularjs不仅会渲染该数据，还会为这个值创建创建一个观察序列，之后，只要程序发生了任何事情，angularjs就会检查该观察过程中的值是否发生了修改，如果有，重新呈现表达式，运行这些观察者的过程称为脏检查。</p>
<h3 id="angular2-双向绑定机制"><a href="#angular2-双向绑定机制" class="headerlink" title="angular2 双向绑定机制"></a>angular2 双向绑定机制</h3><p>angularjs是由$scope.apply()和$scope.digest触发，angular2接入了Zonejs,监听所有的异步事件，<strong>zonejs</strong>重写了所有的异步API,<br>监听异步api,当异步api发生变化，通知angular以组件树的形式进行检查。<br>zonejs会通知angularjs可能有数据发生变化，需要检测更新。<br>脏检查就是存储变量所有的值，每当可能的值发生变化的时候，将所有变量的旧值和新值进行比较，不相等就更新视图。</p>
<p>angular js采用脏检查。而<strong>angular</strong>的核心是组件化，组件的嵌套会形成一棵树。angular的变化检测可以按组件进行，每个组件有相应的变化检测器changeDetector,可想而知，这些变化检测器也会构成一棵树。<br>angular数据流是自顶向下的，从父组件到子组件单向流动。单向数据流向保证了高效、可预测的变化检测，尽管检查了负组件之后，自组件可能会改变父组件的数据使得父组件需要再次被检查，这是不被推荐的数据处理方式。在开发模式下，Angular会进行二次检查，如果出现上述情况，二次检查就会报错：ExpressionChangedAfterItHasBeenCheckedError（关于这个问题的答案，可以在参考资料中找到）。而在生产环境中，脏检查只会执行一次。</p>
<h3 id="vue-js与angular-js区别"><a href="#vue-js与angular-js区别" class="headerlink" title="vue js与angular js区别"></a>vue js与angular js区别</h3><p>vue js更加灵活，比起angular更少专制，能够按照自己想要的方式构建应用，而非凡事都得按照vue的方法。它只不过是一层界面而已，因此你可以拿它作为页面中一个轻量的功能来使用，而不是一个完整的 SPA。<br>vue 仅仅是一个view层，只是一个如jquery搬的工具库，而angular是一个mvvm框架。<br>vue 使用数据劫持，object.defineProperty来实现，angular使用自己实现的一套模板编译规则。”脏检查机制”,来实现。相对来说vue性能更高。<br>vue 需要提供一个el对象并且进行实例化，后续所有作用范围都在el对象之下，而angular是整个html页面，一个页面，可以有多个vue实例，而angular不是这样的。</p>
<h3 id="angular常见面试题"><a href="#angular常见面试题" class="headerlink" title="angular常见面试题"></a>angular常见面试题</h3><p><a href="https://blog.csdn.net/qq_34543438/article/details/72793622" target="_blank" rel="noopener">链接1</a><br><a href="https://juejin.im/entry/5878551b570c3500620e5181" target="_blank" rel="noopener">链接2</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/js原理题的实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/js原理题的实现/" itemprop="url">js原理题的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T16:11:48+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://juejin.im/post/5d2ee123e51d4577614761f8" target="_blank" rel="noopener">参考微信</a><br>1.实现一个call函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//将改变this指向的方法挂到目标this上执行并且返回</span><br><span class="line">    Function.prototype.mycall = function (context) &#123;</span><br><span class="line"></span><br><span class="line">        if(typeof this !== &apos;function&apos;)</span><br><span class="line">            throw  new TypeError(&quot;not function&quot;);</span><br><span class="line">        context = context || window;</span><br><span class="line">        context.fn = this;</span><br><span class="line">        //获取参数</span><br><span class="line">        //从后面获取</span><br><span class="line">        let args = [...arguments].slice(1);</span><br><span class="line">        let result = context.fn(...args);</span><br><span class="line">        delete  context.fn;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.实现一个apply函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.myapply = function (context) &#123;</span><br><span class="line">       if(typeof this !== &apos;function&apos;)</span><br><span class="line">           throw new TypeError(&quot;not function&quot;);</span><br><span class="line">       context = context || window;</span><br><span class="line">       context.fn = this;</span><br><span class="line">       let result;</span><br><span class="line">       if(arguments[1])&#123;</span><br><span class="line">           </span><br><span class="line">          result =  context.fn(arguments[1]);</span><br><span class="line">       &#125;else</span><br><span class="line">           result =  context.fn();</span><br><span class="line">       delete context.fn;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.实现bind函数，思路与call相似，但是返回的是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.mybind = function (context) &#123;</span><br><span class="line">       if(typeof this !== &apos;function&apos;)</span><br><span class="line">           throw  new TypeError(&quot;not function&quot;);</span><br><span class="line">       let _this = this;</span><br><span class="line">       let arg = [...arguments].slice(1);</span><br><span class="line">       return function F() &#123;</span><br><span class="line">           //处理函数使用new的情况</span><br><span class="line">           if (this instanceof F) &#123;</span><br><span class="line">               return new _this(...arg, ...arguments)</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return _this.apply(context, arg.concat(...arguments))</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p>
<p>实现instancceof方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//instanceof 右边变量的原型位于左边变量的原型上 左边变量一直递归查找</span><br><span class="line">    function instanceOf(left,right) &#123;</span><br><span class="line">        let leftValue = left.__proto__;</span><br><span class="line">        let rightValue = right.prototype;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            if(left == null)</span><br><span class="line">                return false;</span><br><span class="line">           if(leftValue == rightValue)</span><br><span class="line">               return true;</span><br><span class="line">        leftValue = leftValue.__proto__;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现object.create方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//object.create的原理</span><br><span class="line">   //思路 将传入的对象作为原型</span><br><span class="line">   function create(obj) &#123;</span><br><span class="line">       function F() &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       F.prototype = obj;</span><br><span class="line">       return new F();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>new的本质<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//new 的本质 创建一个新对象并且将其隐式原型指向构造函数</span><br><span class="line">    function myNew(fun) &#123;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            let obj = &#123;</span><br><span class="line">                __proto__:fun.prototype</span><br><span class="line">            &#125;</span><br><span class="line">            fun.call(obj,...arguments);</span><br><span class="line">            return obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function person(name,age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    let obj = myNew(person)(&apos;chen&apos;,18);</span><br></pre></td></tr></table></figure></p>
<p>实现一个promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> //实现一个promise</span><br><span class="line">    class Promise&#123;</span><br><span class="line">        constructor(fn) &#123;</span><br><span class="line">            this.state = &apos;pending&apos;;</span><br><span class="line">            this.value = undefined;</span><br><span class="line">            this.reason = undefined;</span><br><span class="line">            let resolve = value =&gt; &#123;</span><br><span class="line">                if (this.state == &apos;pending&apos;) &#123;</span><br><span class="line">                    this.state = &apos;fullfilled&apos;;</span><br><span class="line">                    this.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            let reject = value =&gt; &#123;</span><br><span class="line">                if (this.state == &apos;pending&apos;) &#123;</span><br><span class="line">                    this.state = &apos;rejected&apos;;</span><br><span class="line">                    this.reason = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                fn(resolve, reject);</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">then(onFulfilled,onRejected)&#123;</span><br><span class="line">               switch (this.state) &#123;</span><br><span class="line">                   case &apos;fullfilled&apos;:</span><br><span class="line">                       onFulfilled();</span><br><span class="line">                       break;</span><br><span class="line">                   case &apos;rejected&apos;:</span><br><span class="line">                       onRejected();</span><br><span class="line">                       break;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现浅拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1. ...实现</span><br><span class="line">let copy1 = &#123;...&#123;x:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 2. Object.assign实现</span><br><span class="line"></span><br><span class="line">let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;)</span><br></pre></td></tr></table></figure></p>
<p>实现基本的深拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. JOSN.stringify()/JSON.parse()</span><br><span class="line">let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;</span><br><span class="line">JSON.parse(JSON.stringify(obj))</span><br><span class="line"></span><br><span class="line">// 2. 递归拷贝</span><br><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  let copy = obj instanceof Array ? [] : &#123;&#125;</span><br><span class="line">  for (let i in obj) &#123;</span><br><span class="line">    if (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">      copy[i] = typeof obj[i] === &apos;object&apos; ? deepClone(obj[i]) : obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return copy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用setTimeout模拟setInterval<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout (function () &#123;</span><br><span class="line">  // do something</span><br><span class="line">  setTimeout (arguments.callee, 500)</span><br><span class="line">&#125;, 500)</span><br></pre></td></tr></table></figure></p>
<p>js实现继承方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 借用构造函数继承实例属性</span><br><span class="line">function Child () &#123;</span><br><span class="line">  Parent.call(this)</span><br><span class="line">&#125;</span><br><span class="line">// 寄生继承原型属性</span><br><span class="line">(function () &#123;</span><br><span class="line">  let Super = function () &#123;&#125;</span><br><span class="line">  Super.prototype = Parent.prototype</span><br><span class="line">  Child.prototype = new Super()</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>实现一个eventBus<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 组件通信，一个触发与监听的过程</span><br><span class="line">class EventEmitter &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    // 存储事件</span><br><span class="line">    this.events = this.events || new Map()</span><br><span class="line">  &#125;</span><br><span class="line">  // 监听事件</span><br><span class="line">  addListener (type, fn) &#123;</span><br><span class="line">    if (!this.events.get(type)) &#123;</span><br><span class="line">      this.events.set(type, fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 触发事件</span><br><span class="line">  emit (type) &#123;</span><br><span class="line">    let handle = this.events.get(type)</span><br><span class="line">    handle.apply(this, [...arguments].slice(1))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">let emitter = new EventEmitter()</span><br><span class="line">// 监听事件</span><br><span class="line">emitter.addListener(&apos;ages&apos;, age =&gt; &#123;</span><br><span class="line">  console.log(age)</span><br><span class="line">&#125;)</span><br><span class="line">// 触发事件</span><br><span class="line">emitter.emit(&apos;ages&apos;, 18)  // 18</span><br></pre></td></tr></table></figure></p>
<p>实现双向数据绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">let input = document.getElementById(&apos;input&apos;)</span><br><span class="line">let span = document.getElementById(&apos;span&apos;)</span><br><span class="line">// 数据劫持</span><br><span class="line">Object.defineProperty(obj, &apos;text&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(&apos;获取数据了&apos;)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal) &#123;</span><br><span class="line">    console.log(&apos;数据更新了&apos;)</span><br><span class="line">    input.value = newVal</span><br><span class="line">    span.innerHTML = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 输入监听</span><br><span class="line">input.addEventListener(&apos;keyup&apos;, function(e) &#123;</span><br><span class="line">  obj.text = e.target.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>实现路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// hash路由</span><br><span class="line">class Route&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // 路由存储对象</span><br><span class="line">    this.routes = &#123;&#125;</span><br><span class="line">    // 当前hash</span><br><span class="line">    this.currentHash = &apos;&apos;</span><br><span class="line">    // 绑定this，避免监听时this指向改变</span><br><span class="line">    this.freshRoute = this.freshRoute.bind(this)</span><br><span class="line">    // 监听</span><br><span class="line">    window.addEventListener(&apos;load&apos;, this.freshRoute, false)</span><br><span class="line">    window.addEventListener(&apos;hashchange&apos;, this.freshRoute, false)</span><br><span class="line">  &#125;</span><br><span class="line">  // 存储</span><br><span class="line">  storeRoute (path, cb) &#123;</span><br><span class="line">    this.routes[path] = cb || function () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 更新</span><br><span class="line">  freshRoute () &#123;</span><br><span class="line">    this.currentHash = location.hash.slice(1) || &apos;/&apos;</span><br><span class="line">    this.routes[this.currentHash]()</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现懒加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let imgs =  document.querySelectorAll(&apos;img&apos;)</span><br><span class="line">// 可视区高度</span><br><span class="line">let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight</span><br><span class="line">function lazyLoad () &#123;</span><br><span class="line">  // 滚动卷去的高度</span><br><span class="line">  let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop</span><br><span class="line">  for (let i = 0; i &lt; imgs.length; i ++) &#123;</span><br><span class="line">    // 图片在可视区冒出的高度</span><br><span class="line">    let x = clientHeight + scrollTop - imgs[i].offsetTop</span><br><span class="line">    // 图片在可视区内</span><br><span class="line">    if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123;</span><br><span class="line">      imgs[i].src = imgs[i].getAttribute(&apos;data&apos;)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line">// addEventListener(&apos;scroll&apos;, lazyLoad) or setInterval(lazyLoad, 1000)</span><br></pre></td></tr></table></figure></p>
<p>rem实现原理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 原始配置</span><br><span class="line">function setRem () &#123;</span><br><span class="line">  let doc = document.documentElement</span><br><span class="line">  let width = doc.getBoundingClientRect().width</span><br><span class="line">  let rem = width / 75</span><br><span class="line">  doc.style.fontSize = rem + &apos;px&apos;</span><br><span class="line">&#125;</span><br><span class="line">// 监听窗口变化</span><br><span class="line">addEventListener(&quot;resize&quot;, setRem)</span><br></pre></td></tr></table></figure></p>
<p>手写ajax<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// 1. 简单流程</span><br><span class="line"></span><br><span class="line">// 实例化</span><br><span class="line">let xhr = new XMLHttpRequest()</span><br><span class="line">// 初始化</span><br><span class="line">xhr.open(method, url, async)</span><br><span class="line">// 发送请求</span><br><span class="line">xhr.send(data)</span><br><span class="line">// 设置状态变化回调处理请求结果</span><br><span class="line">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">  if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">    console.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. 基于promise实现 </span><br><span class="line"></span><br><span class="line">function ajax (options) &#123;</span><br><span class="line">  // 请求地址</span><br><span class="line">  const url = options.url</span><br><span class="line">  // 请求方法</span><br><span class="line">  const method = options.method.toLocaleLowerCase() || &apos;get&apos;</span><br><span class="line">  // 默认为异步true</span><br><span class="line">  const async = options.async</span><br><span class="line">  // 请求参数</span><br><span class="line">  const data = options.data</span><br><span class="line">  // 实例化</span><br><span class="line">  const xhr = new XMLHttpRequest()</span><br><span class="line">  // 请求超时</span><br><span class="line">  if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123;</span><br><span class="line">    xhr.timeout = options.timeout</span><br><span class="line">  &#125;</span><br><span class="line">  // 返回一个Promise实例</span><br><span class="line">  return new Promise ((resolve, reject) =&gt; &#123;</span><br><span class="line">    xhr.ontimeout = () =&gt; reject &amp;&amp; reject(&apos;请求超时&apos;)</span><br><span class="line">    // 监听状态变化回调</span><br><span class="line">    xhr.onreadystatechange = () =&gt; &#123;</span><br><span class="line">      if (xhr.readyState == 4) &#123;</span><br><span class="line">        // 200-300 之间表示请求成功，304资源未变，取缓存</span><br><span class="line">        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123;</span><br><span class="line">          resolve &amp;&amp; resolve(xhr.responseText)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject &amp;&amp; reject()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 错误回调</span><br><span class="line">    xhr.onerror = err =&gt; reject &amp;&amp; reject(err)</span><br><span class="line">    let paramArr = []</span><br><span class="line">    let encodeData</span><br><span class="line">    // 处理请求参数</span><br><span class="line">    if (data instanceof Object) &#123;</span><br><span class="line">      for (let key in data) &#123;</span><br><span class="line">        // 参数拼接需要通过 encodeURIComponent 进行编码</span><br><span class="line">        paramArr.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(data[key]))</span><br><span class="line">      &#125;</span><br><span class="line">      encodeData = paramArr.join(&apos;&amp;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    // get请求拼接参数</span><br><span class="line">    if (method === &apos;get&apos;) &#123;</span><br><span class="line">      // 检测url中是否已存在 ? 及其位置</span><br><span class="line">      const index = url.indexOf(&apos;?&apos;)</span><br><span class="line">      if (index === -1) url += &apos;?&apos;</span><br><span class="line">      else if (index !== url.length -1) url += &apos;&amp;&apos;</span><br><span class="line">      // 拼接url</span><br><span class="line">      url += encodeData</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化</span><br><span class="line">    xhr.open(method, url, async)</span><br><span class="line">    // 发送请求</span><br><span class="line">    if (method === &apos;get&apos;) xhr.send(null)</span><br><span class="line">    else &#123;</span><br><span class="line">      // post 方式需要设置请求头</span><br><span class="line">      xhr.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded;charset=UTF-8&apos;)</span><br><span class="line">      xhr.send(encodeData)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现拖拽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">  // drag处于绝对定位状态</span><br><span class="line">  let drag = document.getElementById(&apos;box&apos;)</span><br><span class="line">  drag.onmousedown = function(e) &#123;</span><br><span class="line">    var e = e || window.event</span><br><span class="line">    // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离</span><br><span class="line">    let diffX = e.clientX - drag.offsetLeft</span><br><span class="line">    let diffY = e.clientY - drag.offsetTop</span><br><span class="line">    drag.onmousemove = function (e) &#123;</span><br><span class="line">      // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离</span><br><span class="line">      let left = e.clientX - diffX</span><br><span class="line">      let top = e.clientY - diffY</span><br><span class="line">      // 避免拖拽出可视区</span><br><span class="line">      if (left &lt; 0) &#123;</span><br><span class="line">        left = 0</span><br><span class="line">      &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123;</span><br><span class="line">        left = window.innerWidth - drag.offsetWidth</span><br><span class="line">      &#125;</span><br><span class="line">      if (top &lt; 0) &#123;</span><br><span class="line">        top = 0</span><br><span class="line">      &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123;</span><br><span class="line">        top = window.innerHeight - drag.offsetHeight</span><br><span class="line">      &#125;</span><br><span class="line">      drag.style.left = left + &apos;px&apos;</span><br><span class="line">      drag.style.top = top + &apos;px&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    drag.onmouseup = function (e) &#123;</span><br><span class="line">      this.onmousemove = null</span><br><span class="line">      this.onmouseup = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现防抖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 思路:在规定时间内未触发第二次，则执行</span><br><span class="line">function debounce (fn, delay) &#123;</span><br><span class="line">  // 利用闭包保存定时器</span><br><span class="line">  let timer = null</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let context = this</span><br><span class="line">    let arg = arguments</span><br><span class="line">    // 在规定时间内再次触发会先清除定时器后再重设定时器</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(function () &#123;</span><br><span class="line">      fn.apply(context, arg)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn () &#123;</span><br><span class="line">  console.log(&apos;防抖&apos;)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(&apos;scroll&apos;, debounce(fn, 1000))</span><br></pre></td></tr></table></figure></p>
<p>实现节流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 思路：在规定时间内只触发一次</span><br><span class="line">function throttle (fn, delay) &#123;</span><br><span class="line">  // 利用闭包保存时间</span><br><span class="line">  let prev = Date.now()</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let context = this</span><br><span class="line">    let arg = arguments</span><br><span class="line">    let now = Date.now()</span><br><span class="line">    if (now - prev &gt;= delay) &#123;</span><br><span class="line">      fn.apply(context, arg)</span><br><span class="line">      prev = Date.now()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn () &#123;</span><br><span class="line">  console.log(&apos;节流&apos;)</span><br><span class="line">&#125;</span><br><span class="line">addEventListener(&apos;scroll&apos;, throttle(fn, 1000))</span><br></pre></td></tr></table></figure></p>
<p>只能说tql</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/node-js事件循环机制探索/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/node-js事件循环机制探索/" itemprop="url">node.js事件循环机制探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T15:54:08+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/node相关/" itemprop="url" rel="index">
                    <span itemprop="name">node相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每当我们运行一个程序时，都会创建一个实例，并且我们会调用一些内部线程，它们是与该实例相关联的，<strong>线程可以看做是CPU必须执行的操作单元</strong>，许多不同的线程可以与程序的单个进程相关联。<br>每当我们能运行node程序时，都会自动创建一个线程，这个线程就是我们整个代码库被执行的唯一地方，其中，还生成了<strong>事件循环</strong>的东西，这个循环的作用是<strong>安排我们唯一的线程</strong>在某个给定的时间点应该执行哪些操作。<br>事件循环实际上就是一个循环，事件循环的每次迭代都成为tick.<br>事件循环执行tick的条件是什么：<br>挂起的定时器操作(setTimeout(),setInterval());<br>挂起的操作系统任务(OS)<br>挂起的长时间运行操作的执行<br>只要其中一个操作处于挂起的状态，事件循环就会执行一个新的tick<br>执行tick<br>阶段1<br>node查看挂起的计时器内部集合。并检查传递给setTimeout()和setInterval()<br>阶段2<br>node查看挂起的os任务的内部集合，并检查哪些回调函数已经准备好被调用<br>从计算机检索文件便是一个例子<br>阶段3<br>node暂停执行，等待新事件的出现。新事件包括：新的计时器完成、新的 OS 任务完成和新的挂起操作完成。<br>阶段 4：Node 检查是否准备好调用与挂起定时器（挂起定时器与setImmediate()函数相关）相关的任何函数。<br>阶段 5：管理关闭事件，用于清理应用程序的状态。<br>node js完全是单线程吗<br>错误，node js只是js的运行时单线程的，但是node js标准库中包含的函数并非如此，其异步IO通过线程池的调用是单线程的<br>例如fs模块函数，是为了保持程序的速度和性能。<br>这些线程在哪里外包？<br>使用node js时，使用一个名为<strong>libuv</strong>的特殊库模块来执行异步操作，此库还与node的后向逻辑一起被用来管理称为libuv的特殊线程池。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/面试笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/面试笔记/" itemprop="url">面经笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T14:51:11+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.nowcoder.com/discuss/216281?type=2&amp;order=0&amp;pos=7&amp;page=1" target="_blank" rel="noopener">阿里一面凉经</a><br>nod中版本号前的^是什么意思<br>~x.y.z匹配大于x.y.z的z的最新版<br>^x.y.z匹配大于x.y.z的y.z的最新版<br>body-parser:~1.15.2 匹配1.15的最新版<br>body-parser:^1.15.2 匹配3.x.x的最新版<br><a href="https://blog.csdn.net/njweiyukun/article/details/70309066" target="_blank" rel="noopener">参考网站</a><br>http报文的格式：<br>http请求报文有：请求行，请求头，和请求体组成<br>http响应报文有：响应行，响应头，和响应体组成。<br><a href="https://www.cnblogs.com/CodingUniversal/p/7524088.html" target="_blank" rel="noopener">参考网站</a><br>npm的含义 包管理器<br>promise async 和 await的区别<br><a href="https://www.jianshu.com/p/56f16a045c55" target="_blank" rel="noopener">参考网站</a><br>tcp底层原理<br><a href="https://blog.csdn.net/qq_36242487/article/details/78849658" target="_blank" rel="noopener">参考网站</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/页面性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/页面性能优化/" itemprop="url">页面性能优化与常见的攻击</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T15:57:58+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>互联网有一项著名的<strong>8秒规则，用户在访问web页面的时候，如果时间超过了8秒就会感觉到不耐烦，如果加载需要太长的时间，他们就会放弃访问。向网页开发者表明了加载时间的重要性</strong><br>1.资源合并和压缩：主要包括有html压缩，css压缩，js的压缩和混乱文件的合并<br>从文件中去除多余的字符，例如回车，空格等。<br>css代码的压缩：是无效代码删除和css语义合并<br>js的压缩和混乱：1.无效字符的删除 2.删除注释 3代码语义的缩减和优化 4.代码的保护<br><strong>css和js的压缩是非常有必要的,压缩合并css和js可以减少网站http请求的次数，但合并文件可能会带来问题：首屏渲染和缓存失效问题</strong><br>2.非核心代码进行异步加载。<br>异步加载的3种方式-async和defer。动态脚本的创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;text/javascript&quot; src = &quot;xxx.js&quot; async = &quot;async&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>defer是在html解析完之后才会执行，如果是多个，则会按照加载的顺序依次执行，</strong><br><strong>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</strong><br>3.利用浏览器缓存<br>3.1利用前缓存 不会向服务器发送请求 直接从缓存中读取资源<br>3.2利用协商缓存 向服务器发送请求，服务器会根据request header中的一些参数来判断是否命中协商缓存<br>强缓存优先于协商缓存,若强制缓存生效则直接使用缓存。若不生效则使用协商缓存。<br><strong>用户行为对浏览器缓存的影响</strong><br>1.地址栏访问，链接跳转是正常用户行为，将会触发浏览器的缓存机制<br>2.F5刷新，浏览器会设置max-age = 0,跳过强缓存判断，会进行协商缓存判断。<br>3.ctrl + F5,跳过强缓存和协商缓存，直接从服务器获取数据<br>4.使用CDN<br><strong>浏览器的缓存只是为了提高二次访问的速度</strong>需要从网络层面进行优化，最常见的是CDN(内容分发网络),通过将静态资源(js,css,html图片)等缓存到离用户很近的相同网络运营商的CDN节点上，不但提高用户的访问速度，还能节省服务器的带宽消耗，降低负载。<br>CDN服务商在全国各个省份部署计算节点，当到达计算节点时，首先判断缓存是否有效，若有效，则立即响应缓存给用户，否则，就去内容服务器上请求数据，反馈给用户，并将内容缓存下来以便响应给后续访问的用户。<br><strong>一个地区内只要有一个用户预先加载资源，在CDN中建立了缓存，该地区中的其余用户便会因此而受益</strong><br>5.<br><strong>预解析DNS 使用该技术预先告知浏览器某些资源可能会在将来被使用，</strong><br>通过DNS预解析告诉浏览器我们未来可能从某个特定的URL获取资源，当浏览器真正使用的时候，就可以尽快完成DNS的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel = &quot;dns-prefetch&quot; href = &quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好用的性能优化方式</strong>,，<br>用户滚动到它们之前，<strong>可视区域外的图像不会加载</strong>,<br><strong>使用延迟加载使得网页加载更快</strong><br>为什么使用懒加载：1.能提升用户体验。2.减少无效资源的加载 3.防止并发加载的资源过多会阻塞js的加载。<br>预加载：另一个性能优化技术，告知浏览器某些资源可能会在未来使用到，<br>预加载把所有资源提前加载到本地，这样后面要使用的话就直接从缓存中读取。</p>
<p>懒加载和预加载的对比，<br>两者主要区别是一个是提前加载，一个是迟缓甚至不加载，懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器端压力。<br>函数防抖和节流<br>函数节流(throttle)：<strong>一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。</strong><br>有个需要频繁触发的函数，出于性能优化，在规定时间内，只让函数触发一次。<br>判断当前时间戳和上次执行的时间戳是否已经达到规定时间段。<br>函数节流：<br>1.DOM元素的拖拽功能，计算鼠标移动，射击游戏的mousedown/keydown.<br>函数防抖(debounce)：<br>防抖函数：<strong>一个需要频繁触发的函数，在规定时间内，只让最后一次生效即可，前面的不生效</strong></p>
<h2 id="常见的攻击和防御方法"><a href="#常见的攻击和防御方法" class="headerlink" title="常见的攻击和防御方法"></a>常见的攻击和防御方法</h2><p>xss(跨站脚本攻击)，通过存在安全漏洞的web网站注册用户的浏览器内运行非法的html标签或者js进行攻击<br>1.利用虚假输入表单获取信息<br>2.利用脚本窃取用户的cookie值。被害者在不知情的情况下，帮助攻击者发送恶意请求。<br>3.显示伪造的文章或者图片<br>防御XSS攻击：<br>CSP建立白名单，开发者明确告诉浏览器哪些外部资源可以加载<br>通过设置http header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-security-policy:defalut-src &apos;self&apos;</span><br></pre></td></tr></table></figure></p>
<p>通过使用转移字符<br>3.httpOnly cookie<br>预防xss攻击的最有效手段 设置httpOnly,避免网页的cookie被客户端恶意js获取，保护用户的cookie信息<br>2.csrf攻击：<br>在登录a的情况下已经设置好cookie,所以在登录恶意网站时，将a网站上的cookie信息获取。<br>防范：get请求不对数据进行修改，不让第三方网站访问到用户的cookie.阻止第三方网站请求接口，请求时必须携带验证信息，例如cookie<br>3.点击劫持：视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套到自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击，特点：隐蔽性较高，UI-覆盖点击，利用iframe或者其他标签的属性。<br>4.URL跳转漏洞：借助未验证的URL进行跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。<br>5.SQL注入，一种典型的web安全漏洞，攻击者利用这个漏洞，可以访问或者修改数据，或者利用潜在的数据库漏洞进行攻击。<br>6.OS命令注入攻击：和SQL注入差不多，SQL注入是针对数据库的，而OS注入是针对操作系统的。OS命令注入攻击指的是通过Web应用，执行非法的操作系统命令而达到攻击的目的，只要在能调用shell函数的地方就能存在被攻击的风险。防御：进行规则限制，<br>在调用系统命令前将所有传入参数进行命令行参数转义过滤。不要直接拼接命令语句，借助一些工具作拼接。，例如 Node.js 的 shell-escape npm包</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/http相关知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/http相关知识/" itemprop="url">http相关知识,tcp知识,web实时推送</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T11:30:44+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>http状态码：<br>1xx 指示信息-表示请求已经接受，继续处理 表示客户端需要提交下一步请求<br>2xx 成功 表示请求已被成功接受<br>304未修改，客户端的缓存是最新的<br>3xx 重定向 要完成请求需要进一步操作 302(重定向), 307 和 304(拿缓存)<br>4xx 客户端错误 请求有语法错误等<br>5xx 服务器端错误 服务器未能实现合法的请求</p>
<p>403 //对被请求的页面访问禁止 404 请求资源不存在 比如输入了错误的URL<br>post 向URL指定的资源提交数据<br>put 提交数据 put指定了在服务器上的位置 而post没有<br>head 只请求页面的首部<br>delete 方法：删除服务器上的某资源<br>options 方法：它用于获取当前 URL支持的方法，如果请求成功，会有一个 Allow 的头包含类似“GET,POST”这样的信息</p>
<p>持久连接：只要任意一端没有提出明确断开连接，则保持TCP的连接状态</p>
<p>https的工作原理：！！！<br>https在HTTP上建立了SSL加密层，对传输数据进行了加密，是http的安全版<br>主要作用：<br>1.对数据进行加密，并建立一个信息安全通道，来保证传输数据的过程中的数据安全<br>2.对网站服务器进行真实身份认证<br>http使用的是明文进行发送。<br>完成了数据隐私性传输，完整性的校验，身份认证<br>http先和SSL通信，再由SSL和tcp通信。<br>对称加密：加密和解密用同一个秘钥，将秘钥也需要发送给对方。<br>非对称加密：私有秘钥不能让任何人知道，公开秘钥可以随意发布<br>使用公开秘钥加密的方式：发送密文的一方使用对方的公开秘钥进行加密，<br>对方收到后，利用私钥进行解密。<br>非对称加密特点是信息一传输多，服务端只需要维护一个<strong>私钥就能和多个客户端进行通信</strong></p>
<p>http使用的方式：在交换秘钥环节使用非对称加密方式，之后的建立通信交换报文阶段采用对称加密方式</p>
<p><strong>发送密文的一方使用对方的公开秘钥加密处理对称的秘钥，然后对方利用自己的私钥进行解密拿到对称的秘钥，这样可以确保秘钥在安全的情况下，使用对称秘钥进行加密</strong></p>
<p>解决报文是否可能遭到篡改 – 数字签名<br>确定消息是由发送方签名并且发过来的，因为别人假冒不了<br>数字签名保证消息的完整性，证明数据没有被篡改<br>文本用hash生成消息摘要 再由私钥生成数字签名，发送给接受者<br>接受者只有用发送者的公钥才能进行解密，然后用hash函数产生摘要信息。</p>
<p>解决通信双方身份可能被伪装的问题：数字证书<br>数字认证机构处于客户端和服务器双方都可信赖的第三方机构的立场上</p>
<p>https通信过程<br>1.client发送https请求 server的连接端口为443<br>2.server把事先配置好的公钥证书返回给客户端<br>3.client验证公钥证书<br>4.clent使用<strong>伪随机数产生对称秘钥，然后用证书的公钥加密,发送给server</strong><br>5.server利用自己私钥进行解密，client和server拥有了相同的私钥<br>6.server使用对称秘钥加密明文内容，发送给client<br>7.client使用对称秘钥解密密文，得到明文内容<br>8.client再次发送http,使用对称秘钥加密请求B,然后server使用对称秘钥解密</p>
<p>tcp3次握手过程<br>client -&gt; server发送<br>server 接收后 回复ack<br>client收到ack后回复ack</p>
<p>问：为什么建立连接需要3次<br>答：防止失效的连接请求报文段被服务端接收，从而产生报错 A是client,B是server<br>发送的失效报文到达时，A和B已经断开了，但是B又建立了连接，向A发送数据，所以造成资源浪费<br>tcp 4次挥手<br>客户端打算关闭连接<br>tcp停止释放报文，fin = 1<br>服务器接收到后确认，确认号是ack + 1<br><strong>客户端到服务器这个连接已经释放，但是服务器到客户端还未释放，client不能发送，server不能接受，但是server可以发送，client可以接受</strong><br>因为tcp是全双工的，两端可以同时发送和接收数据</p>
<p>服务器到客户端发送fin<br>客户端接收到后，必须发出请求，ack = 1<br>运输层中有传输控制协议tcp和用户数据协议udp<br>dns查看 浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存</p>
<p>http/2相比于http/1，可以说大幅度提高了网页的性能，只需要升级到该协议就能减少很多之前需要做的性能优化工作，<br>当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。<br>http/3相对于http/2又是一个提升<br>http协议：<br>处于计算机网络中的应用层，http是建立在tcp协议之上，<strong>所以http协议的瓶颈及其优化技巧都是基于tcp本身的特性</strong>,<br>例如tcp建立的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间</p>
<p>http/1.x缺陷<br>连接无法复用 每次都会导致3次握手和慢启动，慢启动对大量小文件请求影响较大。<br>head-of-line blocking(holb) 导致宽度无法被充分利用，以及后续请求被阻塞<br>http/1.x在传输数据时，所有传输内容都是明文，客户端和服务端都无法验证对方身份，这在一定程度上无法保证数据的安全性</p>
<p>http/2方法/状态码/语义都与http/1.x一样，http/2基于SPDY3协议，专注于<strong>性能</strong>,最大的目标是在用户和网站之间只用一个连接。</p>
<p>http/2采用二进制格式传输数据，而非http1.x的文本格式。<br>http/2采用了多路复用技术。<br>解决了同一个域名下的请求数量的问题。<br>同时也更容易实现全速传输。<br>http/2<br>同域名下所有通行都在单个连接上完成。<br>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。<br>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。<br>并行交错地发送多个请求，请求之间互不影响。<br>并行交错地发送多个响应，响应之间互不干扰。<br>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。<br>http/2只采用一个tcp协议，<br>http/2压缩了header<br>server-push也叫cache push<br>某些资源客户端一定会请求，可以采用服务端push方式，提前给客户端必要的资源。<br>http3协议是基于QUIC协议，QUIC协议是基于UDP协议。<br>QUIC新功能：<br>0-RTT 通过使用类似TCP快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0-RTT建立连接可以说是QUIC相比HTTP2最大的性能优势。<br>https建立一次完全握手需要3个RTT，而QUIC建立在UDP基础上，同时又实现了0RTT的安全握手，所以在大部分情况下，只需要0个RTT就能实现数据传送。<br>同一条QUIC连接上可以创建多个stream,来发送多个http请求。<br>QUIC有向前纠错机制，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。<br>http/1.x有连接无法复用，队头阻塞，协议开销大和安全因素等多个缺陷。<br>http/2通过多路复用，二进制流，Header等压缩技术，极大的提高了性能。但是还是存在性能问题。<br>quic基于udp协议来实现，是http/3中的底层支撑协议，该协议基于UDP，又吸取了TCP中的精华，实现了既块又可靠的协议传输。</p>
<p>web实时推送机制 将后台发生的变化主动的，实时的传送到浏览器端。而不需要用户端主动刷新页面<br><strong>轮询</strong>是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次，缺点：连接数会非常多，一个接受，一个发送，<br><strong>而且每次发送请求都会有http的header，会很耗流量，也会消耗cpu的利用率。
</strong>长轮询<strong>客户端发送http给服务器后，看有没有新消息，如果没有新消息，就一直等待，当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节),但是真正被服务器用到的数据却很少，<br>这样的数据在网络上周期性的传输，</strong>难免对网络带宽是一种浪费<strong>
</strong>iframe<strong>流方式是在页面中插入一个隐藏的iframe,利用其src属性在服务器和客户端之间建立一条长连接，服务器想iframe传输数据，来实时更新页面。<br>优点：消息能够实时到达；浏览器兼容好<br>缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。
</strong>web socket<strong>机制，web服务器和客户端之间建立连接后，之后所有的通信都依靠这个专用协议进行。任意一方可直接向对方发送报文。<br>http是半双工协议，web socket是全双工协议。<br>tcp和udp的比较<br>tcp/ip是互联网相关的各类协议族的总称，例如tcp,udp,ip,ftp,http,icmp,smtp等<br>是互联网的基础，一系列网络协议的总称，<br>这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。<br>tcp/ip的4层模型<br>链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层<br>udp协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种</strong>无连接的协议<strong>。<br>面向无连接，不需要和tcp一样在发送数据前建立3次握手。<br>有单播，多播，广播的功能。<br>支持一对一，一对多，多对多，多对一的方式。<br>udp是面向报文的，是不可靠的。<br>头部开销小，传播数据报文是很高效的<br>两台计算机通信时，需要畅通并且可靠。<br>当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 TCP。
</strong>tcp协议全称是传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议<strong>.<br>3次握手和4次挥手<br>tcp仅支持单播传输<br>ajax是一种</strong>异步请求数据的web开发技术**,在不需要重新刷新页面的情况下，ajax通过异步请求加载后台数据，并在前端显示。<br>ajax目的是提高用户体验，减少网络数据传输量<br>基于浏览器提供的xmlhttprequest对象，使得浏览器可以发出http请求和接收到http响应。<br>浏览器接着干自己的事情</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/伪数组和promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/伪数组和promise/" itemprop="url">伪数组和promise,async,await的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T10:09:59+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>何为伪数组<br>如果一个对象的所有键名都是正整数或者0，并且具有Length属性，那么这个对象就很像数组，语法上就非常像伪数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    0:&apos;a&apos;,</span><br><span class="line">    1:&apos;b&apos;,</span><br><span class="line">    2:&apos;c&apos;,</span><br><span class="line">    length:3</span><br><span class="line">&#125;;</span><br><span class="line">obj[0] //&apos;a&apos;</span><br><span class="line">obj[1] //&apos;b&apos;</span><br><span class="line">obj.length //3</span><br></pre></td></tr></table></figure></p>
<p>对象obj是一个类似数组的对象，但是类似数组的对象<strong>并不是数组</strong>,因为它们不具备数组的方法，对象obj没有数组的push方法。<br>典型的”类似数组的对象”是<strong>函数的arguments对象，以及大多数DOM元素集，还有字符串</strong>/<br>数组的slice方法可以将类似数组的对象转变成真正的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6提供了array.from方法，将伪数组转化成真正的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let btns = document.getElementByTagName(&quot;button&quot;);</span><br><span class="line">console.log(btns);</span><br><span class="line">Array.from(btns).forEach(item =&gt; &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>将伪数组转化成真正的数组<br>扩展运算符(…)也可以将某些数据结构转化为数组。<strong>只不过需要在背后调用遍历器接口Symbol.iterator</strong><br>值得注意的是如果一个对象没有部署遍历器接口，使用扩展运算符是无法将类似数组对象转换成数组的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    return [...arguments];</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);</span><br></pre></td></tr></table></figure></p>
<p>Array.of相当于Array的构造器，会创建一个包含所有传入参数的数组，而不管参数的数量与类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = Array.of(2); </span><br><span class="line">console.log(items[0]); //2</span><br><span class="line">console.log(items.length); //2</span><br></pre></td></tr></table></figure></p>
<h2 id="promise相关"><a href="#promise相关" class="headerlink" title="promise相关"></a>promise相关</h2><p>异步编程模式在前端开发中，显得越来越重要，从最开始的XHR到封装后的ajax都在试图解决异步编程中的问题，<br>传统ajax中，当异步请求之间的数据存在依赖关系的时候，就可能产生出多层的回调嵌套问题。俗称”回调地狱”,<br>promise的出现让我们告别了回调函数，写出了更加优雅的代码。<br>async/await的到来使得异步代码看起来像同步代码的替代方法。<br>promise的原理：<br>对一种异步操作的封装，可以通过独立的接口添加在异步操作执行成功，失败时执行的方法，主流的规范是promise/a+<br>promise的状态：pending初始状态,fulfilled成功,rejected失败.<br>promise实例必须实现then这个方法 then必须返回2个函数作为参数(resolve,reject)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    var img = document.createElement(&quot;img&quot;);</span><br><span class="line">    img.onload = function() &#123;</span><br><span class="line">        resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = function()&#123;</span><br><span class="line">        reject(&quot;图片加载失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">result.then(</span><br><span class="line">    function(img)&#123;</span><br><span class="line">console.log();</span><br><span class="line">    &#125;.then(function(img)&#123;</span><br><span class="line">        console.log();</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>promise的级联操作<br>result1.then(function(img){</p>
<p>}).then(function(img){</p>
<p>}).catch(function(ex){<br>    console.log();<br>})<br>promise的all方法，可以并行执行所有任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(resolve,500,&apos;p1&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">var p2 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(resolve,600,&apos;p2&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">promise.all([p1,p2]).then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>promise.race接收一个包含多个promise对象的数组，只要一个完成，就执行success.<br>async/await是写异步代码的新方式，优于回调函数和promise.<br>async/await基于promise实现的。不能用于普通的回调函数。<br>。。。。。。。与promise是一样的，是非阻塞的。<br>。。。。。。。使得异步代码看起来像同步代码一样，没有回调函数。但是改变不了js单线程，异步的本质。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const load = async function()&#123;</span><br><span class="line">    const result1 = await loading(src1);</span><br><span class="line">    console.log(result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="async-await相关"><a href="#async-await相关" class="headerlink" title="async,await相关"></a>async,await相关</h2><p>async/await较promise有诸多好处<br>1.简洁。使用async/await明显节约了不少代码。不需要写.then()方法。<br>2.中间值。调用promise1,使用promise1返回的结果去调用promise2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const makeRequest = async () =&gt; &#123;</span><br><span class="line">    const value1 = await promise1();</span><br><span class="line">    const value2 = await promise2(value1);</span><br><span class="line">    return promise3(value1,value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/笔试笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/笔试笔记/" itemprop="url">笔试笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T20:13:27+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/css相关/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.实现如下布局<br><img src="/writenExp/1.png" width="50%" height="50%"><br>注意header,footer,content的划分和命名规范，flex布局，和当容器设置为父容器的百分号时，注意设置body和html的 body html{margin:0;height:100%}<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line">html &#123;</span><br><span class="line"></span><br><span class="line">    margin:0 auto;</span><br><span class="line"></span><br><span class="line">    padding:0;</span><br><span class="line"></span><br><span class="line">    height: 100%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.header&#123;</span><br><span class="line"></span><br><span class="line">    border: solid 1px green;</span><br><span class="line">    height:100px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.leftLogo&#123;</span><br><span class="line">    margin: 10px 0px 10px 10px;</span><br><span class="line">    width: 80px;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.rightUserName&#123;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line">    text-align: right;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin: 60px 10px 0px 0px;</span><br><span class="line">    height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content&#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.leftContent&#123;</span><br><span class="line">    flex-grow:1 ;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.aside&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line">    text-align: left;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    border:solid 1px black;</span><br><span class="line">    text-align: center;</span><br><span class="line">    height: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle-down&#123;</span><br><span class="line">    width:0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    border-bottom: 5px solid black;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;triangle-down&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>参考网站<br><a href="https://blog.csdn.net/carrybest/article/details/54286137" target="_blank" rel="noopener">html body设置宽高</a><br><a href="https://www.cnblogs.com/dreamperson/p/9367008.html" target="_blank" rel="noopener">flex布局</a><br>2.实现如下函数：<br>uniqueryfy([1,0,0]) 返回[1,0]<br>uniquerfy([{id:1,name:1},{id:1,name:2}],a =&gt; a.id)返回[{id:1,name:1}]<br>后面是过滤的规则 或者为 a =&gt; a.sex + a.name<br>方法：使用set的方法来做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function uniquery(arr,rules) &#123;</span><br><span class="line">     if(rules == null)&#123; //判断rule为空的情况下</span><br><span class="line">         var set = new Set();</span><br><span class="line">         arr.forEach(function (item,index,arr) &#123;</span><br><span class="line">             if(!set.has(item))</span><br><span class="line">                 set.add(item);</span><br><span class="line">         &#125;)</span><br><span class="line">         return Array.from(set);//伪数组的转变 将set转化为数组</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         //保存key 新的数组来保存所有的key和value</span><br><span class="line">         var set = new Set();</span><br><span class="line">         var newArr = [];</span><br><span class="line">         arr.forEach(function (item,index,arr) &#123;</span><br><span class="line">             var key = rules(item);</span><br><span class="line">             if(!set.has(key))&#123;</span><br><span class="line">                 set.add(key);</span><br><span class="line">                 newArr.push(item);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;)</span><br><span class="line">         return newArr;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<br><img src="/writenExp/03.jpeg" width="50%" height="50%"><br>三角形的绘制可以通过border来 transparent设置两边为透明即可了。<br><a href="https://www.jianshu.com/p/9a463d50e441" target="_blank" rel="noopener">三角形绘制参考网站</a><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">.total&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br><span class="line">.top&#123;</span><br><span class="line">    background: black;</span><br><span class="line">    color: white;</span><br><span class="line">    width: 100px;</span><br><span class="line">    display: flex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.trangle-down&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-top: 5px solid white;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.content-top&#123;</span><br><span class="line">    background: white;</span><br><span class="line">    color: red;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.trangle-up&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-bottom: 5px solid red;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;total&quot; onmouseleave=&quot;closeMenu()&quot;&gt;</span><br><span class="line">&lt;div class=&quot;top&quot; onmouseenter=&quot;opemMenu()&quot;&gt;</span><br><span class="line">    客户服务</span><br><span class="line">    &lt;div class=&quot;trangle-down&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content-top&quot;&gt;</span><br><span class="line">        客户服务</span><br><span class="line">        &lt;div class=&quot;trangle-up&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;帮助中心&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function opemMenu() &#123;</span><br><span class="line">        (document.getElementsByClassName(&quot;content&quot;)[0]).style.display = &quot;block&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function closeMenu() &#123;</span><br><span class="line">        (document.getElementsByClassName(&quot;content&quot;)[0]).style.display = &quot;none&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.实现如下函数，今天是小明生日，他希望知道余下还剩下多少时间，<br><span id="clock"></span><br>要求：<br>1.使用原生js<br>2.时间格式 时：分：秒<br>3.自动补全2位，06:06:06<br>4.过了凌晨12点，时钟自动停止<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;span id = &quot;clock&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function PrefixInteger(num, n) &#123;</span><br><span class="line">        return (Array(n).join(0) + num).slice(-n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   var interval =  setInterval(function () &#123;</span><br><span class="line">        var curDate = new Date(); //获取当前时间</span><br><span class="line">        var nextDate = new Date(curDate.getTime() + 24 * 60 * 60 * 1000);  //获取下一天</span><br><span class="line">        var next = new Date(nextDate.getFullYear(),nextDate.getMonth(),nextDate.getDate());//获取下一天的0时刻</span><br><span class="line">        var time = next - curDate; //求得时间差</span><br><span class="line">        var hours =(parseInt((time %(1000 * 60 * 60 * 24)) / (1000 * 60 * 60)));</span><br><span class="line">        var minutes = parseInt((time % (1000 * 60 * 60)) / (1000 * 60));</span><br><span class="line">        var seconds = parseInt((time % (1000 * 60)) / 1000);</span><br><span class="line">       if(hours == 0 &amp;&amp; minutes == 0 &amp;&amp; seconds == 0) //如果都为0了 说明到头了 就清除</span><br><span class="line">         clearInterval(interval);</span><br><span class="line">       var str = &quot;&quot;;</span><br><span class="line">            str += PrefixInteger(hours, 2) + &quot;:&quot;; //补全</span><br><span class="line">            str += PrefixInteger(minutes, 2) + &quot;:&quot;;</span><br><span class="line">            str += PrefixInteger(seconds, 2);</span><br><span class="line"></span><br><span class="line">        document.getElementById(&quot;clock&quot;).innerText = str;</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>5.实现如下页面布局<br>已知header,footer高度为48px,宽度为100%,aside宽度均为320px,实现该布局<br><img src="/writenExp/04.jpg" width="50%" height="50%"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">    html &#123;</span><br><span class="line"></span><br><span class="line">        margin:0;</span><br><span class="line"></span><br><span class="line">        padding:0;</span><br><span class="line"></span><br><span class="line">        height: 100%;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">    &#125;</span><br><span class="line">    .header&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        height: 48px;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .footer&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        height: 48px;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .main&#123;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-grow: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    .aside&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">        width: 320px;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">        flex-grow: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    header</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;aside&quot;&gt;</span><br><span class="line">        aside</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        content</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;aside&quot;&gt;</span><br><span class="line">        aside</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    footer</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.将函数fn的执行上下文改为obj,返回fn执行后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function HelloWorld(fn,obj) &#123;</span><br><span class="line">    return fn.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">HelloWorld(</span><br><span class="line">    function() &#123;</span><br><span class="line">        return this.firstname + &apos;&apos; + this.lastname + &apos;|&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;firstname:&quot;hello&quot;,lastname:&quot;world&quot;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>7.实现如下布局<br><img src="/writenExp/05.jpeg" width="50%" height="50%"><br><a href="https://www.cnblogs.com/daxiong/articles/3158630.html" target="_blank" rel="noopener">关键是三角形冒泡的实现</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .tag&#123; width:500px; position:relative;border-radius: 5px&#125;</span><br><span class="line">    .tag em&#123;display:block; border-width:20px; position:absolute; bottom:150px; left:500px;border-style:solid  ; border-color: transparent  transparent transparent white;font-size:0; line-height:0;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body style=&quot;background-color: #666666&quot;&gt;</span><br><span class="line">&lt;div style=&quot;display: flex&quot;&gt;</span><br><span class="line">&lt;div class=&quot;tag&quot; style=&quot;width: 500px;background-color: white&quot;&gt;&lt;h1&gt;《倩女幽魂2.0》来看看我的&lt;br&gt;最新梦岛动态!&lt;/h1&gt;</span><br><span class="line">    &lt;em&gt;&lt;/em&gt;</span><br><span class="line">&lt;div style=&quot;display: flex&quot;&gt;</span><br><span class="line">&lt;p style=&quot;font-size: 25px;color: #999999&quot;&gt;上大神，发梦岛，不进游戏也能&lt;br&gt;撩！&lt;/p&gt;</span><br><span class="line">&lt;img src=&quot;https://nos.netease.com/hi-163-qn/upload/201909/04/ff2e1e80cef611e9a213af01a189a04b.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;img style=&quot;width: 150px;height: 150px;margin-left: 30px&quot; src=&quot;https://nos.netease.com/hi-163-qn/upload/201909/04/ff2e1e80cef611e9a213af01a189a04b.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>8.实现如下函数<br><img src="/writenExp/06.jpeg" width="50%" height="50%"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/vue学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/vue学习笔记/" itemprop="url">vue视频学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T20:13:27+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/vue相关/" itemprop="url" rel="index">
                    <span itemprop="name">vue相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每个vue实例在被创建时候都要经历一系列的初始化过程，<br>设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM，<br>同时这个过程会运行一些<strong>生命周期函数钩子</strong>,<br>created:实例被创建<br>mouted,updated,destroyed.<br>计算属性的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&quot;example&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:&quot;hello</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        vm.reverseMessage依赖于message,所以message一旦变化 reverseMessage就会变化</span><br><span class="line">        reverseMessage:function() &#123;</span><br><span class="line">        </span><br><span class="line">            return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        fullName:&#123;</span><br><span class="line">            //get和set方法</span><br><span class="line">            get:function()&#123;</span><br><span class="line">             return this.firstName</span><br><span class="line">            &#125;</span><br><span class="line">            set:function(newValue)&#123;</span><br><span class="line">                this.firstName = &quot;ckq&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>计算属性是基于它们的响应式依赖进行缓存的，只有相关响应式发生了变化，才会重新求值。<br>message没变化，多次访问reverseMessage。计算属性还是返回之前计算的结果。<br>而不必再次执行函数。<br>侦听属性，利用watch:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">firstName:function(val)&#123;</span><br><span class="line">    this.fullName = val + this.lastName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过class和style绑定属性的时候，可以通过对象或者是数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class = &quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>active这个class是否加载决定于isActive属性是否为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    classObj:&#123;</span><br><span class="line">        active:true,</span><br><span class="line">        &apos;text-danger&apos;:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class = &quot;[active,error]&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>内联样式的绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style = &quot;&#123;color:active&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>v-if用于条件渲染<br>v-if与v-else联合使用 v-else-if联合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if = &quot;ok&quot;&gt;</span><br><span class="line">&lt;h1&gt;title&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;p1&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p>v-if与v-show的区别<br><strong>v-if是真正的条件渲染，当为false时会删除dom</strong><br><strong>而v-show是是会修改其css属性来展现与否。</strong><br><strong>当不存在的时候，v-if是从dom中移除，v-show为隐藏，不从dom中移除。</strong><br>v-for的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for = &quot;(item,index) in items&quot;&gt;</span><br><span class="line">&lt;li v-for = &quot;(value,name,index) in object&quot;&gt;</span><br><span class="line">&#123;&#123;index&#125;&#125; --&#123;&#123;item.message&#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure></p>
<p>当vue正在更新使用v-for渲染的元素列表时，使用”就地跟新”原则，<br>如果数据项的顺序被改变，vue将不会移动dom元素来匹配数据项的顺序，而是就地跟新每个元素，并且确保在每个索引位置都被<br>正确的渲染。类似于vue 1.x中的track-by = “$index”<br>可以使用key进行绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for = &quot;item in items&quot; v-bind:key = &quot;item.id&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>利用响应式<br>Vue.set(vm.items,indexOfItems,value);<br>当处于同一个节点时，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中，当你只想为部分项渲染节点时，这种优先级机制十分有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li is = &quot;todo-item&quot; v-for = &quot;(todo,index) in todos&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>的 is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要,这么做实现的效果与<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;todo-item&gt;</span><br></pre></td></tr></table></figure></p>
<p>相同。<br>但是可以避开一些潜在的浏览器解析错误。<br>v-on:click.stop = “doThis”<br>v-on:submit.prevent = “on<br>v-on:keyup.13 = “submit”<br>@click.ctrl = “onclick”<br>v-model在表单input,textarea以及select上创建数据的双向绑定<br>v-model本质上还是语法糖，负责监听用户的输入事件并且更新数据。并对一些极端场景进行一些特殊处理。<br>会忽略所有表单的check,value,select值。<br>总是将vue实例的数据作为数据来源。应该通过js在组件中data选项声明初始值。<br>vue自定义组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//vue自定义组件</span><br><span class="line">  Vue.component(&apos;button-counter&apos;,&#123;</span><br><span class="line">      data:function () &#123;</span><br><span class="line">          return&#123;</span><br><span class="line">              count:0</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template:&apos;&lt;button v-on:click = &quot;count++&quot;&gt;&apos;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>与new Vue接收相同的选项 例如data,computed,watch,methods等以及生命周期函数钩子<br><strong>data必须是一个函数。而不是一个对象，因此每个实例可以维护一份被返回对象的独立的拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:function()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Vue.component是全局注册的<br>通过props向子组件传递数据<br>一个值传递给props，就变成了组件实例的一个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog&apos;,&#123;</span><br><span class="line">    props:[&apos;title&apos;],</span><br><span class="line">    template:&apos;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>就像访问data中的数据是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post :key = &apos;post.id&apos; :title = &apos;post.title&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>每个组件必须要有一个根元素，可以将模板的内容包裹在一个根元素内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;div v-html = &quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>component的is属性来切换组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>
<p>vue组件注册通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue.component(&apos;my-comment-name&apos;,&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">//使用时候</span><br><span class="line">&lt;my-component-name&gt;&lt;/my-component-name&gt;</span><br></pre></td></tr></table></figure></p>
<p>全局注册往往不理想，局部注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ComponentA = &#123;&#125;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;component-a&apos;:ComponentA,</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>导入组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import ComponentA from &apos;./ComponentA&apos;;</span><br><span class="line">export default&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>props传递对应的值类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    title:String,</span><br><span class="line">    likes:Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提供了类型检测 在使用时。<br><strong>任何类型的值都可以传递给props</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post v-bind:likes = &quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post v-bind:is-publish = &quot;false&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=&quot;&#123;</span><br><span class="line">    name: &apos;Veronica&apos;,</span><br><span class="line">    company: &apos;Veridian Dynamics&apos;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure></p>
<p>props都是单向数据流的传递 父级props的跟新会向下流动到子组件中，但是反过来是不会的。<br>这样可以阻止子组件意外改变父组件的状态<br>每次父组件发送变化，子组件props都会刷新为最新的值<br>注意：js中对象和数组都是通过引用传入的，所以对于一个数组或者对象类型的props,<strong>在子组件中改变这个对象或数组本身将会影响在父组件中的状态。</strong><br>注意prop会在一个组件实例创建之前进行验证，所有实例的属性，例如data,computed等在函数中是不可用的。<br>事件名：事件名不存在任何自动化的大小写转换。而是触发的事件名必须匹配这个事件所用的名称<br>触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&quot;myEvent&quot;)</span><br></pre></td></tr></table></figure></p>
<p>随后在组件上绑定事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:my-event = &quot;doSomthing&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>自定义事件重点看</strong><br>自定义指令，在页面打开后，应该自动聚焦到输入框上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;,&#123;</span><br><span class="line">    inserted:function(el)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="指令的钩子函数"><a href="#指令的钩子函数" class="headerlink" title="指令的钩子函数"></a>指令的钩子函数</h2><p><strong>bind</strong>:只调用一次，指令第一次绑定到元素时调用，在这里可进行一次性的初始化操作。<br><strong>inserted</strong>:被绑定元素插入到父节点时调用，(仅保证父节点存在，但不一定已被插入到文档中)<br><strong>updated</strong>:所有组件的VNode更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。<br><strong>componentUpdated</strong>:指令所在组件的VNode及其子VNode全部跟新后调用<br><strong>unbind</strong>:只调用一次，指令与元素解绑时调用。<br>尝试使用render函数来做渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;anchor&apos;,&#123;</span><br><span class="line">    render:function(createElement)&#123;</span><br><span class="line">        return createElement(</span><br><span class="line">            &apos;h&apos; + this.level, //标签名称</span><br><span class="line">            this.$slots.default//子节点数组</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        level:&#123;</span><br><span class="line">            type:Number,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>createElement返回的是createNodeDescription,因为它所包含的信息会告诉vue页面上需要渲染什么节点。包括其子节点的描述信息。<br>插件的使用<br>通过全局的方法Vue.use()来加载使用插件<br>需要在new Vue()之前使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Vue = require(&apos;vue&apos;);</span><br><span class="line">var vueRouter = require(&apos;vue-router&apos;);</span><br><span class="line">Vue.use(vueRouter);</span><br></pre></td></tr></table></figure></p>
<p>过滤器<br>双括号插值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;message | capitalize&#125;&#125;</span><br><span class="line">filters:&#123;</span><br><span class="line">    capitalize:function(value)&#123;</span><br><span class="line">        if(!value)</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">        value = value.toString();</span><br><span class="line">        return value.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>过滤器的连续使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>将过滤器A执行完的结果传递给过滤器B<br>vue单文件的预处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang = &quot;jade&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">ccc</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;.</span><br><span class="line">    components:&#123;</span><br><span class="line">        otherComponents</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>vue进行<strong>异步跟新DOM</strong>的情况，一些依赖DOM更新结果的断言必须在<br>vue.nextTick中回调中进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.nextTick(() =&gt; &#123;</span><br><span class="line">    expect(vm.$el.textContent).toBe(&apos;foo&apos;);</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV</span><br></pre></td></tr></table></figure></p>
<p>vue源码根据process.env.NODE_ENV决定是否启用生产环境模式，默认为开发环境模式。</p>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>通过nuxt.js搭建服务端渲染。nuxt是一个基于vue生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。<br>this.$nextTick保证元素被挂载到dom中才触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    // 代码保证 this.$el 在 document 中</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="vue中slot的使用"><a href="#vue中slot的使用" class="headerlink" title="vue中slot的使用"></a>vue中slot的使用</h3><p>vue中slot的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;span&gt;1111&lt;/span&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:&quot;&lt;div&gt;这是一个div标签&lt;/div&gt;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>child内部的span等标签会被div等所有的覆盖掉 没有slot的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;computer&gt;</span><br><span class="line">       &lt;div slot = &quot;CPU&quot;&gt;ddd&lt;/div&gt;</span><br><span class="line">       &lt;div slot = &quot;GPU&quot;&gt;GPU&lt;/div&gt;</span><br><span class="line">   &lt;/computer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;computer&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">&lt;slot name = &quot;CPU&quot;&gt;CPU插槽&lt;/slot&gt;</span><br><span class="line">&lt;slot name = &quot;GPU&quot;&gt;GPU插槽&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>根据name进行绑定 将slot具体渲染成对应组件</p>
<p>单个slot的情况<br>简单来说，使用slot标签，可以将<span>1111</span>放到子组件中想让他显示的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span&gt;1111&lt;/span&gt;</span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>子组件内部的slot标签会被渲染成<span>1111</span>所以可以将父组件中的传过来<br>有多个标签的时候也会被插入，被当成一个slot来看待<br>具名slot(有名称的slot)<br>将放在子组件里的不同html标签放在不同的位置<br>父组件在要分发的标签里面添加slot = “name名”的属性<br>子组件在对应的分发位置的slot标签里面，添加name = “name”属性，<br>然后会将对应的标签放在位置里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span slot = &quot;one&quot;&gt;one&lt;/span&gt;</span><br><span class="line">       &lt;span slot = &quot;two&quot;&gt;two&lt;/span&gt;</span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot name = &quot;two&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;br&gt;</span><br><span class="line">这是&lt;slot name = &quot;one&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>将父标签里的two渲染到子组件里的第一个，将父标签里的one渲染到子组件李的第二个<br>没有slot的话，将会显示默认的值。<br>也就是没有将父组件中的slot插入到子组件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span slot = &quot;one&quot;&gt;one&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot name = &quot;two&quot;&gt;no two&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;br&gt;</span><br><span class="line">这是&lt;slot name = &quot;one&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>slot = two 没有标签，因此显示内部的no two<br>作用域插槽是一种特殊类型的插槽，用作一个(能被传递数据的)可重用模板，来代替已经渲染好的元素，<br>在子组件中，只需要将数据传递到插槽，就想你将prop传递给组件一样，<br>在父级中，具有特殊属性slot-scope的template的元素必须存在，表明它是作用域插槽的模板。<br>slot-scope的值被用作一个临时变量，此变量收集从子组件传递过来的props<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;template slot-scope = &quot;props&quot;&gt;</span><br><span class="line"></span><br><span class="line">           &lt;p&gt;hello from parent&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&#123;&#123;props.tt&#125;&#125;&lt;/p&gt;</span><br><span class="line">       &lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">&lt;slot tt = &quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>将子组件的传递到父组件中,如下示例，当子组件循环的时候，某一部分dom结构由外部传递进来，<br>使用作用域插槽，子组件可以向父组件插槽传递数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;root&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;template slot-scope = &quot;props&quot;&gt;</span><br><span class="line">            &lt;p&gt;&#123;&#123;props.item&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;child&apos;,&#123;</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list:[1,2,3,4,5]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">&lt;slot v-for=&apos;item of list&apos; :item = item&gt;&lt;/slot&gt;</span><br><span class="line">`</span><br><span class="line">    &#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&quot;#root&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>作用域插槽，统一为渲染的模板。为不同的渲染添加值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">    &lt;my-list title=&quot;caokaiqiang&quot; :items=&quot;shapes&quot;&gt;</span><br><span class="line">        &lt;div slot-scope=&quot;vv&quot;&gt;&#123;&#123;vv.name&#125;&#125;&lt;small&gt;（&#123;&#123;vv.sides&#125;&#125;条边）&lt;/small&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/my-list&gt;</span><br><span class="line"></span><br><span class="line">    &lt;my-list title=&quot;颜色&quot; :items=&quot;colors&quot;&gt;</span><br><span class="line">        &lt;div slot-scope=&quot;ad&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;colorbox&quot; :style=&quot;&#123;background:ad.hex&#125;&quot;&gt;&#123;&#123;ad.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/my-list&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&apos;my-list&apos;, &#123;</span><br><span class="line">        props:[&quot;title&quot;,&quot;items&quot;],</span><br><span class="line">        template: `</span><br><span class="line">  &lt;div class=&quot;my-list&quot;&gt;</span><br><span class="line">              &lt;h3 class=&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">              &lt;div class=&quot;list&quot;&gt;</span><br><span class="line">                  &lt;slot v-bind=&quot;item&quot; v-for=&quot;item in items&quot;&gt;&lt;/slot&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &apos;#components-demo&apos;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            shapes:[&#123; name:&apos;正方形&apos;, sides:4&#125;,&#123; name:&apos;六边形&apos;, sides:6&#125;,&#123; name:&apos;三角形&apos;, sides:3&#125;],</span><br><span class="line">            colors:[&#123; name: &apos;黄色&apos;, hex: &apos;#f4d03f&apos; &#125;,&#123; name: &apos;绿色&apos;, hex: &apos;#229954&apos; &#125;,&#123; name: &apos;紫色&apos;, hex: &apos;#9b59b6&apos; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>两个组件中相同的slot的for循环放到子组件中slot来代替，随后通过slot-scope和绑定:item来从父组件中传递数据到子组件中<br>vue子组件向父组件中传递值，通过触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;parent-show&apos;);</span><br></pre></td></tr></table></figure></p>
<p> 在组件中绑定事件<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;component1 @parent-show = &apos;show&apos;&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    show:function() &#123;</span><br><span class="line">        console.log(&quot;父组件中的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在vue中，通过ref属性获取DOM元素的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 id = &quot;myH3&quot; ref = &quot;myTitle&quot;&gt;&lt;/h3&gt;</span><br><span class="line">console.log(this.$refs.myTitle.innerText);</span><br></pre></td></tr></table></figure></p>
<h2 id="vuex使用笔记"><a href="#vuex使用笔记" class="headerlink" title="vuex使用笔记"></a>vuex使用笔记</h2><p>state是统一状态的管理，对state的改变只能通过action来改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">    debug:true,</span><br><span class="line">    state:&#123;</span><br><span class="line">        message:&quot;hello&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    setMessage(newValue)&#123;</span><br><span class="line">        this.state.message = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组件不允许直接修改属于store实例的state,而应该执行action来分发(dispatch)事件通知store去改变，我们最终也达成了flux架构，这样约定的好处，我们能够记录所有store中发生的state改变，同时实现能做到记录变更(mutation),保存状态快照，历史回滚等。</p>
<p>应用遇到多个组件共享状态时，需要多个组件依赖同一个状态，或是来自不同视图的行为来修改同一个状态。<br>vuex是一个专门为vue.js开发的状态管理模式，采用<strong>集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方法发生变化，对vue中多个组件的共享状态进行集中式的管理</strong><br>全局拥有一个state存放数据，组件修改state中的数据时，必须通过mutation进行，mutation同时提供了<strong>订阅者</strong>模式提供外部插件调用来获取state数据的更新，当所有的异步操作结束后，常见于action操作后，action通过mutation来修改state的数据，最后state通过渲染再呈现到html上。<br>dispatch:操作行为触发方法，唯一执行action的方法<br>action:操作行为处理模块，组件中的$store.dispatch(‘action’,detail)来触发<br>然后通过commit交给mutation,mutation通过同步操作来修改state中的值。<br>store.js文件的创建，里面来存储相应的state,mutation,action和getter函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex from &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">//创建store</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;,</span><br><span class="line">    //mutation来修改store</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        INCREMENT(state)&#123;</span><br><span class="line">            state.count = state.count + 1;</span><br><span class="line">        &#125;,</span><br><span class="line">        DECREMENT(state)&#123;</span><br><span class="line">            state.count = state.count - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        //通过读取属性自动调用并返回属性值</span><br><span class="line">        evenOrOdd(state)&#123;</span><br><span class="line">            return state.count % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        //包含了多个异步操作 包含了多个直接更新state函数的对象</span><br><span class="line">        incrementIfOdd(&#123;commit,state&#125;)&#123;</span><br><span class="line">            if(state.count % 2 === 1)</span><br><span class="line">                commit(&apos;INCREMENT&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        incrementAsync(&#123;commit&#125;)&#123;</span><br><span class="line">            setInterval(() =&gt; &#123;</span><br><span class="line">               commit(&apos;INCREMENT&apos;)</span><br><span class="line">            &#125;,2000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">//导出</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure></p>
<p>习惯于mutation中的函数名称是大写的，而action中是小写的。<br>随后在main.js中使用创建好的store.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store&apos;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  store,</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>在helloWorld.vue中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;p&gt;click&#123;&#123;count&#125;&#125; times,count is &#123;&#123;evenOrOdd&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;incrementIfOdd&quot;&gt;increment if odd-&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;incrementAsync&quot;&gt;increment async-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&quot;HelloWorld&quot;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">      count()&#123;</span><br><span class="line">        return this.$store.state.count;</span><br><span class="line">      &#125;,</span><br><span class="line">      evenOrOdd()&#123;</span><br><span class="line">        //计算型属性来计算值 通过state来获取</span><br><span class="line">        return this.$store.getters.evenOrOdd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      //同步加载</span><br><span class="line">      increment()&#123;</span><br><span class="line">        this.$store.commit(&apos;INCREMENT&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      decrement()&#123;</span><br><span class="line">        this.$store.commit(&quot;DECREMENT&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      incrementIfOdd()&#123;</span><br><span class="line">        //通过dispatch触发action</span><br><span class="line">        this.$store.dispatch(&apos;incrementIfOdd&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      incrementAsync()&#123;</span><br><span class="line">        this.$store.dispatch(&apos;incrementAsync&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果想直接使用mutation,通过this.$store.commit(“INCREMENT”)来直接使用，<br>如果想通过异步，则通过dispatch触发action,再通过action来触发mutation<br>this.$store.dispatch(“incrementAsync”);<br>通过简便的方法来缩写action,mutation,getter和state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions, mapGetters, mapState, mapMutations &#125; from &quot;vuex&quot;;</span><br><span class="line">...</span><br><span class="line"> computed: &#123;</span><br><span class="line">    ...mapState([&quot;count&quot;]),</span><br><span class="line">    ...mapGetters([&quot;evenOrOdd&quot;])</span><br><span class="line">    &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&quot;incrementIfOdd&quot;, &quot;incrementAsync&quot;]),</span><br><span class="line">    ...mapMutations([&quot;increment&quot;, &quot;decrement&quot;])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意的是mapMutation中的和methods中的方法名称必须保持一致。<br>getters可以看做在获取数据前对数据进行的进一步加工<br>action和mutation的区别，action是异步跟新，mutation是同步跟新<br>同步的意义在于每一个mutation的跟新都对应一个新的状态，可以看到mutation是如何改变的。<br>mutation传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&apos;INCREMENT&apos;,2);</span><br><span class="line">随后在mutation中添加</span><br><span class="line">   INCREMENT(state,n)&#123;</span><br><span class="line">          state.count = state.count + n;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="vue直播课"><a href="#vue直播课" class="headerlink" title="vue直播课"></a>vue直播课</h2><p>provide &amp; inject 类似react中的上下文<br>provide在父组件中注入，在子组件中就可以进行获取<br>inject:[‘title’] 祖先元素提供的 不需要通过props 来一个个传值<br>但是provider和inject不是响应式的，如果子孙元素想要通知祖先，就需要hack一下，vue1中有dispatch和boardcast2个方法，但是vue2中被干掉了。我们可以自己模拟一下。<br>原理就是可以通过this.parent和boradcast获取子元素，this.children来获取父组件和子组件，我们自己递归一下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">dispatch(eventName,data)&#123;</span><br><span class="line">    let parent = this.$parent;</span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">    borardcast.call(child,eventName,data); </span><br><span class="line">&#125;</span><br><span class="line">//全局挂载的方法</span><br><span class="line">Vue.prototype.$dispatch = function(eventName,data)&#123;</span><br><span class="line">    //向上传递 一直不停的获取$parent</span><br><span class="line">    let parent  = this.$parent;</span><br><span class="line">    while(parent)&#123;</span><br><span class="line">        parent.$emit(eventName,data);</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子元素</span><br><span class="line">Vue.prototype.$boardcast = function(eventName.data)&#123;</span><br><span class="line">    //通知递归所有子元素</span><br><span class="line">    boardcast.call(eventName,data);</span><br><span class="line">&#125;</span><br><span class="line">function boardcast(eventName,data)&#123;</span><br><span class="line">    this.$children.forEach(child =&gt; &#123;</span><br><span class="line">        child.$emit(eventName,data);</span><br><span class="line">        if(child.$children.length)&#123;</span><br><span class="line">    boardcast.call(child,eventName,data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">this.$on(&quot;boardcast&quot;,msg =&gt; &#123;</span><br><span class="line">    console.log();//通过监听</span><br><span class="line">&#125;)</span><br><span class="line">eventBus全局实现 </span><br><span class="line">class Bus&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.callBacks =&#123;</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        //监听 触发</span><br><span class="line">        $on(name,fn)&#123;</span><br><span class="line">       this.callBacks[name] = this.callBacks[name] || [];</span><br><span class="line">       this.callBacks[name].push(fn);</span><br><span class="line">        &#125;</span><br><span class="line">        $emit(name,args)&#123; </span><br><span class="line">            if(this.callbacks[name])&#123;</span><br><span class="line">                this.callbacks[name].forEach(cb =&gt; cb(args));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.$bus = new Vue();</span><br></pre></td></tr></table></figure></p>
<p>$bus触发所有的事件<br>自定义input监听on和input事件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :type = &quot;type&quot; :value = &quot;value&quot; @input = &quot;onInput&quot;&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    onInput(e)&#123;</span><br><span class="line">        this.$emit(&quot;input&quot;,e.target.value);</span><br><span class="line">        this.$parent.$emit(&quot;validate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">v-model的语法糖</span><br><span class="line">k-form-item 负责显示label 执行校验，和显示校验结果 插槽作组件扩展</span><br><span class="line">form进行全局校验</span><br><span class="line">能够获取全部的规则</span><br><span class="line">inject:[&quot;form&quot;];</span><br><span class="line">models:&#123;&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;&quot;&#125;,</span><br><span class="line">rules:&#123;</span><br><span class="line">    username:[</span><br><span class="line">        &#123;required:true,message:&quot;请输入用户名&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">schema来做校验</span><br><span class="line">import Schema from &apos;async-validator&apos;</span><br><span class="line">每个item都有validate方法</span><br><span class="line">单元测试:站在外层来进行测试，期望获取的结果是想要的</span><br></pre></td></tr></table></figure></p>
<p>vue router在实现前端应用时，使用hash模式和history模式<br>默认hash模式：使用URL的hash来模拟一个完整的URL，于是当URL改变时，页面不会重新加载。<br>hash(#)是URL中的锚点，代表的是网页中的位置，单改变#后面的值，不会重新加载网页，只会滚动到相应的位置。<br>hash出现在URL中，但不会出现在http中，不会对后端请求发生影响。<br>同时改变hash,会在浏览器访问历史中增加一个记录，使用后退按钮，就会回到上一个位置。<br>history模式：url像正常的url，例如<a href="http://www.baidu.com/user/id" target="_blank" rel="noopener">http://www.baidu.com/user/id</a>;<br>不过这种模式要弄好，还需要后台配置支持。因为我们的应用是SPA,如果后台没有正确的配置，用户访问时就会出现404，<br>要在服务端增加一个覆盖所有情况的候选资源，如果URL匹配不到任何静态资源，则应该返回同一个index.html的页面。</p>
<p>属性，事件和插槽3个vue基础概念。<br>属性：自定义属性props,原生属性attrs,特殊属性class,style。<br>props:称为静态数据，vue是单向数据流，数据传递时不能改变数据类型，而且不允许子组件中直接操作。<br>.sync实现双向绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;demo :show.sync = &quot;show&quot; :msg.sync = &quot;msg&quot; :arr = &quot;arr&gt;</span><br><span class="line"> props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;,</span><br><span class="line">    show: &#123;</span><br><span class="line">      type: Boolean</span><br><span class="line">    &#125;,</span><br><span class="line">    arr: &#123;</span><br><span class="line">      type: Array //在子组件中改变传递过来数组将会影响到父组件的状态</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>通过props从父组件传递到子组件中<br>vue中是由数据驱动的，是指视图是由数据驱动生成的。<br>对视图的修改，不是直接操作DOM,而是修改对应数据。<br>用户执行某个操作 -&gt; 反馈到VM处理(可以导致model变动) -&gt; VM层改变，通过绑定关系直接更新页面对应位置的数据。<br>.lazy事件，以往通常是input中一旦键入键盘就触发change事件，现在可以转变为当输入完所有内容后，光标离开才跟新视图的场景。<br>render和template都定义，执行render<br>Vue.use函数 插件和事情<br>plugin.install 是方法.<br>plugin.install.apply(plugin,args);<br>plugin都会执行<br>vuex刷新就没了 localStorage还存储在数据中<br>强类型 typescript<br>vuex源码！！！typescript和docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang = &quot;ts&quot;&gt;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">import Hello form &quot;./components/Hello.vue</span><br><span class="line">@Component(&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        HelloWorld,Hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default class App extends Vue&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>1.vue-cli<br>2.数据mock,跨域，假数据<br>3.工作流 githook eslint<br>4.webpack 模块化原理<br>5.vuex源码<br>6.router 看了源码<br>7.jwt中的具体操作<br>登录 网络拦截器 token 路由权限 addRoutes<br>token是一段加密字符串 加密函数(用户id + 随机数 + 过期时间)<br>解密token token放在header之上 token 1.注销登录 2.过期了 对称加密</p>
<p>npm run build dist包<br>线上机器有一个nginx目录<br>1.前端有一个部署机jekins 跑build copy代码，上线<br>2.push之后，jekins点按钮，打包ssh到机器上 解压<br>3.push之后，github或者gitlab的webhook 重新发布docker.<br>devops自动运维。<br>SSR服务端渲染，后端把vue或者react解析成DOM标签，首屏就能直接渲染dom.<br>nuxt就是SSR的最佳实践框架。<br>cloc ./ 看代码有几行<br>nginx和proxy区别，本地使用webpack-dev-serve的proxy做转发<br>线上没有webpack,有nginx,由nginx做转发。<br>vuex存储的变量什么时候销毁<br>缓存策略 LRU last recent use<br>队列：谁用得多留下来 谁用得少慢慢销毁<br>权限 网络拦截 性能优化 热重载 扩展 原理</p>
<p>编译 模板 -&gt; render函数 runtime<br>源码顺序<br>package.json<br>main 和 module<br>版本 不同方式引入<br>core -&gt; instance -&gt; init.js<br>initState,$mount 虚拟dom _render,_update,<br>整个的入口<br>web/entry-runtime-with-compiler.js<br>compiler 将template 编译成render函数 返回虚拟dom createElement<br>如果没有compile模块 文件变小，但只支持render<br>core 核心<br>platforms 平台 web weex<br>server 服务端渲染相关<br>sfc .vue文件解析 单页面解析 script style template<br>shared 公用的方法和常量<br>new Vue({<br>    template:<br>    <div id="app"></div><br>})<br>编译成<br>render:h =&gt; {<br>    return h(‘div’,{attrs:{id:app}},this.name);<br>}<br>每一个依赖放到watcher里面<br>watcher放到dep里面 dep放到defineReactive里面去收集<br>observer观察dep<br>解析dom内容 k-model事件<br>this.$compile = new Compile()<br><strong>vue vuex vue-router全家桶代码</strong><br>node 最佳实践 eggjs 1.1mvc分层 约定大于配置 nginx+docker部署<br>mixin 是自己的 extend给儿子了 是继承<br>react推荐用umi 脚手架<br>auth2第三方登录 微信 微博登录<br>虚拟dom就是object对象123 createElement({div,id:app,123}),大的object对象，模拟树形结构<br>{<br>    type:div,<br>    props:{id:div},<br>    children[<br>        {type:组件}<br>    ]<br>}<br>ast抽象语法树 super-tiny-compiler 前端编译<br>codegen<br>vue的生命周期函数<br>在newVue后 首先初始化事件event和生命周期lifecycle等<br>实际就是往上面挂载一些函数<br>这里到达的是beforeCreate<br>随后是初始化provide和inject中的一些实例<br>这里data和props都已经加载完毕 可以调用<br>随后将el元素挂载上去，如果有模板编译的话，首先执行模板编译生成render函数 这里是挂在前beforeMount<br>随后根据render函数产生虚拟dom,真正的渲染到dom上，触发mouted,在update的时候，根据不同情况产生不同的虚拟dom进行对比，利用patch算法进行对比和渲染，到真正的dom上。在销毁的时候触发beforeDestroy方法。将监听组件等全部取出，随后触发destroy方法<br><a href="https://www.cnblogs.com/happ0/p/8075562.html" target="_blank" rel="noopener">生命周期链接</a><br><a href="https://blog.csdn.net/running_runtu/article/details/79936503" target="_blank" rel="noopener">生命周期最好的回答</a><br>性能优化<br>文件更快加载 文件执行次数更少<br>很多dom都是可以重用的 整个dom的元素就这么多<br>整个3屏 整个的dom元素是不会增加的，上面去除的拿到下面来添加上  上面的屏幕都放到下面来 骨架屏<br>SSR 服务端渲染</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/浏览器缓存机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/浏览器缓存机制/" itemprop="url">浏览器缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T14:19:19+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/浏览器相关/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>缓存可以说是性能优化中简单高效的一种优化方式了，一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，<br>并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。<br>数据请求的步骤：发起网络请求，后端处理，浏览器响应。<br>浏览器缓存在第一步网络请求和浏览器响应2个环节中做性能优化。<br>缓存位置：<br>service worker:运行在浏览器背后的独立线程，一般可以用来实现缓存功能，<br>。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。service workder的缓存与浏览器其余内建缓存不同，它可以让我们<br><strong>控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的</strong><br>2.memory cache<br>memory cache也是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载好的样式，脚本等，<br>读取内存中的数据肯定比磁盘来得快，内存读取高效，可是缓存持续性很低，会随着进程的释放而释放，<br><strong>一旦关闭tab页面，内存中的缓存也就被释放了</strong>.<br><strong>内存缓存在缓存资源时并不关心返回的资源的http缓存头cache-control是什么，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。<br>3.disk cache 顾名思义也就是硬盘中的缓存，读取速度较低，但是什么都可以存储到磁盘中，，比之 Memory Cache 胜在容量和存储时效性上。
</strong>对于大文件来说，大概率是不会存储在内存中的，反之优先<strong>,
</strong>当前系统内存使用率高的话，文件优先存储进硬盘中<strong>.<br>4.push cache是http/2中的内容，当以上3种缓存都没有命中的时候，才会被使用，只在会话session中使用，一旦会话session结束，也就被释放，并且缓存时间很短。<br>出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个http连接。<br>大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为2种，</strong>强缓存和协商缓存<strong>,<br>并且缓存策略都是通过设置</strong>http header<strong>来实现的。<br>浏览器与服务器通信为应答模式，浏览器发出http请求，服务器响应后拿到数据，<br>浏览器如何确定一个资源该不该被缓存，如何去缓存呢。<br>浏览器第一次向服务器发起请求后拿到请求结果后，</strong>将请求结果和缓存标识<strong>存入浏览器缓存中，
</strong>浏览器每次发出请求，都会现在浏览器缓存中查找请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览<strong>
</strong>器缓存中<strong><br>确保了每个请求的缓存存入与读取，<br>是否需要向服务器重新发起http请求将缓存分为2个部分，分别是</strong>强缓存和协商缓存<strong><br>强缓存：不会向服务器发送请求，直接从缓存中读取资源，强缓存通过设置2种http header来实现，<br>expires 和 cache-control.<br>expires:</strong>用来指定资源到期的时间，是服务器端的具体的时间点<strong>,<br>expires = max-age + 请求时间，。需要和last-modified结合使用，<br>是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器都可以直接从浏览器缓存中读取数据，而无需再次请求。<br>cache-control主要用来控制网页缓存，cache-control:max-age=300,则代表在这个请求正确返回时间，5分钟内再次加载该网页，就会命中强缓存，cache-control可以在请求头或者响应头中设置。<br>expires是http1.0的产物，cache-control是http1.1的产物，同时存在，</strong>cache-control优先级高于expires.<strong><br>expires是一个过期的产物，现阶段它的存在只是一种兼容性的写法。<br>强缓存判断是否缓存的依据是是否超出某个时间或者某个时间段，</strong>而不用去关心服务器端的数据是否跟新了<strong>.<br>可能导致加载文件不是服务器端最新的文件，那我们如何得知</strong>服务器端内容是否已经发生了更新呢<strong>这时候就要用到协商缓存。<br>5.协商缓存。<br>协商缓存是强缓存失效后，浏览器携带着</strong>缓存标识向服务器发起请求,由服务器根据缓存标识决定是否使用缓存的过程，<strong>,<br>主要有以下情况，
</strong>协商缓存生效，返回304和not modified<strong> 
</strong>协商缓存失效，返回200和请求结果<strong><br>协商缓存可以通过设置http header来实现，last-modified和if-modified-since.<br>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加last-modifed的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>last-modifed是文件在服务器上的最后修改时间。<br>浏览器下一次请求资源时，浏览器首先检测有last-modified这个header,于是添加if-modified-since这个header,值就是last-modified中的值，服务器收到资源后，会根据if-modified-since中的值和服务器中的最后修改时间作比较，如果没有变化，就返回304和空的响应体，直接读取缓存，如果If-Modified-Since的时间小于浏览器的最后修改时间，说明文件有更新，于是返回新的资源文件和200.<br>如果本地打开了缓存文件，即时没有修改文件，也会造成last-modified被修改，服务器不能命中缓存导致发送相同的资源。<br>既然根据文件修改时间来决定是否缓存尚有不足，能否根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了ETag和If-None-Match.<br>ETag是服务器响应请求时，返回当前资源文件的一个唯一标示，(由服务器生成)，只要资源有变化，ETag就会重新生成，浏览器在下一次加载资源并向服务器端发送请求时，，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传过来的if-none-match和自己服务器上的etag标签是否一致即可。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。<br>etag优于last-modified<br>强缓存优于协商缓存进行。，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，</strong>协商缓存有服务器决定是否使用缓存**，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。<br>用户行为对浏览器缓存的影响：指的是用户在浏览器操作时，会触发怎样的缓存策略。<br>打开网页：直接输入地址，查找disk cache中是否有匹配。。如有则使用；如没有则发送网络请求。<br>普通刷新(f5),因为tab并没有关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache.<br>强制刷新(ctrl + f5),浏览器不使用缓存，存，因此发送的请求头是:cache-control:no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KevinSwift">
            
              <p class="site-author-name" itemprop="name">KevinSwift</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
 
           <div>
              <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="50" height="60" src="//music.163.com/outchain/player?type=2&id=34532273&auto=1&height=66"></iframe>
           </div>
 
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinSwift</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
