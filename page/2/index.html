<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KevinSwift">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="KevinSwift">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KevinSwift">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>KevinSwift</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KevinSwift</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
            相册
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/页面性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/页面性能优化/" itemprop="url">页面性能优化与常见的攻击</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-21T15:57:58+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>互联网有一项著名的<strong>8秒规则，用户在访问web页面的时候，如果时间超过了8秒就会感觉到不耐烦，如果加载需要太长的时间，他们就会放弃访问。向网页开发者表明了加载时间的重要性</strong><br>1.资源合并和压缩：主要包括有html压缩，css压缩，js的压缩和混乱文件的合并<br>从文件中去除多余的字符，例如回车，空格等。<br>css代码的压缩：是无效代码删除和css语义合并<br>js的压缩和混乱：1.无效字符的删除 2.删除注释 3代码语义的缩减和优化 4.代码的保护<br><strong>css和js的压缩是非常有必要的,压缩合并css和js可以减少网站http请求的次数，但合并文件可能会带来问题：首屏渲染和缓存失效问题</strong><br>2.非核心代码进行异步加载。<br>异步加载的3种方式-async和defer。动态脚本的创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;text/javascript&quot; src = &quot;xxx.js&quot; async = &quot;async&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>defer是在html解析完之后才会执行，如果是多个，则会按照加载的顺序依次执行，</strong><br><strong>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</strong><br>3.利用浏览器缓存<br>3.1利用前缓存 不会向服务器发送请求 直接从缓存中读取资源<br>3.2利用协商缓存 向服务器发送请求，服务器会根据request header中的一些参数来判断是否命中协商缓存<br>强缓存优先于协商缓存,若强制缓存生效则直接使用缓存。若不生效则使用协商缓存。<br><strong>用户行为对浏览器缓存的影响</strong><br>1.地址栏访问，链接跳转是正常用户行为，将会触发浏览器的缓存机制<br>2.F5刷新，浏览器会设置max-age = 0,跳过强缓存判断，会进行协商缓存判断。<br>3.ctrl + F5,跳过强缓存和协商缓存，直接从服务器获取数据<br>4.使用CDN<br><strong>浏览器的缓存只是为了提高二次访问的速度</strong>需要从网络层面进行优化，最常见的是CDN(内容分发网络),通过将静态资源(js,css,html图片)等缓存到离用户很近的相同网络运营商的CDN节点上，不但提高用户的访问速度，还能节省服务器的带宽消耗，降低负载。<br>CDN服务商在全国各个省份部署计算节点，当到达计算节点时，首先判断缓存是否有效，若有效，则立即响应缓存给用户，否则，就去内容服务器上请求数据，反馈给用户，并将内容缓存下来以便响应给后续访问的用户。<br><strong>一个地区内只要有一个用户预先加载资源，在CDN中建立了缓存，该地区中的其余用户便会因此而受益</strong><br>5.<br><strong>预解析DNS 使用该技术预先告知浏览器某些资源可能会在将来被使用，</strong><br>通过DNS预解析告诉浏览器我们未来可能从某个特定的URL获取资源，当浏览器真正使用的时候，就可以尽快完成DNS的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel = &quot;dns-prefetch&quot; href = &quot;//example.com&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好用的性能优化方式</strong>,，<br>用户滚动到它们之前，<strong>可视区域外的图像不会加载</strong>,<br><strong>使用延迟加载使得网页加载更快</strong><br>为什么使用懒加载：1.能提升用户体验。2.减少无效资源的加载 3.防止并发加载的资源过多会阻塞js的加载。<br>预加载：另一个性能优化技术，告知浏览器某些资源可能会在未来使用到，<br>预加载把所有资源提前加载到本地，这样后面要使用的话就直接从缓存中读取。</p>
<p>懒加载和预加载的对比，<br>两者主要区别是一个是提前加载，一个是迟缓甚至不加载，懒加载对服务器端有一定的缓解压力作用，预加载则会增加服务器端压力。<br>函数防抖和节流<br>函数节流(throttle)：<strong>一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。</strong><br>有个需要频繁触发的函数，出于性能优化，在规定时间内，只让函数触发一次。<br>判断当前时间戳和上次执行的时间戳是否已经达到规定时间段。<br>函数节流：<br>1.DOM元素的拖拽功能，计算鼠标移动，射击游戏的mousedown/keydown.<br>函数防抖(debounce)：<br>防抖函数：<strong>一个需要频繁触发的函数，在规定时间内，只让最后一次生效即可，前面的不生效</strong></p>
<h2 id="常见的攻击和防御方法"><a href="#常见的攻击和防御方法" class="headerlink" title="常见的攻击和防御方法"></a>常见的攻击和防御方法</h2><p>xss(跨站脚本攻击)，通过存在安全漏洞的web网站注册用户的浏览器内运行非法的html标签或者js进行攻击<br>1.利用虚假输入表单获取信息<br>2.利用脚本窃取用户的cookie值。被害者在不知情的情况下，帮助攻击者发送恶意请求。<br>3.显示伪造的文章或者图片<br>防御XSS攻击：<br>CSP建立白名单，开发者明确告诉浏览器哪些外部资源可以加载<br>通过设置http header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-security-policy:defalut-src &apos;self&apos;</span><br></pre></td></tr></table></figure></p>
<p>通过使用转移字符<br>3.httpOnly cookie<br>预防xss攻击的最有效手段 设置httpOnly,避免网页的cookie被客户端恶意js获取，保护用户的cookie信息<br>2.csrf攻击：<br>在登录a的情况下已经设置好cookie,所以在登录恶意网站时，将a网站上的cookie信息获取。<br>防范：get请求不对数据进行修改，不让第三方网站访问到用户的cookie.阻止第三方网站请求接口，请求时必须携带验证信息，例如cookie<br>3.点击劫持：视觉欺骗的攻击手段，攻击者将需要攻击的网站通过iframe嵌套到自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击，特点：隐蔽性较高，UI-覆盖点击，利用iframe或者其他标签的属性。<br>4.URL跳转漏洞：借助未验证的URL进行跳转，将应用程序引导到不安全的第三方区域，从而导致安全问题。<br>5.SQL注入，一种典型的web安全漏洞，攻击者利用这个漏洞，可以访问或者修改数据，或者利用潜在的数据库漏洞进行攻击。<br>6.OS命令注入攻击：和SQL注入差不多，SQL注入是针对数据库的，而OS注入是针对操作系统的。OS命令注入攻击指的是通过Web应用，执行非法的操作系统命令而达到攻击的目的，只要在能调用shell函数的地方就能存在被攻击的风险。防御：进行规则限制，<br>在调用系统命令前将所有传入参数进行命令行参数转义过滤。不要直接拼接命令语句，借助一些工具作拼接。，例如 Node.js 的 shell-escape npm包</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/20/http相关知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/http相关知识/" itemprop="url">http相关知识,tcp知识,web实时推送</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T11:30:44+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>http状态码：<br>1xx 指示信息-表示请求已经接受，继续处理 表示客户端需要提交下一步请求<br>2xx 成功 表示请求已被成功接受<br>304未修改，客户端的缓存是最新的<br>3xx 重定向 要完成请求需要进一步操作 302(重定向), 307 和 304(拿缓存)<br>4xx 客户端错误 请求有语法错误等<br>5xx 服务器端错误 服务器未能实现合法的请求</p>
<p>403 //对被请求的页面访问禁止 404 请求资源不存在 比如输入了错误的URL<br>post 向URL指定的资源提交数据<br>put 提交数据 put指定了在服务器上的位置 而post没有<br>head 只请求页面的首部<br>delete 方法：删除服务器上的某资源<br>options 方法：它用于获取当前 URL支持的方法，如果请求成功，会有一个 Allow 的头包含类似“GET,POST”这样的信息</p>
<p>持久连接：只要任意一端没有提出明确断开连接，则保持TCP的连接状态</p>
<p>https的工作原理：！！！<br>https在HTTP上建立了SSL加密层，对传输数据进行了加密，是http的安全版<br>主要作用：<br>1.对数据进行加密，并建立一个信息安全通道，来保证传输数据的过程中的数据安全<br>2.对网站服务器进行真实身份认证<br>http使用的是明文进行发送。<br>完成了数据隐私性传输，完整性的校验，身份认证<br>http先和SSL通信，再由SSL和tcp通信。<br>对称加密：加密和解密用同一个秘钥，将秘钥也需要发送给对方。<br>非对称加密：私有秘钥不能让任何人知道，公开秘钥可以随意发布<br>使用公开秘钥加密的方式：发送密文的一方使用对方的公开秘钥进行加密，<br>对方收到后，利用私钥进行解密。<br>非对称加密特点是信息一传输多，服务端只需要维护一个<strong>私钥就能和多个客户端进行通信</strong></p>
<p>http使用的方式：在交换秘钥环节使用非对称加密方式，之后的建立通信交换报文阶段采用对称加密方式</p>
<p><strong>发送密文的一方使用对方的公开秘钥加密处理对称的秘钥，然后对方利用自己的私钥进行解密拿到对称的秘钥，这样可以确保秘钥在安全的情况下，使用对称秘钥进行加密</strong></p>
<p>解决报文是否可能遭到篡改 – 数字签名<br>确定消息是由发送方签名并且发过来的，因为别人假冒不了<br>数字签名保证消息的完整性，证明数据没有被篡改<br>文本用hash生成消息摘要 再由私钥生成数字签名，发送给接受者<br>接受者只有用发送者的公钥才能进行解密，然后用hash函数产生摘要信息。</p>
<p>解决通信双方身份可能被伪装的问题：数字证书<br>数字认证机构处于客户端和服务器双方都可信赖的第三方机构的立场上</p>
<p>https通信过程<br>1.client发送https请求 server的连接端口为443<br>2.server把事先配置好的公钥证书返回给客户端<br>3.client验证公钥证书<br>4.clent使用<strong>伪随机数产生对称秘钥，然后用证书的公钥加密,发送给server</strong><br>5.server利用自己私钥进行解密，client和server拥有了相同的私钥<br>6.server使用对称秘钥加密明文内容，发送给client<br>7.client使用对称秘钥解密密文，得到明文内容<br>8.client再次发送http,使用对称秘钥加密请求B,然后server使用对称秘钥解密</p>
<p>tcp3次握手过程<br>client -&gt; server发送<br>server 接收后 回复ack<br>client收到ack后回复ack</p>
<p>问：为什么建立连接需要3次<br>答：防止失效的连接请求报文段被服务端接收，从而产生报错 A是client,B是server<br>发送的失效报文到达时，A和B已经断开了，但是B又建立了连接，向A发送数据，所以造成资源浪费<br>tcp 4次挥手<br>客户端打算关闭连接<br>tcp停止释放报文，fin = 1<br>服务器接收到后确认，确认号是ack + 1<br><strong>客户端到服务器这个连接已经释放，但是服务器到客户端还未释放，client不能发送，server不能接受，但是server可以发送，client可以接受</strong><br>因为tcp是全双工的，两端可以同时发送和接收数据</p>
<p>服务器到客户端发送fin<br>客户端接收到后，必须发出请求，ack = 1<br>运输层中有传输控制协议tcp和用户数据协议udp<br>dns查看 浏览器缓存 -&gt; 系统缓存 -&gt; 路由器缓存</p>
<p>http/2相比于http/1，可以说大幅度提高了网页的性能，只需要升级到该协议就能减少很多之前需要做的性能优化工作，<br>当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。<br>http/3相对于http/2又是一个提升<br>http协议：<br>处于计算机网络中的应用层，http是建立在tcp协议之上，<strong>所以http协议的瓶颈及其优化技巧都是基于tcp本身的特性</strong>,<br>例如tcp建立的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间</p>
<p>http/1.x缺陷<br>连接无法复用 每次都会导致3次握手和慢启动，慢启动对大量小文件请求影响较大。<br>head-of-line blocking(holb) 导致宽度无法被充分利用，以及后续请求被阻塞<br>http/1.x在传输数据时，所有传输内容都是明文，客户端和服务端都无法验证对方身份，这在一定程度上无法保证数据的安全性</p>
<p>http/2方法/状态码/语义都与http/1.x一样，http/2基于SPDY3协议，专注于<strong>性能</strong>,最大的目标是在用户和网站之间只用一个连接。</p>
<p>http/2采用二进制格式传输数据，而非http1.x的文本格式。<br>http/2采用了多路复用技术。<br>解决了同一个域名下的请求数量的问题。<br>同时也更容易实现全速传输。<br>http/2<br>同域名下所有通行都在单个连接上完成。<br>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。<br>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,消除了因多个 TCP 连接而带来的延时和内存消耗。<br>并行交错地发送多个请求，请求之间互不影响。<br>并行交错地发送多个响应，响应之间互不干扰。<br>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。<br>http/2只采用一个tcp协议，<br>http/2压缩了header<br>server-push也叫cache push<br>某些资源客户端一定会请求，可以采用服务端push方式，提前给客户端必要的资源。<br>http3协议是基于QUIC协议，QUIC协议是基于UDP协议。<br>QUIC新功能：<br>0-RTT 通过使用类似TCP快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0-RTT建立连接可以说是QUIC相比HTTP2最大的性能优势。<br>https建立一次完全握手需要3个RTT，而QUIC建立在UDP基础上，同时又实现了0RTT的安全握手，所以在大部分情况下，只需要0个RTT就能实现数据传送。<br>同一条QUIC连接上可以创建多个stream,来发送多个http请求。<br>QUIC有向前纠错机制，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。<br>http/1.x有连接无法复用，队头阻塞，协议开销大和安全因素等多个缺陷。<br>http/2通过多路复用，二进制流，Header等压缩技术，极大的提高了性能。但是还是存在性能问题。<br>quic基于udp协议来实现，是http/3中的底层支撑协议，该协议基于UDP，又吸取了TCP中的精华，实现了既块又可靠的协议传输。</p>
<p>web实时推送机制 将后台发生的变化主动的，实时的传送到浏览器端。而不需要用户端主动刷新页面<br><strong>轮询</strong>是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次，缺点：连接数会非常多，一个接受，一个发送，<br><strong>而且每次发送请求都会有http的header，会很耗流量，也会消耗cpu的利用率。
</strong>长轮询<strong>客户端发送http给服务器后，看有没有新消息，如果没有新消息，就一直等待，当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节),但是真正被服务器用到的数据却很少，<br>这样的数据在网络上周期性的传输，</strong>难免对网络带宽是一种浪费<strong>
</strong>iframe<strong>流方式是在页面中插入一个隐藏的iframe,利用其src属性在服务器和客户端之间建立一条长连接，服务器想iframe传输数据，来实时更新页面。<br>优点：消息能够实时到达；浏览器兼容好<br>缺点：服务器维护一个长连接会增加开销；IE、chrome、Firefox会显示加载没有完成，图标会不停旋转。
</strong>web socket<strong>机制，web服务器和客户端之间建立连接后，之后所有的通信都依靠这个专用协议进行。任意一方可直接向对方发送报文。<br>http是半双工协议，web socket是全双工协议。<br>tcp和udp的比较<br>tcp/ip是互联网相关的各类协议族的总称，例如tcp,udp,ip,ftp,http,icmp,smtp等<br>是互联网的基础，一系列网络协议的总称，<br>这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。<br>tcp/ip的4层模型<br>链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层<br>udp协议全称是用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种</strong>无连接的协议<strong>。<br>面向无连接，不需要和tcp一样在发送数据前建立3次握手。<br>有单播，多播，广播的功能。<br>支持一对一，一对多，多对多，多对一的方式。<br>udp是面向报文的，是不可靠的。<br>头部开销小，传播数据报文是很高效的<br>两台计算机通信时，需要畅通并且可靠。<br>当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了 TCP。
</strong>tcp协议全称是传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议<strong>.<br>3次握手和4次挥手<br>tcp仅支持单播传输<br>ajax是一种</strong>异步请求数据的web开发技术**,在不需要重新刷新页面的情况下，ajax通过异步请求加载后台数据，并在前端显示。<br>ajax目的是提高用户体验，减少网络数据传输量<br>基于浏览器提供的xmlhttprequest对象，使得浏览器可以发出http请求和接收到http响应。<br>浏览器接着干自己的事情</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/伪数组和promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/伪数组和promise/" itemprop="url">伪数组和promise,async,await的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T10:09:59+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>何为伪数组<br>如果一个对象的所有键名都是正整数或者0，并且具有Length属性，那么这个对象就很像数组，语法上就非常像伪数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    0:&apos;a&apos;,</span><br><span class="line">    1:&apos;b&apos;,</span><br><span class="line">    2:&apos;c&apos;,</span><br><span class="line">    length:3</span><br><span class="line">&#125;;</span><br><span class="line">obj[0] //&apos;a&apos;</span><br><span class="line">obj[1] //&apos;b&apos;</span><br><span class="line">obj.length //3</span><br></pre></td></tr></table></figure></p>
<p>对象obj是一个类似数组的对象，但是类似数组的对象<strong>并不是数组</strong>,因为它们不具备数组的方法，对象obj没有数组的push方法。<br>典型的”类似数组的对象”是<strong>函数的arguments对象，以及大多数DOM元素集，还有字符串</strong>/<br>数组的slice方法可以将类似数组的对象转变成真正的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    return args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6提供了array.from方法，将伪数组转化成真正的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let btns = document.getElementByTagName(&quot;button&quot;);</span><br><span class="line">console.log(btns);</span><br><span class="line">Array.from(btns).forEach(item =&gt; &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>将伪数组转化成真正的数组<br>扩展运算符(…)也可以将某些数据结构转化为数组。<strong>只不过需要在背后调用遍历器接口Symbol.iterator</strong><br>值得注意的是如果一个对象没有部署遍历器接口，使用扩展运算符是无法将类似数组对象转换成数组的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function doSomething()&#123;</span><br><span class="line">    return [...arguments];</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);</span><br></pre></td></tr></table></figure></p>
<p>Array.of相当于Array的构造器，会创建一个包含所有传入参数的数组，而不管参数的数量与类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items = Array.of(2); </span><br><span class="line">console.log(items[0]); //2</span><br><span class="line">console.log(items.length); //2</span><br></pre></td></tr></table></figure></p>
<h2 id="promise相关"><a href="#promise相关" class="headerlink" title="promise相关"></a>promise相关</h2><p>异步编程模式在前端开发中，显得越来越重要，从最开始的XHR到封装后的ajax都在试图解决异步编程中的问题，<br>传统ajax中，当异步请求之间的数据存在依赖关系的时候，就可能产生出多层的回调嵌套问题。俗称”回调地狱”,<br>promise的出现让我们告别了回调函数，写出了更加优雅的代码。<br>async/await的到来使得异步代码看起来像同步代码的替代方法。<br>promise的原理：<br>对一种异步操作的封装，可以通过独立的接口添加在异步操作执行成功，失败时执行的方法，主流的规范是promise/a+<br>promise的状态：pending初始状态,fulfilled成功,rejected失败.<br>promise实例必须实现then这个方法 then必须返回2个函数作为参数(resolve,reject)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    var img = document.createElement(&quot;img&quot;);</span><br><span class="line">    img.onload = function() &#123;</span><br><span class="line">        resolve(img);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = function()&#123;</span><br><span class="line">        reject(&quot;图片加载失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">result.then(</span><br><span class="line">    function(img)&#123;</span><br><span class="line">console.log();</span><br><span class="line">    &#125;.then(function(img)&#123;</span><br><span class="line">        console.log();</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>promise的级联操作<br>result1.then(function(img){</p>
<p>}).then(function(img){</p>
<p>}).catch(function(ex){<br>    console.log();<br>})<br>promise的all方法，可以并行执行所有任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(resolve,500,&apos;p1&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">var p2 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(resolve,600,&apos;p2&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">promise.all([p1,p2]).then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>promise.race接收一个包含多个promise对象的数组，只要一个完成，就执行success.<br>async/await是写异步代码的新方式，优于回调函数和promise.<br>async/await基于promise实现的。不能用于普通的回调函数。<br>。。。。。。。与promise是一样的，是非阻塞的。<br>。。。。。。。使得异步代码看起来像同步代码一样，没有回调函数。但是改变不了js单线程，异步的本质。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const load = async function()&#123;</span><br><span class="line">    const result1 = await loading(src1);</span><br><span class="line">    console.log(result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="async-await相关"><a href="#async-await相关" class="headerlink" title="async,await相关"></a>async,await相关</h2><p>async/await较promise有诸多好处<br>1.简洁。使用async/await明显节约了不少代码。不需要写.then()方法。<br>2.中间值。调用promise1,使用promise1返回的结果去调用promise2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const makeRequest = async () =&gt; &#123;</span><br><span class="line">    const value1 = await promise1();</span><br><span class="line">    const value2 = await promise2(value1);</span><br><span class="line">    return promise3(value1,value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/笔试笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/笔试笔记/" itemprop="url">笔试笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T20:13:27+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/css相关/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.实现如下布局<br><img src="/writenExp/1.png" width="50%" height="50%"><br>注意header,footer,content的划分和命名规范，flex布局，和当容器设置为父容器的百分号时，注意设置body和html的 body html{margin:0;height:100%}<br>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line">html &#123;</span><br><span class="line"></span><br><span class="line">    margin:0 auto;</span><br><span class="line"></span><br><span class="line">    padding:0;</span><br><span class="line"></span><br><span class="line">    height: 100%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.header&#123;</span><br><span class="line"></span><br><span class="line">    border: solid 1px green;</span><br><span class="line">    height:100px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.leftLogo&#123;</span><br><span class="line">    margin: 10px 0px 10px 10px;</span><br><span class="line">    width: 80px;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.rightUserName&#123;</span><br><span class="line">    border: solid 1px black;</span><br><span class="line">    text-align: right;</span><br><span class="line">    width: 100px;</span><br><span class="line">    margin: 60px 10px 0px 0px;</span><br><span class="line">    height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content&#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-grow: 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.leftContent&#123;</span><br><span class="line">    flex-grow:1 ;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.aside&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    border: solid 1px red;</span><br><span class="line">    text-align: left;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    border:solid 1px black;</span><br><span class="line">    text-align: center;</span><br><span class="line">    height: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle-down&#123;</span><br><span class="line">    width:0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    border-bottom: 5px solid black;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;triangle-down&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>参考网站<br><a href="https://blog.csdn.net/carrybest/article/details/54286137" target="_blank" rel="noopener">html body设置宽高</a><br><a href="https://www.cnblogs.com/dreamperson/p/9367008.html" target="_blank" rel="noopener">flex布局</a><br>2.实现如下函数：<br>uniqueryfy([1,0,0]) 返回[1,0]<br>uniquerfy([{id:1,name:1},{id:1,name:2}],a =&gt; a.id)返回[{id:1,name:1}]<br>后面是过滤的规则 或者为 a =&gt; a.sex + a.name<br>方法：使用set的方法来做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function uniquery(arr,rules) &#123;</span><br><span class="line">     if(rules == null)&#123; //判断rule为空的情况下</span><br><span class="line">         var set = new Set();</span><br><span class="line">         arr.forEach(function (item,index,arr) &#123;</span><br><span class="line">             if(!set.has(item))</span><br><span class="line">                 set.add(item);</span><br><span class="line">         &#125;)</span><br><span class="line">         return Array.from(set);//伪数组的转变 将set转化为数组</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         //保存key 新的数组来保存所有的key和value</span><br><span class="line">         var set = new Set();</span><br><span class="line">         var newArr = [];</span><br><span class="line">         arr.forEach(function (item,index,arr) &#123;</span><br><span class="line">             var key = rules(item);</span><br><span class="line">             if(!set.has(key))&#123;</span><br><span class="line">                 set.add(key);</span><br><span class="line">                 newArr.push(item);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;)</span><br><span class="line">         return newArr;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<br><img src="/writenExp/03.jpeg" width="50%" height="50%"><br>三角形的绘制可以通过border来 transparent设置两边为透明即可了。<br><a href="https://www.jianshu.com/p/9a463d50e441" target="_blank" rel="noopener">三角形绘制参考网站</a><br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang=&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">.total&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">&#125;</span><br><span class="line">.top&#123;</span><br><span class="line">    background: black;</span><br><span class="line">    color: white;</span><br><span class="line">    width: 100px;</span><br><span class="line">    display: flex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.trangle-down&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-top: 5px solid white;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.content-top&#123;</span><br><span class="line">    background: white;</span><br><span class="line">    color: red;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.trangle-up&#123;</span><br><span class="line">    width: 0;</span><br><span class="line">    height: 0;</span><br><span class="line">    border-bottom: 5px solid red;</span><br><span class="line">    border-left: 5px solid transparent;</span><br><span class="line">    border-right: 5px solid transparent;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;total&quot; onmouseleave=&quot;closeMenu()&quot;&gt;</span><br><span class="line">&lt;div class=&quot;top&quot; onmouseenter=&quot;opemMenu()&quot;&gt;</span><br><span class="line">    客户服务</span><br><span class="line">    &lt;div class=&quot;trangle-down&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;content-top&quot;&gt;</span><br><span class="line">        客户服务</span><br><span class="line">        &lt;div class=&quot;trangle-up&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;帮助中心&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;联系客户&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function opemMenu() &#123;</span><br><span class="line">        (document.getElementsByClassName(&quot;content&quot;)[0]).style.display = &quot;block&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function closeMenu() &#123;</span><br><span class="line">        (document.getElementsByClassName(&quot;content&quot;)[0]).style.display = &quot;none&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.实现如下函数，今天是小明生日，他希望知道余下还剩下多少时间，<br><span id="clock"></span><br>要求：<br>1.使用原生js<br>2.时间格式 时：分：秒<br>3.自动补全2位，06:06:06<br>4.过了凌晨12点，时钟自动停止<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;span id = &quot;clock&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function PrefixInteger(num, n) &#123;</span><br><span class="line">        return (Array(n).join(0) + num).slice(-n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   var interval =  setInterval(function () &#123;</span><br><span class="line">        var curDate = new Date(); //获取当前时间</span><br><span class="line">        var nextDate = new Date(curDate.getTime() + 24 * 60 * 60 * 1000);  //获取下一天</span><br><span class="line">        var next = new Date(nextDate.getFullYear(),nextDate.getMonth(),nextDate.getDate());//获取下一天的0时刻</span><br><span class="line">        var time = next - curDate; //求得时间差</span><br><span class="line">        var hours =(parseInt((time %(1000 * 60 * 60 * 24)) / (1000 * 60 * 60)));</span><br><span class="line">        var minutes = parseInt((time % (1000 * 60 * 60)) / (1000 * 60));</span><br><span class="line">        var seconds = parseInt((time % (1000 * 60)) / 1000);</span><br><span class="line">       if(hours == 0 &amp;&amp; minutes == 0 &amp;&amp; seconds == 0) //如果都为0了 说明到头了 就清除</span><br><span class="line">         clearInterval(interval);</span><br><span class="line">       var str = &quot;&quot;;</span><br><span class="line">            str += PrefixInteger(hours, 2) + &quot;:&quot;; //补全</span><br><span class="line">            str += PrefixInteger(minutes, 2) + &quot;:&quot;;</span><br><span class="line">            str += PrefixInteger(seconds, 2);</span><br><span class="line"></span><br><span class="line">        document.getElementById(&quot;clock&quot;).innerText = str;</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>5.实现如下页面布局<br>已知header,footer高度为48px,宽度为100%,aside宽度均为320px,实现该布局<br><img src="/writenExp/04.jpg" width="50%" height="50%"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">    html &#123;</span><br><span class="line"></span><br><span class="line">        margin:0;</span><br><span class="line"></span><br><span class="line">        padding:0;</span><br><span class="line"></span><br><span class="line">        height: 100%;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">    &#125;</span><br><span class="line">    .header&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        height: 48px;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .footer&#123;</span><br><span class="line">        background-color: blue;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        height: 48px;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .main&#123;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-grow: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    .aside&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: blue;</span><br><span class="line">        flex-grow: 0;</span><br><span class="line">        width: 320px;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">        flex-grow: 1;</span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        background-color: rebeccapurple;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;header&quot;&gt;</span><br><span class="line">    header</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;aside&quot;&gt;</span><br><span class="line">        aside</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        content</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;aside&quot;&gt;</span><br><span class="line">        aside</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    footer</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.将函数fn的执行上下文改为obj,返回fn执行后的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function HelloWorld(fn,obj) &#123;</span><br><span class="line">    return fn.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">HelloWorld(</span><br><span class="line">    function() &#123;</span><br><span class="line">        return this.firstname + &apos;&apos; + this.lastname + &apos;|&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;firstname:&quot;hello&quot;,lastname:&quot;world&quot;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>7.实现如下布局<br><img src="/writenExp/05.jpeg" width="50%" height="50%"><br><a href="https://www.cnblogs.com/daxiong/articles/3158630.html" target="_blank" rel="noopener">关键是三角形冒泡的实现</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .tag&#123; width:500px; position:relative;border-radius: 5px&#125;</span><br><span class="line">    .tag em&#123;display:block; border-width:20px; position:absolute; bottom:150px; left:500px;border-style:solid  ; border-color: transparent  transparent transparent white;font-size:0; line-height:0;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body style=&quot;background-color: #666666&quot;&gt;</span><br><span class="line">&lt;div style=&quot;display: flex&quot;&gt;</span><br><span class="line">&lt;div class=&quot;tag&quot; style=&quot;width: 500px;background-color: white&quot;&gt;&lt;h1&gt;《倩女幽魂2.0》来看看我的&lt;br&gt;最新梦岛动态!&lt;/h1&gt;</span><br><span class="line">    &lt;em&gt;&lt;/em&gt;</span><br><span class="line">&lt;div style=&quot;display: flex&quot;&gt;</span><br><span class="line">&lt;p style=&quot;font-size: 25px;color: #999999&quot;&gt;上大神，发梦岛，不进游戏也能&lt;br&gt;撩！&lt;/p&gt;</span><br><span class="line">&lt;img src=&quot;https://nos.netease.com/hi-163-qn/upload/201909/04/ff2e1e80cef611e9a213af01a189a04b.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;img style=&quot;width: 150px;height: 150px;margin-left: 30px&quot; src=&quot;https://nos.netease.com/hi-163-qn/upload/201909/04/ff2e1e80cef611e9a213af01a189a04b.png&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>8.实现如下函数<br><img src="/writenExp/06.jpeg" width="50%" height="50%"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/16/vue学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/16/vue学习笔记/" itemprop="url">vue视频学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-16T20:13:27+08:00">
                2019-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/vue相关/" itemprop="url" rel="index">
                    <span itemprop="name">vue相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每个vue实例在被创建时候都要经历一系列的初始化过程，<br>设置数据监听，编译模板，将实例挂载到DOM并在数据变化时更新DOM，<br>同时这个过程会运行一些<strong>生命周期函数钩子</strong>,<br>created:实例被创建<br>mouted,updated,destroyed.<br>计算属性的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&quot;example&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:&quot;hello</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        vm.reverseMessage依赖于message,所以message一旦变化 reverseMessage就会变化</span><br><span class="line">        reverseMessage:function() &#123;</span><br><span class="line">        </span><br><span class="line">            return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        fullName:&#123;</span><br><span class="line">            //get和set方法</span><br><span class="line">            get:function()&#123;</span><br><span class="line">             return this.firstName</span><br><span class="line">            &#125;</span><br><span class="line">            set:function(newValue)&#123;</span><br><span class="line">                this.firstName = &quot;ckq&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>计算属性是基于它们的响应式依赖进行缓存的，只有相关响应式发生了变化，才会重新求值。<br>message没变化，多次访问reverseMessage。计算属性还是返回之前计算的结果。<br>而不必再次执行函数。<br>侦听属性，利用watch:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">firstName:function(val)&#123;</span><br><span class="line">    this.fullName = val + this.lastName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过class和style绑定属性的时候，可以通过对象或者是数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class = &quot;&#123;active:isActive&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>active这个class是否加载决定于isActive属性是否为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    classObj:&#123;</span><br><span class="line">        active:true,</span><br><span class="line">        &apos;text-danger&apos;:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class = &quot;[active,error]&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>内联样式的绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style = &quot;&#123;color:active&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>v-if用于条件渲染<br>v-if与v-else联合使用 v-else-if联合使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if = &quot;ok&quot;&gt;</span><br><span class="line">&lt;h1&gt;title&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;p1&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<p>v-if与v-show的区别<br><strong>v-if是真正的条件渲染，当为false时会删除dom</strong><br><strong>而v-show是是会修改其css属性来展现与否。</strong><br><strong>当不存在的时候，v-if是从dom中移除，v-show为隐藏，不从dom中移除。</strong><br>v-for的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for = &quot;(item,index) in items&quot;&gt;</span><br><span class="line">&lt;li v-for = &quot;(value,name,index) in object&quot;&gt;</span><br><span class="line">&#123;&#123;index&#125;&#125; --&#123;&#123;item.message&#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure></p>
<p>当vue正在更新使用v-for渲染的元素列表时，使用”就地跟新”原则，<br>如果数据项的顺序被改变，vue将不会移动dom元素来匹配数据项的顺序，而是就地跟新每个元素，并且确保在每个索引位置都被<br>正确的渲染。类似于vue 1.x中的track-by = “$index”<br>可以使用key进行绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for = &quot;item in items&quot; v-bind:key = &quot;item.id&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>利用响应式<br>Vue.set(vm.items,indexOfItems,value);<br>当处于同一个节点时，v-for的优先级比v-if更高，这意味着v-if将分别重复运行于每个v-for循环中，当你只想为部分项渲染节点时，这种优先级机制十分有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li is = &quot;todo-item&quot; v-for = &quot;(todo,index) in todos&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>的 is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要,这么做实现的效果与<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;todo-item&gt;</span><br></pre></td></tr></table></figure></p>
<p>相同。<br>但是可以避开一些潜在的浏览器解析错误。<br>v-on:click.stop = “doThis”<br>v-on:submit.prevent = “on<br>v-on:keyup.13 = “submit”<br>@click.ctrl = “onclick”<br>v-model在表单input,textarea以及select上创建数据的双向绑定<br>v-model本质上还是语法糖，负责监听用户的输入事件并且更新数据。并对一些极端场景进行一些特殊处理。<br>会忽略所有表单的check,value,select值。<br>总是将vue实例的数据作为数据来源。应该通过js在组件中data选项声明初始值。<br>vue自定义组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//vue自定义组件</span><br><span class="line">  Vue.component(&apos;button-counter&apos;,&#123;</span><br><span class="line">      data:function () &#123;</span><br><span class="line">          return&#123;</span><br><span class="line">              count:0</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template:&apos;&lt;button v-on:click = &quot;count++&quot;&gt;&apos;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>与new Vue接收相同的选项 例如data,computed,watch,methods等以及生命周期函数钩子<br><strong>data必须是一个函数。而不是一个对象，因此每个实例可以维护一份被返回对象的独立的拷贝</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:function()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Vue.component是全局注册的<br>通过props向子组件传递数据<br>一个值传递给props，就变成了组件实例的一个属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;blog&apos;,&#123;</span><br><span class="line">    props:[&apos;title&apos;],</span><br><span class="line">    template:&apos;&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>就像访问data中的数据是一样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post :key = &apos;post.id&apos; :title = &apos;post.title&apos;&gt;</span><br></pre></td></tr></table></figure></p>
<p>每个组件必须要有一个根元素，可以将模板的内容包裹在一个根元素内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;div v-html = &quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>component的is属性来切换组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>
<p>vue组件注册通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue.component(&apos;my-comment-name&apos;,&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">//使用时候</span><br><span class="line">&lt;my-component-name&gt;&lt;/my-component-name&gt;</span><br></pre></td></tr></table></figure></p>
<p>全局注册往往不理想，局部注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var ComponentA = &#123;&#125;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        &apos;component-a&apos;:ComponentA,</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>导入组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import ComponentA from &apos;./ComponentA&apos;;</span><br><span class="line">export default&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        ComponentA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>props传递对应的值类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    title:String,</span><br><span class="line">    likes:Number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提供了类型检测 在使用时。<br><strong>任何类型的值都可以传递给props</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post v-bind:likes = &quot;42&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post v-bind:is-publish = &quot;false&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post v-bind:comment-ids=&quot;[234, 266, 273]&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;blog-post</span><br><span class="line">  v-bind:author=&quot;&#123;</span><br><span class="line">    name: &apos;Veronica&apos;,</span><br><span class="line">    company: &apos;Veridian Dynamics&apos;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;&lt;/blog-post&gt;</span><br></pre></td></tr></table></figure></p>
<p>props都是单向数据流的传递 父级props的跟新会向下流动到子组件中，但是反过来是不会的。<br>这样可以阻止子组件意外改变父组件的状态<br>每次父组件发送变化，子组件props都会刷新为最新的值<br>注意：js中对象和数组都是通过引用传入的，所以对于一个数组或者对象类型的props,<strong>在子组件中改变这个对象或数组本身将会影响在父组件中的状态。</strong><br>注意prop会在一个组件实例创建之前进行验证，所有实例的属性，例如data,computed等在函数中是不可用的。<br>事件名：事件名不存在任何自动化的大小写转换。而是触发的事件名必须匹配这个事件所用的名称<br>触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&quot;myEvent&quot;)</span><br></pre></td></tr></table></figure></p>
<p>随后在组件上绑定事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-on:my-event = &quot;doSomthing&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>自定义事件重点看</strong><br>自定义指令，在页面打开后，应该自动聚焦到输入框上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;,&#123;</span><br><span class="line">    inserted:function(el)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="指令的钩子函数"><a href="#指令的钩子函数" class="headerlink" title="指令的钩子函数"></a>指令的钩子函数</h2><p><strong>bind</strong>:只调用一次，指令第一次绑定到元素时调用，在这里可进行一次性的初始化操作。<br><strong>inserted</strong>:被绑定元素插入到父节点时调用，(仅保证父节点存在，但不一定已被插入到文档中)<br><strong>updated</strong>:所有组件的VNode更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。<br><strong>componentUpdated</strong>:指令所在组件的VNode及其子VNode全部跟新后调用<br><strong>unbind</strong>:只调用一次，指令与元素解绑时调用。<br>尝试使用render函数来做渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;anchor&apos;,&#123;</span><br><span class="line">    render:function(createElement)&#123;</span><br><span class="line">        return createElement(</span><br><span class="line">            &apos;h&apos; + this.level, //标签名称</span><br><span class="line">            this.$slots.default//子节点数组</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        level:&#123;</span><br><span class="line">            type:Number,</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>createElement返回的是createNodeDescription,因为它所包含的信息会告诉vue页面上需要渲染什么节点。包括其子节点的描述信息。<br>插件的使用<br>通过全局的方法Vue.use()来加载使用插件<br>需要在new Vue()之前使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Vue = require(&apos;vue&apos;);</span><br><span class="line">var vueRouter = require(&apos;vue-router&apos;);</span><br><span class="line">Vue.use(vueRouter);</span><br></pre></td></tr></table></figure></p>
<p>过滤器<br>双括号插值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;message | capitalize&#125;&#125;</span><br><span class="line">filters:&#123;</span><br><span class="line">    capitalize:function(value)&#123;</span><br><span class="line">        if(!value)</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">        value = value.toString();</span><br><span class="line">        return value.charAt(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>过滤器的连续使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;message | filterA | filterB&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>将过滤器A执行完的结果传递给过滤器B<br>vue单文件的预处理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template lang = &quot;jade&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">ccc</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    data() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;.</span><br><span class="line">    components:&#123;</span><br><span class="line">        otherComponents</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>vue进行<strong>异步跟新DOM</strong>的情况，一些依赖DOM更新结果的断言必须在<br>vue.nextTick中回调中进行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.nextTick(() =&gt; &#123;</span><br><span class="line">    expect(vm.$el.textContent).toBe(&apos;foo&apos;);</span><br><span class="line">    done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.env.NODE_ENV</span><br></pre></td></tr></table></figure></p>
<p>vue源码根据process.env.NODE_ENV决定是否启用生产环境模式，默认为开发环境模式。</p>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>通过nuxt.js搭建服务端渲染。nuxt是一个基于vue生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。更酷的是，你甚至可以用它来做为静态站生成器。推荐尝试。<br>this.$nextTick保证元素被挂载到dom中才触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">  this.$nextTick(function () &#123;</span><br><span class="line">    // 代码保证 this.$el 在 document 中</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="vue中slot的使用"><a href="#vue中slot的使用" class="headerlink" title="vue中slot的使用"></a>vue中slot的使用</h3><p>vue中slot的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;span&gt;1111&lt;/span&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:&quot;&lt;div&gt;这是一个div标签&lt;/div&gt;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>child内部的span等标签会被div等所有的覆盖掉 没有slot的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;computer&gt;</span><br><span class="line">       &lt;div slot = &quot;CPU&quot;&gt;ddd&lt;/div&gt;</span><br><span class="line">       &lt;div slot = &quot;GPU&quot;&gt;GPU&lt;/div&gt;</span><br><span class="line">   &lt;/computer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;computer&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">&lt;slot name = &quot;CPU&quot;&gt;CPU插槽&lt;/slot&gt;</span><br><span class="line">&lt;slot name = &quot;GPU&quot;&gt;GPU插槽&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>根据name进行绑定 将slot具体渲染成对应组件</p>
<p>单个slot的情况<br>简单来说，使用slot标签，可以将<span>1111</span>放到子组件中想让他显示的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span&gt;1111&lt;/span&gt;</span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>子组件内部的slot标签会被渲染成<span>1111</span>所以可以将父组件中的传过来<br>有多个标签的时候也会被插入，被当成一个slot来看待<br>具名slot(有名称的slot)<br>将放在子组件里的不同html标签放在不同的位置<br>父组件在要分发的标签里面添加slot = “name名”的属性<br>子组件在对应的分发位置的slot标签里面，添加name = “name”属性，<br>然后会将对应的标签放在位置里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span slot = &quot;one&quot;&gt;one&lt;/span&gt;</span><br><span class="line">       &lt;span slot = &quot;two&quot;&gt;two&lt;/span&gt;</span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot name = &quot;two&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;br&gt;</span><br><span class="line">这是&lt;slot name = &quot;one&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>将父标签里的two渲染到子组件里的第一个，将父标签里的one渲染到子组件李的第二个<br>没有slot的话，将会显示默认的值。<br>也就是没有将父组件中的slot插入到子组件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;span slot = &quot;one&quot;&gt;one&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">这是&lt;slot name = &quot;two&quot;&gt;no two&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;br&gt;</span><br><span class="line">这是&lt;slot name = &quot;one&quot;&gt;&lt;/slot&gt;</span><br><span class="line">一个div</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>slot = two 没有标签，因此显示内部的no two<br>作用域插槽是一种特殊类型的插槽，用作一个(能被传递数据的)可重用模板，来代替已经渲染好的元素，<br>在子组件中，只需要将数据传递到插槽，就想你将prop传递给组件一样，<br>在父级中，具有特殊属性slot-scope的template的元素必须存在，表明它是作用域插槽的模板。<br>slot-scope的值被用作一个临时变量，此变量收集从子组件传递过来的props<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;app&quot;&gt;</span><br><span class="line">   &lt;child&gt;</span><br><span class="line">       &lt;template slot-scope = &quot;props&quot;&gt;</span><br><span class="line"></span><br><span class="line">           &lt;p&gt;hello from parent&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&#123;&#123;props.tt&#125;&#125;&lt;/p&gt;</span><br><span class="line">       &lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;,&#123;</span><br><span class="line">        template:`&lt;div&gt;</span><br><span class="line">&lt;slot tt = &quot;hello from child&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">`,</span><br><span class="line">    &#125;);</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>将子组件的传递到父组件中,如下示例，当子组件循环的时候，某一部分dom结构由外部传递进来，<br>使用作用域插槽，子组件可以向父组件插槽传递数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;root&quot;&gt;</span><br><span class="line">    &lt;child&gt;</span><br><span class="line">        &lt;template slot-scope = &quot;props&quot;&gt;</span><br><span class="line">            &lt;p&gt;&#123;&#123;props.item&#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&apos;child&apos;,&#123;</span><br><span class="line">        data:function () &#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                list:[1,2,3,4,5]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template:`</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">&lt;slot v-for=&apos;item of list&apos; :item = item&gt;&lt;/slot&gt;</span><br><span class="line">`</span><br><span class="line">    &#125;)</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el:&quot;#root&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>作用域插槽，统一为渲染的模板。为不同的渲染添加值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">    &lt;my-list title=&quot;caokaiqiang&quot; :items=&quot;shapes&quot;&gt;</span><br><span class="line">        &lt;div slot-scope=&quot;vv&quot;&gt;&#123;&#123;vv.name&#125;&#125;&lt;small&gt;（&#123;&#123;vv.sides&#125;&#125;条边）&lt;/small&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/my-list&gt;</span><br><span class="line"></span><br><span class="line">    &lt;my-list title=&quot;颜色&quot; :items=&quot;colors&quot;&gt;</span><br><span class="line">        &lt;div slot-scope=&quot;ad&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;colorbox&quot; :style=&quot;&#123;background:ad.hex&#125;&quot;&gt;&#123;&#123;ad.name&#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/my-list&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    Vue.component(&apos;my-list&apos;, &#123;</span><br><span class="line">        props:[&quot;title&quot;,&quot;items&quot;],</span><br><span class="line">        template: `</span><br><span class="line">  &lt;div class=&quot;my-list&quot;&gt;</span><br><span class="line">              &lt;h3 class=&quot;title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span><br><span class="line">              &lt;div class=&quot;list&quot;&gt;</span><br><span class="line">                  &lt;slot v-bind=&quot;item&quot; v-for=&quot;item in items&quot;&gt;&lt;/slot&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">  `</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &apos;#components-demo&apos;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            shapes:[&#123; name:&apos;正方形&apos;, sides:4&#125;,&#123; name:&apos;六边形&apos;, sides:6&#125;,&#123; name:&apos;三角形&apos;, sides:3&#125;],</span><br><span class="line">            colors:[&#123; name: &apos;黄色&apos;, hex: &apos;#f4d03f&apos; &#125;,&#123; name: &apos;绿色&apos;, hex: &apos;#229954&apos; &#125;,&#123; name: &apos;紫色&apos;, hex: &apos;#9b59b6&apos; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>两个组件中相同的slot的for循环放到子组件中slot来代替，随后通过slot-scope和绑定:item来从父组件中传递数据到子组件中<br>vue子组件向父组件中传递值，通过触发事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&apos;parent-show&apos;);</span><br></pre></td></tr></table></figure></p>
<p> 在组件中绑定事件<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;component1 @parent-show = &apos;show&apos;&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    show:function() &#123;</span><br><span class="line">        console.log(&quot;父组件中的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在vue中，通过ref属性获取DOM元素的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 id = &quot;myH3&quot; ref = &quot;myTitle&quot;&gt;&lt;/h3&gt;</span><br><span class="line">console.log(this.$refs.myTitle.innerText);</span><br></pre></td></tr></table></figure></p>
<h2 id="vuex使用笔记"><a href="#vuex使用笔记" class="headerlink" title="vuex使用笔记"></a>vuex使用笔记</h2><p>state是统一状态的管理，对state的改变只能通过action来改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var store = &#123;</span><br><span class="line">    debug:true,</span><br><span class="line">    state:&#123;</span><br><span class="line">        message:&quot;hello&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    setMessage(newValue)&#123;</span><br><span class="line">        this.state.message = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>组件不允许直接修改属于store实例的state,而应该执行action来分发(dispatch)事件通知store去改变，我们最终也达成了flux架构，这样约定的好处，我们能够记录所有store中发生的state改变，同时实现能做到记录变更(mutation),保存状态快照，历史回滚等。</p>
<p>应用遇到多个组件共享状态时，需要多个组件依赖同一个状态，或是来自不同视图的行为来修改同一个状态。<br>vuex是一个专门为vue.js开发的状态管理模式，采用<strong>集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方法发生变化，对vue中多个组件的共享状态进行集中式的管理</strong><br>全局拥有一个state存放数据，组件修改state中的数据时，必须通过mutation进行，mutation同时提供了<strong>订阅者</strong>模式提供外部插件调用来获取state数据的更新，当所有的异步操作结束后，常见于action操作后，action通过mutation来修改state的数据，最后state通过渲染再呈现到html上。<br>dispatch:操作行为触发方法，唯一执行action的方法<br>action:操作行为处理模块，组件中的$store.dispatch(‘action’,detail)来触发<br>然后通过commit交给mutation,mutation通过同步操作来修改state中的值。<br>store.js文件的创建，里面来存储相应的state,mutation,action和getter函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Vuex from &apos;vuex&apos;;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">//创建store</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:0</span><br><span class="line">    &#125;,</span><br><span class="line">    //mutation来修改store</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        INCREMENT(state)&#123;</span><br><span class="line">            state.count = state.count + 1;</span><br><span class="line">        &#125;,</span><br><span class="line">        DECREMENT(state)&#123;</span><br><span class="line">            state.count = state.count - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">        //通过读取属性自动调用并返回属性值</span><br><span class="line">        evenOrOdd(state)&#123;</span><br><span class="line">            return state.count % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        //包含了多个异步操作 包含了多个直接更新state函数的对象</span><br><span class="line">        incrementIfOdd(&#123;commit,state&#125;)&#123;</span><br><span class="line">            if(state.count % 2 === 1)</span><br><span class="line">                commit(&apos;INCREMENT&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        incrementAsync(&#123;commit&#125;)&#123;</span><br><span class="line">            setInterval(() =&gt; &#123;</span><br><span class="line">               commit(&apos;INCREMENT&apos;)</span><br><span class="line">            &#125;,2000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">//导出</span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure></p>
<p>习惯于mutation中的函数名称是大写的，而action中是小写的。<br>随后在main.js中使用创建好的store.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store&apos;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  store,</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></p>
<p>在helloWorld.vue中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;p&gt;click&#123;&#123;count&#125;&#125; times,count is &#123;&#123;evenOrOdd&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button @click=&quot;incrementIfOdd&quot;&gt;increment if odd-&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;incrementAsync&quot;&gt;increment async-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&quot;HelloWorld&quot;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">      count()&#123;</span><br><span class="line">        return this.$store.state.count;</span><br><span class="line">      &#125;,</span><br><span class="line">      evenOrOdd()&#123;</span><br><span class="line">        //计算型属性来计算值 通过state来获取</span><br><span class="line">        return this.$store.getters.evenOrOdd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      //同步加载</span><br><span class="line">      increment()&#123;</span><br><span class="line">        this.$store.commit(&apos;INCREMENT&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      decrement()&#123;</span><br><span class="line">        this.$store.commit(&quot;DECREMENT&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      incrementIfOdd()&#123;</span><br><span class="line">        //通过dispatch触发action</span><br><span class="line">        this.$store.dispatch(&apos;incrementIfOdd&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      incrementAsync()&#123;</span><br><span class="line">        this.$store.dispatch(&apos;incrementAsync&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果想直接使用mutation,通过this.$store.commit(“INCREMENT”)来直接使用，<br>如果想通过异步，则通过dispatch触发action,再通过action来触发mutation<br>this.$store.dispatch(“incrementAsync”);<br>通过简便的方法来缩写action,mutation,getter和state<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapActions, mapGetters, mapState, mapMutations &#125; from &quot;vuex&quot;;</span><br><span class="line">...</span><br><span class="line"> computed: &#123;</span><br><span class="line">    ...mapState([&quot;count&quot;]),</span><br><span class="line">    ...mapGetters([&quot;evenOrOdd&quot;])</span><br><span class="line">    &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([&quot;incrementIfOdd&quot;, &quot;incrementAsync&quot;]),</span><br><span class="line">    ...mapMutations([&quot;increment&quot;, &quot;decrement&quot;])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意的是mapMutation中的和methods中的方法名称必须保持一致。<br>getters可以看做在获取数据前对数据进行的进一步加工<br>action和mutation的区别，action是异步跟新，mutation是同步跟新<br>同步的意义在于每一个mutation的跟新都对应一个新的状态，可以看到mutation是如何改变的。<br>mutation传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&apos;INCREMENT&apos;,2);</span><br><span class="line">随后在mutation中添加</span><br><span class="line">   INCREMENT(state,n)&#123;</span><br><span class="line">          state.count = state.count + n;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="vue直播课"><a href="#vue直播课" class="headerlink" title="vue直播课"></a>vue直播课</h2><p>provide &amp; inject 类似react中的上下文<br>provide在父组件中注入，在子组件中就可以进行获取<br>inject:[‘title’] 祖先元素提供的 不需要通过props 来一个个传值<br>但是provider和inject不是响应式的，如果子孙元素想要通知祖先，就需要hack一下，vue1中有dispatch和boardcast2个方法，但是vue2中被干掉了。我们可以自己模拟一下。<br>原理就是可以通过this.parent和boradcast获取子元素，this.children来获取父组件和子组件，我们自己递归一下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">dispatch(eventName,data)&#123;</span><br><span class="line">    let parent = this.$parent;</span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">    borardcast.call(child,eventName,data); </span><br><span class="line">&#125;</span><br><span class="line">//全局挂载的方法</span><br><span class="line">Vue.prototype.$dispatch = function(eventName,data)&#123;</span><br><span class="line">    //向上传递 一直不停的获取$parent</span><br><span class="line">    let parent  = this.$parent;</span><br><span class="line">    while(parent)&#123;</span><br><span class="line">        parent.$emit(eventName,data);</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子元素</span><br><span class="line">Vue.prototype.$boardcast = function(eventName.data)&#123;</span><br><span class="line">    //通知递归所有子元素</span><br><span class="line">    boardcast.call(eventName,data);</span><br><span class="line">&#125;</span><br><span class="line">function boardcast(eventName,data)&#123;</span><br><span class="line">    this.$children.forEach(child =&gt; &#123;</span><br><span class="line">        child.$emit(eventName,data);</span><br><span class="line">        if(child.$children.length)&#123;</span><br><span class="line">    boardcast.call(child,eventName,data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">this.$on(&quot;boardcast&quot;,msg =&gt; &#123;</span><br><span class="line">    console.log();//通过监听</span><br><span class="line">&#125;)</span><br><span class="line">eventBus全局实现 </span><br><span class="line">class Bus&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.callBacks =&#123;</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        //监听 触发</span><br><span class="line">        $on(name,fn)&#123;</span><br><span class="line">       this.callBacks[name] = this.callBacks[name] || [];</span><br><span class="line">       this.callBacks[name].push(fn);</span><br><span class="line">        &#125;</span><br><span class="line">        $emit(name,args)&#123; </span><br><span class="line">            if(this.callbacks[name])&#123;</span><br><span class="line">                this.callbacks[name].forEach(cb =&gt; cb(args));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.$bus = new Vue();</span><br></pre></td></tr></table></figure></p>
<p>$bus触发所有的事件<br>自定义input监听on和input事件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :type = &quot;type&quot; :value = &quot;value&quot; @input = &quot;onInput&quot;&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    onInput(e)&#123;</span><br><span class="line">        this.$emit(&quot;input&quot;,e.target.value);</span><br><span class="line">        this.$parent.$emit(&quot;validate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">v-model的语法糖</span><br><span class="line">k-form-item 负责显示label 执行校验，和显示校验结果 插槽作组件扩展</span><br><span class="line">form进行全局校验</span><br><span class="line">能够获取全部的规则</span><br><span class="line">inject:[&quot;form&quot;];</span><br><span class="line">models:&#123;&quot;username&quot;:&quot;&quot;,&quot;password&quot;:&quot;&quot;&#125;,</span><br><span class="line">rules:&#123;</span><br><span class="line">    username:[</span><br><span class="line">        &#123;required:true,message:&quot;请输入用户名&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">schema来做校验</span><br><span class="line">import Schema from &apos;async-validator&apos;</span><br><span class="line">每个item都有validate方法</span><br><span class="line">单元测试:站在外层来进行测试，期望获取的结果是想要的</span><br></pre></td></tr></table></figure></p>
<p>vue router在实现前端应用时，使用hash模式和history模式<br>默认hash模式：使用URL的hash来模拟一个完整的URL，于是当URL改变时，页面不会重新加载。<br>hash(#)是URL中的锚点，代表的是网页中的位置，单改变#后面的值，不会重新加载网页，只会滚动到相应的位置。<br>hash出现在URL中，但不会出现在http中，不会对后端请求发生影响。<br>同时改变hash,会在浏览器访问历史中增加一个记录，使用后退按钮，就会回到上一个位置。<br>history模式：url像正常的url，例如<a href="http://www.baidu.com/user/id" target="_blank" rel="noopener">http://www.baidu.com/user/id</a>;<br>不过这种模式要弄好，还需要后台配置支持。因为我们的应用是SPA,如果后台没有正确的配置，用户访问时就会出现404，<br>要在服务端增加一个覆盖所有情况的候选资源，如果URL匹配不到任何静态资源，则应该返回同一个index.html的页面。</p>
<p>属性，事件和插槽3个vue基础概念。<br>属性：自定义属性props,原生属性attrs,特殊属性class,style。<br>props:称为静态数据，vue是单向数据流，数据传递时不能改变数据类型，而且不允许子组件中直接操作。<br>.sync实现双向绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;demo :show.sync = &quot;show&quot; :msg.sync = &quot;msg&quot; :arr = &quot;arr&gt;</span><br><span class="line"> props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;,</span><br><span class="line">    show: &#123;</span><br><span class="line">      type: Boolean</span><br><span class="line">    &#125;,</span><br><span class="line">    arr: &#123;</span><br><span class="line">      type: Array //在子组件中改变传递过来数组将会影响到父组件的状态</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>通过props从父组件传递到子组件中<br>vue中是由数据驱动的，是指视图是由数据驱动生成的。<br>对视图的修改，不是直接操作DOM,而是修改对应数据。<br>用户执行某个操作 -&gt; 反馈到VM处理(可以导致model变动) -&gt; VM层改变，通过绑定关系直接更新页面对应位置的数据。<br>.lazy事件，以往通常是input中一旦键入键盘就触发change事件，现在可以转变为当输入完所有内容后，光标离开才跟新视图的场景。<br>render和template都定义，执行render<br>Vue.use函数 插件和事情<br>plugin.install 是方法.<br>plugin.install.apply(plugin,args);<br>plugin都会执行<br>vuex刷新就没了 localStorage还存储在数据中<br>强类型 typescript<br>vuex源码！！！typescript和docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang = &quot;ts&quot;&gt;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">import Hello form &quot;./components/Hello.vue</span><br><span class="line">@Component(&#123;</span><br><span class="line">    components:&#123;</span><br><span class="line">        HelloWorld,Hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default class App extends Vue&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>1.vue-cli<br>2.数据mock,跨域，假数据<br>3.工作流 githook eslint<br>4.webpack 模块化原理<br>5.vuex源码<br>6.router 看了源码<br>7.jwt中的具体操作<br>登录 网络拦截器 token 路由权限 addRoutes<br>token是一段加密字符串 加密函数(用户id + 随机数 + 过期时间)<br>解密token token放在header之上 token 1.注销登录 2.过期了 对称加密</p>
<p>npm run build dist包<br>线上机器有一个nginx目录<br>1.前端有一个部署机jekins 跑build copy代码，上线<br>2.push之后，jekins点按钮，打包ssh到机器上 解压<br>3.push之后，github或者gitlab的webhook 重新发布docker.<br>devops自动运维。<br>SSR服务端渲染，后端把vue或者react解析成DOM标签，首屏就能直接渲染dom.<br>nuxt就是SSR的最佳实践框架。<br>cloc ./ 看代码有几行<br>nginx和proxy区别，本地使用webpack-dev-serve的proxy做转发<br>线上没有webpack,有nginx,由nginx做转发。<br>vuex存储的变量什么时候销毁<br>缓存策略 LRU last recent use<br>队列：谁用得多留下来 谁用得少慢慢销毁<br>权限 网络拦截 性能优化 热重载 扩展 原理</p>
<p>编译 模板 -&gt; render函数 runtime<br>源码顺序<br>package.json<br>main 和 module<br>版本 不同方式引入<br>core -&gt; instance -&gt; init.js<br>initState,$mount 虚拟dom _render,_update,<br>整个的入口<br>web/entry-runtime-with-compiler.js<br>compiler 将template 编译成render函数 返回虚拟dom createElement<br>如果没有compile模块 文件变小，但只支持render<br>core 核心<br>platforms 平台 web weex<br>server 服务端渲染相关<br>sfc .vue文件解析 单页面解析 script style template<br>shared 公用的方法和常量<br>new Vue({<br>    template:<br>    <div id="app"></div><br>})<br>编译成<br>render:h =&gt; {<br>    return h(‘div’,{attrs:{id:app}},this.name);<br>}<br>每一个依赖放到watcher里面<br>watcher放到dep里面 dep放到defineReactive里面去收集<br>observer观察dep<br>解析dom内容 k-model事件<br>this.$compile = new Compile()<br><strong>vue vuex vue-router全家桶代码</strong><br>node 最佳实践 eggjs 1.1mvc分层 约定大于配置 nginx+docker部署<br>mixin 是自己的 extend给儿子了 是继承<br>react推荐用umi 脚手架<br>auth2第三方登录 微信 微博登录<br>虚拟dom就是object对象123 createElement({div,id:app,123}),大的object对象，模拟树形结构<br>{<br>    type:div,<br>    props:{id:div},<br>    children[<br>        {type:组件}<br>    ]<br>}<br>ast抽象语法树 super-tiny-compiler 前端编译<br>codegen<br>vue的生命周期函数<br>在newVue后 首先初始化事件event和生命周期lifecycle等<br>实际就是往上面挂载一些函数<br>这里到达的是beforeCreate<br>随后是初始化provide和inject中的一些实例<br>这里data和props都已经加载完毕 可以调用<br>随后将el元素挂载上去，如果有模板编译的话，首先执行模板编译生成render函数 这里是挂在前beforeMount<br>随后根据render函数产生虚拟dom,真正的渲染到dom上，触发mouted,在update的时候，根据不同情况产生不同的虚拟dom进行对比，利用patch算法进行对比和渲染，到真正的dom上。在销毁的时候触发beforeDestroy方法。将监听组件等全部取出，随后触发destroy方法<br><a href="https://www.cnblogs.com/happ0/p/8075562.html" target="_blank" rel="noopener">生命周期链接</a><br><a href="https://blog.csdn.net/running_runtu/article/details/79936503" target="_blank" rel="noopener">生命周期最好的回答</a><br>性能优化<br>文件更快加载 文件执行次数更少<br>很多dom都是可以重用的 整个dom的元素就这么多<br>整个3屏 整个的dom元素是不会增加的，上面去除的拿到下面来添加上  上面的屏幕都放到下面来 骨架屏<br>SSR 服务端渲染</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/浏览器缓存机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/浏览器缓存机制/" itemprop="url">浏览器缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T14:19:19+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/浏览器相关/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>缓存可以说是性能优化中简单高效的一种优化方式了，一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，<br>并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。<br>数据请求的步骤：发起网络请求，后端处理，浏览器响应。<br>浏览器缓存在第一步网络请求和浏览器响应2个环节中做性能优化。<br>缓存位置：<br>service worker:运行在浏览器背后的独立线程，一般可以用来实现缓存功能，<br>。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。service workder的缓存与浏览器其余内建缓存不同，它可以让我们<br><strong>控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的</strong><br>2.memory cache<br>memory cache也是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载好的样式，脚本等，<br>读取内存中的数据肯定比磁盘来得快，内存读取高效，可是缓存持续性很低，会随着进程的释放而释放，<br><strong>一旦关闭tab页面，内存中的缓存也就被释放了</strong>.<br><strong>内存缓存在缓存资源时并不关心返回的资源的http缓存头cache-control是什么，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。<br>3.disk cache 顾名思义也就是硬盘中的缓存，读取速度较低，但是什么都可以存储到磁盘中，，比之 Memory Cache 胜在容量和存储时效性上。
</strong>对于大文件来说，大概率是不会存储在内存中的，反之优先<strong>,
</strong>当前系统内存使用率高的话，文件优先存储进硬盘中<strong>.<br>4.push cache是http/2中的内容，当以上3种缓存都没有命中的时候，才会被使用，只在会话session中使用，一旦会话session结束，也就被释放，并且缓存时间很短。<br>出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个http连接。<br>大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为2种，</strong>强缓存和协商缓存<strong>,<br>并且缓存策略都是通过设置</strong>http header<strong>来实现的。<br>浏览器与服务器通信为应答模式，浏览器发出http请求，服务器响应后拿到数据，<br>浏览器如何确定一个资源该不该被缓存，如何去缓存呢。<br>浏览器第一次向服务器发起请求后拿到请求结果后，</strong>将请求结果和缓存标识<strong>存入浏览器缓存中，
</strong>浏览器每次发出请求，都会现在浏览器缓存中查找请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览<strong>
</strong>器缓存中<strong><br>确保了每个请求的缓存存入与读取，<br>是否需要向服务器重新发起http请求将缓存分为2个部分，分别是</strong>强缓存和协商缓存<strong><br>强缓存：不会向服务器发送请求，直接从缓存中读取资源，强缓存通过设置2种http header来实现，<br>expires 和 cache-control.<br>expires:</strong>用来指定资源到期的时间，是服务器端的具体的时间点<strong>,<br>expires = max-age + 请求时间，。需要和last-modified结合使用，<br>是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器都可以直接从浏览器缓存中读取数据，而无需再次请求。<br>cache-control主要用来控制网页缓存，cache-control:max-age=300,则代表在这个请求正确返回时间，5分钟内再次加载该网页，就会命中强缓存，cache-control可以在请求头或者响应头中设置。<br>expires是http1.0的产物，cache-control是http1.1的产物，同时存在，</strong>cache-control优先级高于expires.<strong><br>expires是一个过期的产物，现阶段它的存在只是一种兼容性的写法。<br>强缓存判断是否缓存的依据是是否超出某个时间或者某个时间段，</strong>而不用去关心服务器端的数据是否跟新了<strong>.<br>可能导致加载文件不是服务器端最新的文件，那我们如何得知</strong>服务器端内容是否已经发生了更新呢<strong>这时候就要用到协商缓存。<br>5.协商缓存。<br>协商缓存是强缓存失效后，浏览器携带着</strong>缓存标识向服务器发起请求,由服务器根据缓存标识决定是否使用缓存的过程，<strong>,<br>主要有以下情况，
</strong>协商缓存生效，返回304和not modified<strong> 
</strong>协商缓存失效，返回200和请求结果<strong><br>协商缓存可以通过设置http header来实现，last-modified和if-modified-since.<br>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加last-modifed的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>last-modifed是文件在服务器上的最后修改时间。<br>浏览器下一次请求资源时，浏览器首先检测有last-modified这个header,于是添加if-modified-since这个header,值就是last-modified中的值，服务器收到资源后，会根据if-modified-since中的值和服务器中的最后修改时间作比较，如果没有变化，就返回304和空的响应体，直接读取缓存，如果If-Modified-Since的时间小于浏览器的最后修改时间，说明文件有更新，于是返回新的资源文件和200.<br>如果本地打开了缓存文件，即时没有修改文件，也会造成last-modified被修改，服务器不能命中缓存导致发送相同的资源。<br>既然根据文件修改时间来决定是否缓存尚有不足，能否根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了ETag和If-None-Match.<br>ETag是服务器响应请求时，返回当前资源文件的一个唯一标示，(由服务器生成)，只要资源有变化，ETag就会重新生成，浏览器在下一次加载资源并向服务器端发送请求时，，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传过来的if-none-match和自己服务器上的etag标签是否一致即可。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。<br>etag优于last-modified<br>强缓存优于协商缓存进行。，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，</strong>协商缓存有服务器决定是否使用缓存**，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。<br>用户行为对浏览器缓存的影响：指的是用户在浏览器操作时，会触发怎样的缓存策略。<br>打开网页：直接输入地址，查找disk cache中是否有匹配。。如有则使用；如没有则发送网络请求。<br>普通刷新(f5),因为tab并没有关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache.<br>强制刷新(ctrl + f5),浏览器不使用缓存，存，因此发送的请求头是:cache-control:no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/深入浅出浏览器渲染定理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/深入浅出浏览器渲染定理/" itemprop="url">深入浅出浏览器渲染定理与模块化概念，类型转换等</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-05T20:47:26+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器相关/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浏览器的内核是指支持浏览器运行的最核心的程序，分为2个部分，一是渲染引擎，另一个是js引擎，<br>渲染引擎在不同的浏览器中也是不同的，目前市面上常见的浏览器内核有Trident(IE),Gecko(火狐，<br>Blink(Chrome),Webkit(Safari),<br>webkit是当下浏览器世界真正的霸主<br>页面加载过程：<br>浏览器根据dns服务器得到域名的ip地址<br>向这个ip的机器发送http请求<br>服务器收到，处理并返回http请求<br>浏览器得到返回内容</p>
<p>一堆HTML格式的字符串，因为只有HTML格式浏览器才能正确解析，<br>HTML树 -&gt; DOM树形结构<br>CSS -&gt; CSS规则树<br>js脚本，等到js脚本文件加载后，通过dom api和cssom api来操作dom树和css规则树<br>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造render tree,渲染树。<br>渲染树会包括需要显示的节点和这些节点的样式信息。<br>css的规则树主要为了完成匹配吧css规则添加到渲染树上的每个节点<br>最后，计算每个frame的位置，这又叫layout和reflow过程。<br>字节数据 =&gt; 字符串 =&gt; token =&gt; node =&gt; dom<br>在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。<br>将字符串转化为token,例如<html>，<body>等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。<br><strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong><br>渲染过程中，如果遇到script就停止渲染，执行js代码，因为浏览器有GUI渲染线程和JS引擎线程。为了防止渲染出现不同的结果，这两个线程是<strong>互斥</strong>的关系，JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。<br>首屏渲染的越快的话，就越不应该在首屏就加载js文件，这也是将js放在body底部的原因。<br>js不仅阻塞dom的构建，也会导致cssom和dom的构建。<br>因为js不仅可以修改DOM，也可以修改样式。<br>因为js需要修改cssom.所以浏览器将延迟脚本执行和dom构建，直至完成cssom的下载和构建，<br><strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM</strong><br>根据渲染树进行布局，也可以叫做<strong>回流</strong>,<br>输出一个精准的<strong>盒模型</strong>,每个元素在视口内的准确位置。<br><strong>重绘</strong>：当我们对dom的修改导致了样式的变化，却并未影响到几何属性，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式<br><strong>回流</strong>：当我们对dom的修改引发了dom几何尺寸的变化，浏览器会重新计算，这个过程就是回流。<br><strong>回流一定会引发重绘，但重绘不一定引发回流</strong>.<br>减少重绘或者回流：<br>使用visibility替换display:none.因为前者会引发重绘。<br>不要使用table布局。<br>动画速度越快，回流次数越多<br>defer 使脚本在文档解析完成后执行。不会影响html的解析。<br>async:用于异步下载文件，下载完后立即解释执行。不会阻塞html的执行</body></html></p>
<h2 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h2><p>将一个复杂的程序依据一定的规则封装成几个块(文件),并进行组合在一起<br>块的内部数据与实现是私有的，只是向外部暴露一些接口(方法),与外部其他模块通信。<br>模块化的好处<br>避免命名冲突(减少命名空间污染)<br>更好的分离，按需加载<br>更高复用性<br>高可维护性<br>引入多个script后出现的问题<br>请求过多，会发送多个请求。依赖模糊，难以维护<br>可能出现牵一发而动全身的情况。<br>模块化规范：commonjs,AMD,ES6,CMD规范<br>commonjs node应用由模块组成，采用commonjs模块规范，<br>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong><br>暴露模块 module代表当前模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">exports.xxx = value;</span><br></pre></td></tr></table></figure></p>
<p>引入模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(xxx);</span><br></pre></td></tr></table></figure></p>
<p>commonjs规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作<br>amd规范则是非同步的，允许指定回调函数，由于node js主要用于服务端编程，，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<br>浏览器环境，要从服务器端加载模块，这时必须采用非同步模式，这时AMD就比较实适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define[&apos;modlue1&apos;,&apos;module2&apos;],function(m1,m2)&#123;</span><br><span class="line">    return 模块;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>引入使用模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;module1&apos;,&apos;module2&apos;,function(m1,m1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>requurejs是一个工具库，，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<br>基本思想：通过define,将代码定义为模块，通过require,实现代码的模块加载。<br>CMD<strong>规范专门用于浏览器端，模块的加载是异步的</strong>,模块使用时才会加载执行。<br>CMD整合了commonjs和amd规范的特点，在sea.js中，<br>通过define配置文件，通过requre导入文件。<br>AMD和CMD都适用于浏览器端，AMD同步，CMD异步。<br>ES6的模块化语法<br>export{basicNum,add};<br>import{add} from ‘./main’;<br>commonjs提出的是一个值的拷贝，而es6是值的引用。<br>commonjs是模块运行时加载，es6模块是**编译时输出的接口。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>js是一门动态类型语言，所谓的动态类型可以确定是在语言中一切内容是不确定的<br>如果运算符发现，运算子的类型与预期不符合，就会自动进行转换。<br><strong>自动转换时基于强制转换的，</strong><br>强制转换主要指使用Number,String,Boolean.3个函数<br>其他数据类型转换为string<br>toString()方法<br>null和undefined这2个值没有toString方法，如果调用，会报错<br>采用number类型的toString()方法的基模式，可以用不同的基输出数字，<br>例如二进制基为2，八进制为8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString(2)); //输出1010</span><br></pre></td></tr></table></figure></p>
<p>方式二 采用string函数<br>string函数作强制转换，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br><span class="line">String(a);//为字符串&quot;null&quot;</span><br><span class="line">String(&#123;a:1&#125;);//转化为[object Object]</span><br></pre></td></tr></table></figure></p>
<p>转为数字<br>如果字符串中有非数字的内容，则转为NaN,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(&quot;324&quot;);//324</span><br><span class="line">Number(&quot;324anc&quot;);//NaN</span><br><span class="line">Number(undefined);//转为NaN</span><br><span class="line">Number(&#123;a:1&#125;) //转化为NaN</span><br></pre></td></tr></table></figure></p>
<p>parseInt()把一个字符串转为整数，有效体转为整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(10.43a&quot;) //为10</span><br></pre></td></tr></table></figure></p>
<p>parseFloat()把一个字符串转为浮点数。<br>空字符串，null,undefined,+0,-0,和NaN转为布尔型为false.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>作用域是一个独立的地盘，让变量不会外泄，暴露出去，作用域最大的好处是隔离变量，不同作用域下的同名变量不会冲突。</strong><br>es6之间只有全局作用域和函数作用域。<br>es6提供了块级作用域。<br>let和const的声明并不会提升到当前代码块的顶部，因此需要手动提升。<br>let不能重复声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count = 30;</span><br><span class="line">   function outFun2() &#123;</span><br><span class="line">   let count = 20;</span><br><span class="line">    console.log(count);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上这种情况 在嵌套的作用域内使用let声明一个同名的新变量，<br>并不会抛出错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cnt = 30;</span><br><span class="line">let cnt = 40;</span><br></pre></td></tr></table></figure></p>
<p>作用域链，更确切的说是在<strong>创建这个函数的时候的作用域，而不是调用时候的</strong><br>以上这种情况便会报错。<br>js的执行分为解释阶段和执行阶段<br>解释阶段：词法分析，语法分析，作用域规则确定<br>执行阶段：创建执行上下文，执行函数代码，垃圾回收<br>执行上下文最明显的就是this的指向是在执行时候确定的。</p>
<h2 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h2><p>js是单线程任务，所有任务都需要排队，前一个任务结束，后一个任务才会接上，js中有2种任务，一种是同步任务，一种是异步任务，<br>异步任务指的是，不进入主线程，而进入<strong>消息队列</strong>的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入<strong>主线程</strong>,异步任务又包括<strong>宏任务</strong>和<strong>微任务</strong>,<br><strong>在所有同步任务执行完之前，异步任务是不会执行的</strong>.<br>event loop,只要主线程空了，就会去读取”任务队列”内的东西。<br>放入异步任务的代码：setTimeout,DOM事件，promise,ajax请求。<br>setTimeout和setInterval是过几秒后被放入异步队列<br>异步任务分为宏任务和微任务，<strong>宏任务队列可以有多个，而微任务队列只有一个</strong><br>宏任务包括:script全局任务，setTimeout,setInterval, setImmediate, I/O, UI rendering。<br>微任务包括：new Promise().then,<br>由于执行代码入口都是全局任务scrpit,而全局任务是属于宏任务，所以当栈为空的时候，首先执行微任务队列里的任务，再去执行宏任务队列中最前面的任务。执行宏任务过程中，遇到微任务，再依次加入微任务队列。<br>栈空后，再次读取微任务队列里的任务，以此类推。<br>当某个宏任务中代码全部执行完毕后，会查看是否有微任务队列，如果有，先执行微任务队列中的任务，如果没有，就查看是否有其他宏任务队列。</p>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，<strong>新旧对象还是共享同一块内存</strong>,<br>但是深拷贝会另外创建一个一模一样的对象，新对象和原对象不共享内存，修改新对象不影响原对象。<br>赋值赋的是栈中的地址，而不是堆中的地址。<br>浅拷贝的实现方式object.assign()<br>var initObj = Object.assign({},obj);<br>initObj.a.a = “wade”;<br>console.log(obj.a.a);//打印出来wade<br>深拷贝实现方式<br>json.parse(json.stringfy())<br>函数库loadash<br>该函数库有提供_.cloneDeep来做深拷贝</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化<br>只传递函数一部分参数来调用他，让他返回一个函数去处理剩余的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通add函数</span><br><span class="line">function add(x,y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">//柯里化后</span><br><span class="line">function curryAdd(x)&#123;</span><br><span class="line">    return function(y)&#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(1,2);</span><br><span class="line">curryAdd(1)(2);</span><br></pre></td></tr></table></figure></p>
<p>柯里化作用 可以起到参数服用 复用的结果<br>可以将一个reg返回后，返回一个带有一个正则表达式校验的函数，<br>在剩余函数中调用。</p>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>代表当前可见的计算机图形区域，在web浏览器中，通常与浏览器窗口相同，但不包括浏览器的UI，菜单栏等。<br>布局视口：布局视口是网页布局的基准窗口，在 PC浏览器上，布局视口就等于当前浏览器窗口大小（不包括 borders 、 margins、滚动条）。，移动端默认为980px<br> document.documentElement.clientWidth/clientHeight来获取<br>视觉视口：用户通过屏幕真实看到的区域：<br> 相当于浏览器的窗口大小，当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小<br>window.innerWidth和innerHeight来获取<br>理想视口：网站页面在移动端显示的理想大小。<br>当页面缩放比例为 100%时， CSS像素=设备独立像素， 理想视口=视觉视口。<br>screen.width /height</p>
<p>window.innerHeight 获取浏览器视觉视口高度<br>window.screen 屏幕理想视口宽度，设备的分辨率，设备像素比<br>document.clientHeight 布局视口高度<br>offsetHeight 获取包括内边距，滚动条，边框和外边距<br>scrollHeight在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。<br>移动端适配 @media移动端查询 flexible方案，统一使用rem来布局，<br>vh,vw方案将视觉视口window.innerWidth和height等分为100份<br>(连接)[<a href="https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ]</a></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是js的一个难点，<br>作用：可以访问函数内部的变量，使变量的值长期保存在内存中<br>形成条件：<strong>函数嵌套，内部函数引用外部函数的局部变量</strong><br>能够读取其他函数内部变量的函数<br>只有函数内部的子函数才能读取内部变量，因此可以把闭包理解为”定义在一个函数内部的函数”,<br>闭包的特点<strong>记住诞生的环境,比如f2记住了它诞生的环境f1,所以从f2可以得到f1的内部变量.
</strong>闭包将内部函数和外部函数连接起来的一座桥梁**<br>内存泄漏指的是任何对象在您不需要拥有或者使用的时候它仍然存在，闭包不能滥用，否则导致内存泄漏，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null.<br>闭包作用：读取函数内部的变量，可以使变量的值长期保存在内存中，生命周期比较长。<br>用来实现js模块，js模块:具有特定功能的js文件，将所有数据和功能都封装在一个函数内部，只向外暴露一个具有n个方法的对象或者函数，只需要通过暴露模块的对象调用来实现对应的功能即可。<br>forEach,map,filter,find,every,some,reduce它们都有共同的特点，不会改变原来数组。<br>线程与进程的区别</p>
<h2 id="node中的事件循环"><a href="#node中的事件循环" class="headerlink" title="node中的事件循环"></a>node中的事件循环</h2><p><strong>一个进程只有一个主线程</strong><br><strong>进程是cpu资源分配的最小单位,线程是cpu调度的最小单位</strong>,<br>一个进程可以由一个线程或多个线程组成，线程是一个进程中代码的不同执行路径<br><strong>进程的内存空间是共享的，每个线程都可以共享这些内存</strong><br>浏览器内核是多线程的，在内核控制下各个线程互相配合以保持同步，<br>GUI渲染线程，js引擎线程，定时触发线程，事件触发线程，异步http请求线程。<br>node中的event loop<br>node中的event loop和浏览器中的完全是不相同的东西，node js采用v8作为js的解析引擎，而I/O处理方面采用了自己设计的libuv.<br>libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统的底层特性，对外提供统一的api,事件循环机制也是这里面实现的。<br>node js运行机制如下:<br>v8引擎解析js脚本。<br>解析后的代码，调用node api.<br>libuv库负责node api的执行，将不同的任务分给不同的线程执行，形成一个event loop,以异步的方式将<strong>任务的执行结果返回v8引擎</strong>.<br>v8引擎将结果返回给用户</p>
<p>libuv执行node api分为以下几个阶段<br>事件循环分为6个阶段，会按照顺序反复执行，每当进入一个阶段时，都会从对应的回调队列中取出函数去执行，当队列为空或者执行的回调函数达到系统设定时，将会进入下一个阶段。<br>外部输入数据 -&gt; 轮询阶段(poll) -&gt; 检查阶段(check) -&gt; 关闭事件回调阶段(close callback) -&gt; 定时器检测阶段(timer) -&gt; I/O事件回调阶段(I/O callbacks) -&gt; 闲置阶段(idle,prepare)<br>timers阶段(这个阶段执行timer(setTimeout,setInterval))的回调<br>i/o callback阶段，处理一些上一轮循环中少数的未执行的i/o回调<br>idle 仅node内部使用<br>poll阶段 获取新的i/o事件。<br>check阶段 执行setimmediate的回调<br>close callback 执行socket的close事件回调</p>
<p>poll阶段<br>1.回到timer阶段执行回调<br>2.执行i/o回调<br>并且在进入该阶段如果没有设定timer的话，会发生如下事件<br>如果poll队列不为空，会遍历回调队列并且同步执行，直到队列为空或者达到系统上线<br>如果poll队列为空，如果有setimmediate回调需要执行，poll阶段停止并且进入到 check 阶段执行回调<br>如果没有setimmediate，会等待回调被加入到队列中并立即执行。<br>check阶段 setimmediate的回调会被加入到check中<br>node中事件也有宏任务(macro)和微任务(micro)<br>macro:setTimeout,setInterval,setImmediate,script代码<br>micro:process.nextTick,new Promise().then(回调)<br>process.nextTick,独立于event loop外，有自己的一个队列，<br>当每个阶段完成后，如果存在nextTick队列，会清空队列中的所有回调函数，并且优于其余的微任务执行。<br>浏览器环境中，microtask的任务队列是每个macrotask执行完后再执行<br>而在node js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask中的任务。</p>
<h2 id="js中的垃圾回收和内存泄漏"><a href="#js中的垃圾回收和内存泄漏" class="headerlink" title="js中的垃圾回收和内存泄漏"></a>js中的垃圾回收和内存泄漏</h2><p>内存泄漏指的是：不再用到的内存，没有来级的释放。js具有<strong>自动回收垃圾机制</strong><br>js的垃圾回收机制：找出不再使用的变量，然后释放掉其内存即可。<strong>垃圾回收期会按照固定的时间间隔周期性的回收</strong><br>垃圾回收有2种方法：标记清除和引用计数<br>标记清除：<strong>当变量进入执行环境时，就标记这个变量进行环境</strong>，逻辑上讲，永远不要释放进入环境的变量所占用的内存，因为只要执行刘进入相应的环境，就可能会用到他们，<strong>当变量离开环境的时候，就将其标记为离开环境。</strong><br>引用计数：是指语言引擎有一张‘引用表’，保存了内存里面的所有资源(通常是各种值)的引用计数。<br>如果一个值的引用计数为0，就表示该值不会再用到，因此可以将该值释放。<br>如果一个值不再需要了，引用计数却不为0，垃圾回收机制将无法识别这块内存。从而导致内存泄漏。<br>哪些情况会造成内存泄漏：<br>会让<strong>变量一直处于进入环境的状态</strong>，而无法被回收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg)&#123;</span><br><span class="line">    bar = &quot;this&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创造了一个全局变量，在页面关闭之前是不会释放的。<br>被遗忘的计时器或者回调函数 闭包可以维持内部函数的局部变量，使其得不到释放。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/web前端入门和进阶js笔记-node-js笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/29/web前端入门和进阶js笔记-node-js笔记/" itemprop="url">web前端入门和进阶js笔记-node js笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-29T09:29:13+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/node相关/" itemprop="url" rel="index">
                    <span itemprop="name">node相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>异步编程<br>node 采用google v8引擎来处理js脚本，js最大特点就是单线程运行，一次只能运行一个任务<br>node 大量采用异步操作，即任务不是马上执行，<strong>而是插在任务队列的尾部，等到前面的任务执行完再去执行</strong>.<br>提高代码的响应能力。<br>异步IO也叫非阻塞IO，例如读文件，传统的语言，基本都是读取完毕才能进行下一步操作。非阻塞就是Node的callback，不会影响下一步操作，等到文件读取完毕，回调函数自动被执行，而不是在等待。<br>所以只有把错误交给<strong>回调函数</strong>来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(&quot;找小黑&quot;,function(error,data)&#123;</span><br><span class="line">    if(error)</span><br><span class="line">    throw error;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>异步线程不容易维护，阅读，调试，可以通过es5的promise机制和es6最新提出的async/await机制来实现<br>进程：每一个<strong>正在运行</strong>的应用程序被称为进程。进程是<strong>操作系统为应用程序分配资源的一个单位</strong><br>线程：用来执行应用程序中的代码，一个进程内部，可以分为<strong>多线程</strong><br>在一个线程内部，同时只可以干一件事<br>传统的开发方式大部分都是 I/O 阻塞的，所以需要多线程来更好的利用硬件资源。<br>多线程弊端：<br>创建线程耗费，线程数量有限，cpu需要在不同线程之间切换。</p>
<p>事件驱动和非阻塞机制：<br>node中将所有的阻塞操作都交给了内部线程池来实现。<br>node主线程本身。主要是不断的往返调用。<br>node js基本上所有的事件机制都是利用设计模式中的<strong>观察者模式</strong>来实现。<br>node js单线程类似于进入一个while(true)循环，直到没有事件观察者退出，每个异步事件生成一个事件观察者，如果有事件发生就调用回调函数。<br>node js使用事件驱动模型，当web-server接收到后，就把他关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。<br>node采用事件驱动的运行模型，通过事件驱动的方式处理请求时无需为每一个请求额外创建线程。在事件驱动的模型当中，每一个IO工作被添加到事件队列中，线程循环的来处理队列上的工作任务，当执行过程中遇到阻塞，线程不会阻塞下来，而是会返回一个回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务结束后才会被执行。<br>nginx是<strong>多进程单线程</strong><br><strong>每个Tick周期中会从事件队列查看是否有事件需要处理，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于堵塞IO的处理在幕后使用线程池来确保工作的执行。Node从池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止堵塞IO占用空闲资源。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。</strong><br>node内部采用google v8引擎，作为js引擎解释器<br><strong>通过自行开发的libuv库，调用操作系统资源</strong><br>总结<br><strong>node js</strong>是一个js的运行环境(平台)，不是一门语言，也不是一个框架。<br>node js环境即REPL环境<br>REPL:ead,eval,print,loop类似于浏览器的控制台<br><strong>接收用户输入，执行用户输入，打印执行结果到控制台，循环下一次</strong></p>
<h2 id="程序模块化："><a href="#程序模块化：" class="headerlink" title="程序模块化："></a>程序模块化：</h2><p>js文件越来越多，会遇到一些问题：文件污染，全局污染，命名冲突<br>程序模块化：<br>日期模块，数学计算模块，日志模块<br>模块化：将一个复杂的程序依据一定的规则(规范)封装成几个文件，并且组合在一起。<br>模块的内部数据：实现是私有的，只是向外部暴露一些接口。<br>模块化的好处<br>避免命名冲突，减少命名空间污染<br>降低耦合性；更好地分离、按需加载<br>高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。<br>高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。<br>部署方便<br>模块化规范：<br>模块化起源于node js,node js中把很多js打包成package,需要的时候直接(require) common.js要求 导入进来，这就是模块化的方式。<br>服务端模块化：commonjs是node js使用的模块化规范，约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。<br>浏览器端规范：amd规范:是requrejs在推广过程中对模块化定义的规范化产出。异步加载模块<br>同步加载模块：cmd是seajs在推广过程中对模块化定义的规范化产出。淘宝团队开发。<br>暴露模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">exports.xxx = value;</span><br><span class="line">引入requre(xxx);</span><br></pre></td></tr></table></figure></p>
<p>自定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    name:&quot;我是module1&quot;,</span><br><span class="line">    foo()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let module1 = require(&quot;./modules/module1&quot;);</span><br><span class="line">module1.foo();</span><br></pre></td></tr></table></figure></p>
<p>AMD:异步模块定义：AMD专门用于浏览器端，模块的加载是<strong>异步</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function() &#123;</span><br><span class="line">    return 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;module1&apos;,&apos;module2&apos;],function(m1,m2)&#123;</span><br><span class="line">    //使用</span><br><span class="line">    m1 / m2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>CMD同步模块加载，CMD专门用于浏览器端，模块的加载是<strong>同步</strong>的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">//引入依赖的模块(同步的方式)</span><br><span class="line">    var module2 = require(&apos;./module2&apos;)</span><br><span class="line"></span><br><span class="line">    //引入依赖的模块(异步的方式)</span><br><span class="line">    require.async(&apos;./module3&apos;, function (m3) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>es6模块化的说明<br>依赖模块需要编译打包处理<br>1.有些浏览器不支持es6的语法，写完es6的代码后，需要babel将es6转化为es5<br>export<br>引入模块 import xxx from ‘路径’<br>默认暴露的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default() =&gt; &#123;</span><br><span class="line">    console.log(&quot;我暴露了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>es6语法概览：<br>块级作用域，字符串，对象扩展，解构，类，模块化。<br>let定义变量，代替var</p>
<h2 id="http状态"><a href="#http状态" class="headerlink" title="http状态"></a>http状态</h2><p>http协议是无状态的，服务器只会响应来自客户端的请求，但是他与客户端之间不具备持续连接。<br>服务端发送事件后，无法推送到客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。<br>知道服务器的状态：<br>轮询：客户端每隔很短的时间，都会向服务器发出请求，，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。<br>长连接：客户端只请求一次，但是服务器会保存这次连接，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。<br>websocket协议：允许客户端与服务器端以<strong>全双工</strong>的形式进行通信。<br>WebSocket 的原理非常简单：利用HTTP产生请求握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者之间使用TCP进行交流（QQ的协议）。<br>HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<p>websocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。</p>
<p>keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。<br>es6中新语法<br>如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：<br>arr1是一个数组，arr2不需要指向arr1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = [...arr1];</span><br></pre></td></tr></table></figure></p>
<p>angularJS提供更多的是一套解决方案，更像是一个生态<br>vue和react目前都使用了virtual dom<br>vue和react的相同点<br>利用虚拟DOM实现快速渲染<br>轻量级<br>响应式组件<br>支持服务端渲染<br>易于集成路由工具，打包工具以及状态管理工具<br>虚拟dom:可以在js内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据完整解析，一次性插入到DOM里面去，这就形成了虚拟DOM。</p>
<h2 id="promise机制"><a href="#promise机制" class="headerlink" title="promise机制"></a>promise机制</h2><p>promise:简单来说就是一个容器，里面保存着某个未来才会结束的事件的结果，从语法上说，promise是一个对象，从他可以获取异步操作的结果，promise提供一个统一的api,各种异步操作都可以用同样的方法处理，让开发者不用再关心时序和底层的结果，promise的状态具有<strong>不受外界影响和不可逆</strong>的特点。传统回调存在bug:调用回调次数过少或过多。对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用。<br>对于一个proise对象来说，对象的注册和每一个观察回调都是相对独立的，互不干预的，而promise对象调用reslove和reject,每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用。<br>css中的BFC概念。</p>
<h2 id="BFC概念"><a href="#BFC概念" class="headerlink" title="BFC概念"></a>BFC概念</h2><p>文档流，常说的文档流其实分为<strong>定位流，浮动流，普通流</strong>,3种，而普通流就是指BFC中的FC(fomatting context),直译过来就是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用，常见的FC有BFC,IFC,还有GFC和FFC。<br>BFC，块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释就是：BFC是web页面css视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响的一个区域。<br>一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在2个BFC中，因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。<br>常规流：盒一个接着一个排列。<br>浮动：floats，左浮动元素尽量靠左，靠上，右浮动。<br>绝对定位：盒从常规流中被移除，不影响常规流的布局。<br>根元素，即HTML标签<br>浮动元素：float值为 left、 right<br>overflow值不为 visible，为 auto、 scroll、 hidden<br>display值为 inline-block、 table-cell、 table-caption、 table、 inline-table、 flex、 inline-flex、 grid、 inline-grid<br>定位元素：position值为 absolute、 fixed</p>
<ol start="5">
<li>作用<br>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。<br>5.1阻止元素被浮动覆盖。5.2可以包含浮动元素，通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。<br>5.3阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>5.4阻止相邻元素的margin合并</li>
</ol>
<p>node js是一个基于google v8引擎的js运行环境，所以v8就是node js中使用的虚拟机环境，在之后讲解的 Node.js 中的 GC 其实就是在讲 V8 的 GC。<br>node js与v8的关系好比java与JVM之间的关系，另外 Node.js 之父 Ryan Dahl 在选择 V8 做为 Node.js 的虚拟机时 V8 的性能在当时已经领先了其它所有的 JavaScript 虚拟机，至今仍然是性能最好的，因此我们在做 Node.js 优化时，只要版本升级性能也会伴随着被提升<br>提供了process.memortUsage方法来查看当前进程的使用情况。<br>垃圾回收是指回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象<strong>就会作为垃圾回收的候选对象</strong>,这里的根对象为全局对象，局部变量，无法从根节点访问指的是不会再被任何其他活动对象所引用。<br><img src="/uploads/v8.jpg" width="50%" height="50%"><br>v8中分为新生代和老生代空间，新生代空间中存储频繁的数目，随后将长期驻存的移到老生代空间中。<br>IE盒子模型包含border和padding<br>box-sizing:content-box;标准盒模型<br>box-sizing:border-box;IE盒模型<br>获取样式高度 宽度<br>window.getComputedStyle(element).width/height;<br>BFC:块级格式化上下文<br>BFC渲染原理：BFC内部的子元素，在垂直方向，边距会发生重叠。<br>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然<br>BFC区域不会与旁边的float box区域重叠。<br>计算BFC的高度时，浮动的元素也参与计算<br>DOM事件的级别：<br>准确来说，是DOM标准定义的级别：<br>dom0级别的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dom2级别的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&quot;click&quot;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure></p>
<p>true表示捕获阶段触发,false<br>dom3级别的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&quot;keyup&quot;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>DOM3中，增加了很多事件类型，比如鼠标事件，键盘事件等。<br>为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。<br>window -&gt; document -&gt; html -&gt; body -&gt; 目标元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myEvent = new Event(&quot;clickTest&quot;);</span><br><span class="line">element.addEventListener(&quot;clickTest&quot;,function() &#123;</span><br><span class="line">     console.log(&apos;smyhvae&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">element.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure></p>
<p>http协议：<br>客户端和服务器端是两种身份，第一次请求结束后，就断开了，第二次请求时，<strong>服务器没有记住之前的状态</strong>,<br>HTTP报文的组成：<br>请求报文：请求行，请求头，空行，请求体<br>响应报文：状态行，响应头，空行，响应体<br>请求行：post方法，请求的url,http协议以及版本<br>请求头：一大堆键值对<br>请求体：数据部分<br>响应报文：<br>状态行：http协议以及版本，状态码以及描述<br>响应头：http/1.1 200 OK<br>响应体：返回的数据<br>http状态码：1xx 指示信息-表示请求已经接受 基础处理<br>2xx 成功 表示请求已被成功接受<br>3xx 重定向 要完成请求必须进一步操作<br>4xx 客户端错误<br>5xx 服务器错误<br>instanceof的作用：用于判断<strong>实例</strong>属于哪个构造函数<br>原理：判断实例对象的<strong>proto</strong>属性，和构造函数的prototype属性，是否是同一个引用(即是否是同一个地址)<br>foo instanceof Object的结果也是true,<br>new 运算符发生了什么<br>1.创建了一个<strong>新的空对象实例</strong><br>2.将此空对象的隐式原型指向其构造函数的显示原型<br>3.执行构造函数，同时 this 指向这个新实例。<br>4.如果返回值是一个新对象，就返回该对象，如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.name = &quot;sym&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用class声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ajax：不支持跨域<br>websocket:不受同源策略的限制，支持跨域<br>cors:不受同源策略的限制，支持跨域。同时支持同源和跨域的Ajax。<br>jsonp实现原理：通过script标签的异步加载来实现，比如说，实际开发中，head标签里，可以通过script标签的src,里面来放url,加载很多在线的插件，这里就是通道了jsonp</p>
<h2 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h2><p>在没有网站登出的情况下去访问非法网站，非法网站就要求A去访问新的网站，并且携带者A的cookie -&gt; CSRF<br>跨域脚本攻击：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本，可能是js,html代码块，最后导致结果：盗用cookie,破坏页面解构，插入广告等。d-doss攻击。 -&gt; xss<br>随表单一起提交给服务器，服务器随后解析，xss代码随响应体一起传回，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。<br>存储型：提交的代码会存储在服务器端，下次请求目标页面时就不用再提交XSS代码了。</p>
<h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><p>DTD(文档类型定义)：<br>是一系列的语法规则，用来定义XML或者(x)HTML文件类型，浏览器使用<strong>DTD判断文档类型</strong>.决定使用哪种协议来解析，以及切换浏览器模式。告诉浏览器，我是什么文档类型，你要用什么协议来解析我。<br>&lt;!DOCTYPE html&gt;<br>DOM tree和CSS Rule Tree合并成Render Tree,（虽然有了Render Tree，但并不知道节点的位置，需要依靠接下来的layout）<br>有了render Tree,浏览器已经知道网页中有哪些节点，各个节点的css定义以及他们的从属关系，<strong>从而去计算每个节点在屏幕上的位置(宽高，颜色等)</strong>.<br>painting:按照计算出来的规则，通过显卡，把内容绘制到屏幕上。<br>display:打击看到最终的效果。<br>reflow:重排，dom节点中的各个元素都有自己的盒子，这些都需要浏览器<strong>根据各种样式来进行计算，并根据计算结果将元素放在他该出现的位置</strong>，这个过程称为reflow.<br>触发reflow:增加，删除，修改dom节点。 导致reflow和repaint<br>移动dom位置。修改css样式，宽高，display为none时。<br>repaint:重绘制，当各种盒子的位置，大小以及其余属性，例如颜色，字体大小都确定后，浏览器便会把这些元素按照各自的特性绘制一遍，于是页面的内容也就出来了。<br><strong>页面呈现的内容，绘制在屏幕上，叫做重绘</strong><br><strong>页面元素的位置，叫做重排</strong><br>js是单线程(同一时间只能做意见事情),而且只有一个任务队列，全部的同步任务执行完毕后，才会去执行异步任务，<br>遇到异步任务，setTimeout等，先挂起。全部的同步任务执行完毕后，再来执行异步任务。<br>什么时候需要等待，就什么时候需要用异步。<br>定时任务：setTimeout,网络请求,ajax,动态img增加。<br>事件绑定。比如所，按钮绑定点击事件，用户爱点不点，我们不可能一直卡在那里，，什么都不做。所以，应该用异步）<br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>总结：只要主线程空了，就去读取“任务队列”。<br>提升页面性能方法<br>1.资源压缩合并，减少http请求。<br>2.非核心代码异步加载，<br>document.createElement() defer加载，async加载<br>defer:在html解析完之后才会执行，如果是多个，则按照加载顺序依次执行。<br>async:在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。<br>3.利用浏览器缓存，和存储不是一件事<br>缓存 资源文件<br>强缓存：不用请求服务器，直接使用本地缓存<br>强缓存是利用HTTP响应头中的express或cache-control实现<br>Cache-Control的优先级高于Expires。<br>4.使用CDN<br>5.DNS预解析<br>前端错误监控：<br>1.前端错误的分类 2.每种错误的捕获方式 3.上报错误的基本原理<br>try…catch window.onerror函数 这个函数是全局的<br><strong>手机端的web开发，怎么和原生做交互？</strong><br><strong>调用原理需清楚,怎么调用原生的插件的</strong></p>
<h2 id="let-var-function"><a href="#let-var-function" class="headerlink" title="let var function"></a>let var function</h2><p>let的<strong>创建</strong>过程被提升了，但是初始化没有被提升<br>var的<strong>创建</strong>和<strong>初始化</strong>都被提升了<br>function的<strong>创建</strong>和<strong>初始化</strong>和<strong>赋值</strong>都被提升了<br>声明时的重名问题：<br>假设a被声明为变量，紧接着又被声明为函数，原则是：：<strong>声明会被覆盖（先来后到，就近原则）。</strong><br>如果a已经有值，再用var声明是无效的<br>如果a已经有值，紧接着又被赋值，则<strong>赋值会被覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn;</span><br><span class="line">function fn() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(fn); //打印函数fn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var fn;//再用var 无效</span><br><span class="line">console.log(fn);//打印结果 函数fn</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;&#125;  //fn被声明为function，且此时fn已经有值，这个值就是function的对象</span><br><span class="line"></span><br><span class="line">    function fn() &#123;   //此时fn被重复赋值，会覆盖上一行的值</span><br><span class="line">        console.log(&apos;smyhvae&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(fn)</span><br></pre></td></tr></table></figure>
<p>下面的fn声明会覆盖上面的<br>使用var关键字声明的变量，是在函数作用域中有效，而且会在函数中所有的代码之前被<strong>声明</strong>.<br>函数声明也会在函数中所有的代码执行之前执行。<br>在函数中，没有var声明的变量会成为<strong>全局变量</strong>,而且不会提前声明。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/web前端入门和进阶js笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/web前端入门和进阶js笔记/" itemprop="url">web前端入门和进阶js笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T17:44:09+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js和esmscript的关系"><a href="#js和esmscript的关系" class="headerlink" title="js和esmscript的关系"></a>js和esmscript的关系</h2><p>js和ecmscrpit的关系<br>ecmscript是一种有ecma国际制定和发布的脚本语言规范<br>ecmscript不是一门语言，而是一种标准<br>js包括ecmpscript(语言核心功能基于ES规范)<br>DOM js需要支持对DOM的维护，通过document element<br>BOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的<br>提一下nodejs.nodejs是基于chrome V8引擎。上文提到V8引擎是用来解析执行JS，并且V8是基于ECMAscirpt标准实现的.换个角度说,nodejs里头没有DOM和BOM的操作,只保留的javascript的语法核心(ES),并且增加了事件驱动的非阻塞I/O模型，使其轻量级和高效。nodejs作为服务运行在linux,mac,window,把javascipt的角色从前台开发,转移到了后台开发。<br><a href="https://www.jianshu.com/p/10cfcb536d4a" target="_blank" rel="noopener">js与ecmscript的关系</a><br>js是<strong>弱变量</strong>类型的语言，变量声明用var来实现。而java中必须带类型<br>var a;</p>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><p><img src="/nowcoder/webjs.jpg" width="50%" height="50%"><br>1、User Interface 用户界面，我们所看到的浏览器</p>
<p>2、Browser engine 浏览器引擎，用来查询和操作渲染引擎</p>
<p>3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS</p>
<p>4、Networking 网络，负责发送网络请求</p>
<p>5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码</p>
<p>6、UI Backend UI后端，用来绘制类似组合框和弹出窗口</p>
<p>7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage</p>
<p>js分为3部分组成<br>ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。<br>DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。<br>BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。<br>PS：JS机械重复性的劳动几乎为0，基本都是创造性的劳动。而不像HTML、CSS中margin、padding都是机械重复劳动。<br>js是解释型语言，事先不需要被编译成机器码再执行，逐行执行，无需进行严格的变量声明。<br>解释型语言：边解析边执行，不需要事先编译。例如：JavaScript、php。</p>
<p>编译型语言：事先把所有的代码翻译成计算机能够执行的指令，然后整体执行。例如：c、c++。<br>分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。<br>用户输入<br>prompt()就是专门用来弹出能够让用户输入的对话框，用得少，测试的时候会用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = prompt(&quot;请随便输入点东西&quot;); //不管是什么语句 输入都是字符串</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="基本对象和引用对象"><a href="#基本对象和引用对象" class="headerlink" title="基本对象和引用对象"></a>基本对象和引用对象</h2><p>基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。<br>引用数据类型（引用类型）：Object 对象。<br>注意：内置对象function、Array、Date、RegExp、Error等都是属于Object类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。<br>面试问：引用数据类型有几种？<br>面试题：只有一种，即object类型。<br>基本数据类型：参数赋值的时候，传数值<br>引用数据类型：参数赋值的时候，传地址<br>（2）引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。但是单引号里可以嵌套双引号。<br>\” \’ \n换行<br>无穷大 Infinity 无穷小 -Infinity<br>注意：typeof Infinity的返回结果是number。<br>NaN:是一个特殊的数字，表示Not a Number<br>typeof NaN返回的是number<br>null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。<br>其他数据类型 -&gt; Number<br>字符串 -&gt; 数字<br>1.字符串是纯数字 则将其转化为数字<br>2.字符串有非数字的内容，则转化为NaN,<br>3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0。<br>null -&gt; 数字 0 undefined -&gt; 数字 NaN<br>parseInt的作用，将字符串中有效的整数内容转化为数字<br>console.log(parseInt(“2017.01在公众号上写了6篇文章”));  //打印结果仍是：2017   （说明只会取整数）<br>只能取开头的，中间的不能截取<br>对非String使用parseInt()或者parseFloat() 先转换成string再操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = true;</span><br><span class="line">console.log(parseInt(a));</span><br></pre></td></tr></table></figure></p>
<p>转化为字符串”true”,然后再操作，打印出来NaN<br>转化为Boolean<br>数字 -&gt; 布尔 除了0和NaN 其余都转化为true<br>字符串 -&gt; 布尔 除了空串 其余都是true<br>null和undefined 转化为false<br>对象转化为true<br>布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，<strong>但返回结果是原值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = 5 &amp;&amp; 6;</span><br><span class="line">console.log(&apos;result&apos; + result);</span><br></pre></td></tr></table></figure></p>
<p>与运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则必然返回第二个值（所以说，如果所有的值都为true，则返回的是最后一个值）</p>
<p>如果第一个值为false，则直接返回第一个值</p>
<p>或运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则直接返回第一个值</p>
<p>如果第一个值为false，则返回第二个值<br>== 这个符号并不严谨，会将不同类型的东西，转为相同类型进行比较（大部分情况下，都是转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> console.log(&quot;6&quot; == 6);		// 打印结果：true。这里的字符串&quot;6&quot;会先转换为数字6，然后再进行比较</span><br><span class="line">console.log(true == &quot;1&quot;);   // 打印结果：true</span><br><span class="line">console.log(0 == -0);       // 打印结果：true</span><br><span class="line"></span><br><span class="line">console.log(null == 0);   // 打印结果：true</span><br><span class="line">   console.log(undefined == null) //打印true</span><br><span class="line">   console.log(NaN == NaN) //false</span><br></pre></td></tr></table></figure></p>
<p>如果要保证完全等于，我们就要用三个等号===。全等不会做类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;6&quot; === 6);		//false</span><br><span class="line">console.log(6 === 6);</span><br></pre></td></tr></table></figure></p>
<h2 id="js中的代码块"><a href="#js中的代码块" class="headerlink" title="js中的代码块"></a>js中的代码块</h2><p>js中的代码块，只具有分组的作用，没有其他用途<br>代码块中的内容，在外部是完全可见的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	var a = 2;</span><br><span class="line">&#125;	</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<p>switch语句，条件分支语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case 1:</span><br><span class="line">	break;</span><br><span class="line">	case 2:</span><br><span class="line">	break;</span><br><span class="line">	default:</span><br><span class="line">	breeak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>break语句一般建议不要省略，否则会出现<strong>case穿透现象</strong><br>continue用来跳过当次循环<br>基本数据类型是直接保存在<strong>栈内存</strong>中，值与值之间是独立存在的，修改一个变量不会影响其他变量。<br>对象：只要不是那5种基本数据类型，就全都是对象。<br>如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。<br>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。<br>对象是保存到<strong>堆内存</strong>中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，变量保存的是对象的内存地址(对象的引用)<br>换言之，对象的值是保存在堆内存里的，但是对象的引用是保存在栈内存中的<br>对象的分类：内置对象，由ES标准定义的对象，在任何的ES的实现中都可以使用<br>比如Math,String,Number,Boolean,Function,Object<br>宿主对象：由js运行环境提供的对象，就是主要由浏览器提供的对象<br>比如DOM,BOM,console document等<br>自定义对象 由开发人员自己创建的<br>in运算符，通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true,没有返回false<br>“属性名” in 对象<br>console.log(“name” in obj);<br>js中 所有的<strong>变量</strong>都是保存在栈中的。<br>基本数据类型:基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。<br>引用数据类型:对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟一块新的空间，<strong>而变量保存了对象的地址</strong>,对象的引用，如果两个变量保存了同一个对象的引用，当一个通过变量去修改属性时，另一个也会修改。<br>函数的介绍：将一些功能语句进行封装 函数也是一个对象 使用typeof检查一个函数对象时，返回<strong>function</strong><br>函数表达式:<strong>将匿名函数赋值给一个变量</strong><br>fn()与fn的区别<br>fn()调用函数，相当于获取了函数的返回值<br>fn:函数对象，相当于直接获取了函数对象<br>在js中，只有2种作用域：全局作用域和函数作用域<br>直接编写在script标签中的JS代码，都在全局作用域。</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁。</p>
<p>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。</p>
<p>在全局作用域中：</p>
<p>创建的变量都会作为window对象的属性保存。</p>
<p>创建的函数都会作为window对象的方法保存。</p>
<p>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到<br>变量的声明提前(变量提升)<br>使用var关键字声明的变量var = 1 <strong>会在所有代码执行之前声明(但不赋值)</strong><br>但是如果声明时不用var 比如a = 1 则变量不会被声明提前<br>函数声明：下面就为函数声明的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">	console.log(&quot;我是函数fn1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以函数的声明会提前，也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。<br>fn1()后再声明函数<br>函数表达式不会提前<br>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。<br>当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁。参考链接：<br>this:解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数便是this,this指向的是一个对象，这个对象我们称之为函数的执行<strong>上下文对象</strong>,<br>以函数形式调用,this指向window,比如func()<br>以方法形式调用，this是调用方法的那个对象<br>以构造函数形式调用，this是新创建的那个对象<br>使用call和apply调用，this指定的是那个对象</p>
<h2 id="箭头函数中this的指向"><a href="#箭头函数中this的指向" class="headerlink" title="箭头函数中this的指向"></a>箭头函数中this的指向</h2><p>es6的箭头函数中并不会使用上面4条标准的绑定规则，而是会继承外层函数调用的this绑定(无论this绑定到什么)<br>在调用函数式，浏览器每次都会传递2个隐含参数,this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	console.log(typeof arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。<br>arguments代表的是<strong>实参</strong>,我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments只在函数中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">	console.log(fn.length);//获取形参个数</span><br><span class="line">	console.log(arguments.length);//获取实参个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、arguments可以修改元素<br>之所以说arguments是伪数组，是因为：arguments可以修改元素，但不能改变数组的长短。举例：<br>new 一个构造函数的执行流程<br>(1)开辟内存空间，存储新创建的对象<br>(2)将新建的对象设置为构造函数中的this,在构造函数中可以使用this来引用新对象。<br>(3)执行函数中的代码，(包括设置对象属性和方法等)。<br>(4)将新建的对象作为返回值返回<br><strong>所有的对象都是Object的后代</strong>，因此，任何对象instanceof Object返回的结果都是true.<br>JSON:json的属性必须用双引号来括起来，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            &quot;name&quot; : &quot;zs&quot;,</span><br><span class="line">            &quot;age&quot; : 18,</span><br><span class="line">            &quot;sex&quot; : true,</span><br><span class="line">            &quot;sayHi&quot; : function() &#123;</span><br><span class="line">                console.log(this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>json的遍历与对象的遍历一样，用for…in…来进行遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myJson = &#123;</span><br><span class="line">       &quot;name&quot;: &quot;smyhvae&quot;,</span><br><span class="line">       &quot;aaa&quot;: 111,</span><br><span class="line">       &quot;bbb&quot;: 222</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   //json遍历的方法：for...in...</span><br><span class="line">   for (var key in myJson) &#123;</span><br><span class="line">       console.log(key);   //获取 键</span><br><span class="line">       console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）</span><br><span class="line">       console.log(&quot;------&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><p>原型prototype的概念：<br>认识1：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象，<br>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">	var per1 = new Person();</span><br><span class="line">	var per2 = new Person();</span><br><span class="line">console.log(Person.prototype); //打印结果[object object]</span><br><span class="line">console.log(per1.__proto__ == Person.prototype); //相等</span><br></pre></td></tr></table></figure></p>
<p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。<br>使用in来检查，如果对象中没有但是原型中有，也会返回true.<br>可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。</p>
<h2 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h2><p>当一个对象没有任何的变量或者属性对他进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。<br>在堆内存中：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。<br>js中有自动的垃圾回收机制，会自动回收这些垃圾。如果你不再使用这些对象，将其置为null即可。<br>数组Array是属于内置对象。<br>数组和普通对象的功能类似，也是用来存储一些值的。不同的是：<br>普通对象是使用字符串来作为属性名的，而数组是使用数字来作为索引来操作元素。<br>数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(&quot;参数&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>如果修改的length大于原长度，则多出来部分会空出来，置为null.<br>如果修改的length小于原长度，则多出来部分会被删除，数组将从后面删除元素。<br>数组的基本方法<br>unshift(),在数组最前面插入一个或多个元素，返回结果为数组新的长度。<br>shift(),删除数组的第一个元素，返回结果为被删除的元素<br>forEach()没有返回值，也就是说，返回值是undefined.<br>filter()返回结果是true的项，将组成新的数组，可以起到过滤的作用。<br>map()对原数组中的每一项进行加工<br>every()如果有一项返回false,则停止遍历<br>some()只要有一项返回true,则停止遍历<br>注意：这几个方法不会修改原数组。都会组成新的数组等。<br>forEach循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;网一&quot;,&quot;网二&quot;];</span><br><span class="line">arr.forEach(function(item,index,obj)&#123;</span><br><span class="line">	console.log(item);</span><br><span class="line">	console.log(index);</span><br><span class="line">	console.log(obj);</span><br><span class="line">&#125;)</span><br><span class="line">//表示当前正在遍历的元素，正在遍历元素的索引，和正在遍历的数组</span><br><span class="line">//filter函数</span><br><span class="line">var arr1 = [1,2,3,4,5,6];</span><br><span class="line">var arr2 = arr1.filter(function(item,index)&#123;</span><br><span class="line">	if(item &gt; 2)</span><br><span class="line">	return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;)</span><br><span class="line">//map方法 解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。</span><br><span class="line"></span><br><span class="line">  var arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">    var arr2 = arr1.map(function (item, index) &#123;</span><br><span class="line">        return item + 10;  //让arr1中的每个元素加10</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(arr2);</span><br><span class="line">	//every方法 只有全部返回true,才返回true</span><br><span class="line">	 var arr1 = [&quot;千古&quot;, &quot;宿敌&quot;, &quot;南山忆&quot;, &quot;素颜&quot;];</span><br><span class="line">    var bool1 = arr1.every(function (element, index, array) &#123;</span><br><span class="line">        if (element.length &gt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(bool1);  //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false</span><br><span class="line"></span><br><span class="line">some()方法</span><br><span class="line">解释：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。</span><br><span class="line">如果都返回false,则返回值是false。如果有一项返回true,则停止遍历，返回true.</span><br></pre></td></tr></table></figure></p>
<p>数组的常用方法<br>slice 从数组中提取指定的一个或多个元素，返回新的数组，不会改变原数组<br>splice从数组中删除指定的一个或多个元素，返回新的数组，会改变原数组<br>concat连接两个或多个数组，返回新的数组，不会改变原数组<br>jon将数组转化为字符串，返回转换后的字符串，不会改变原数组<br>reverse反转数组，返回翻转后的数组，会改变原数组<br>sort,对数组元素，按unicode编码，从小到大排序，会改变原数组。<br>slice<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result1 = arr.slice(2);//从第二个位置开始提取</span><br><span class="line">var result2 = arr.slice(-2);//提取最后2个元素</span><br><span class="line">var result3 = arr.slice(2,4);//提取从第二个到第四个 不包含4</span><br></pre></td></tr></table></figure></p>
<h2 id="将伪数组转化为真数组"><a href="#将伪数组转化为真数组" class="headerlink" title="将伪数组转化为真数组"></a>将伪数组转化为真数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = Array.from(arrayLike);</span><br></pre></td></tr></table></figure>
<p>splice 删除一个或多个元素，返回新的数组，会改变原数组<br>新数组 = 原数组.splice(起始索引index,需要删除的个数,第三个参数，第四个参数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];</span><br><span class="line">   var result1 = arr1.splice(1);</span><br><span class="line">   console.log(arr1); //第1个删除后返回arr1</span><br><span class="line">   console.log(result1); //原数组的第一个删除了 给result</span><br></pre></td></tr></table></figure></p>
<p>从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr4 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素</span><br><span class="line">var result4 = arr4.splice(1, 3, &quot;千古壹号&quot;, &quot;vae&quot;);</span><br></pre></td></tr></table></figure></p>
<p>concat连接 arr1.concat(arr2);将arr2中的元素追加到arr1的尾部<br>join方法指定一个字符串作为参数，这个字符串将会成为数组元素连接的连接符，如果不指定连接符，则默认使用’,’作为连接符，此时和 toString()的效果是一致的。<br>reverse反转字符串<br>sort函数中的自定义方法，<br><strong>如果返回一个大于0的值，则元素会交换位置，</strong><br><strong>如果返回一个小于0的值，则元素位置不变</strong><br>如果返回0，则认为2个元素相等，则不交换位置。<br>var result = arr3.sort(function(a,b){<br>    if(a &gt; b){<br>        return a - b; //升序排列<br>        return b - a;//降序排列<br>        return 1;//如果a &gt; b则交换a和b的位置，就是进行升序排列<br>    }else if(a &lt; b){<br>        return -1; //元素位置保持不变<br>    }else<br>return 0;<br>})<br>indexOf,lastIndexOf获取数据的索引<br>从后往前索引，获取 value 在数组中的最后一个下标    从后往前，找到最后一次出现的，也就是排在最后的出现的那位。<br>find(function (item, index){</p>
<p>})<br>Array.from将伪数组转化为真数组<br>伪数组的原型链中没有Array.prototype,而真数组的原型链中有Array.prototype<br>Array.of(1,’abc’,true);//将一系列值转化成数组<br>isArray 判断是否是数组<br>valueOf,返回数组本身 数组本身 = 数组.valueOf();<br>内置对象简介：内置对象就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用的或是最基本而必要的功能。<br>内置对象    对象说明<br>Arguments 函数参数组合<br>Array    数组<br>Boolean    布尔对象<br>Date    日期时间<br>Error    异常对象<br>Function    函数构造器<br>Math    数学对象<br>Number    数值对象<br>Object    基础对象<br>RegExp    正则表达式对象<br>String    字符串对象<br>Date对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure></p>
<p>传递一个表示时间的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date2 = new Date(&quot;2017/09/06 09:00:00&quot;);</span><br><span class="line">console.log(date2);</span><br></pre></td></tr></table></figure></p>
<h2 id="Date和Math方法"><a href="#Date和Math方法" class="headerlink" title="Date和Math方法"></a>Date和Math方法</h2><p>获取日期和时间<br>getDate() //获取日子 1-31<br>getDay() //获取星期0-6 0代表周末 1代表周一<br>getMonth() //获取月份0-11 0代表1月<br>getTime() //获取时间戳<br>时间戳指的是从格林威治标准时间的1970.1.1号0时0分0秒到现在日期所花费的毫秒数(1s = 1000 ms)<br>内置对象Math的常见方法<br>Math.abs()返回绝对值<br>Math.floor()向下取整(向小取)<br>Math.ceil()向上取整(向大取)<br>Math.round()四舍五入(正数四舍五入,负数五舍六入)<br>Math.random()生成0-1之间的随机数<br>Math.max(x,y,z)返回多个数中的最大值<br>Math.min(x,y,z)返回多个数中的最小值<br>生成0-x之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * x);</span><br></pre></td></tr></table></figure></p>
<p>生成x-y之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * (y - x) + x);</span><br></pre></td></tr></table></figure></p>
<h2 id="url编码和解码"><a href="#url编码和解码" class="headerlink" title="url编码和解码"></a>url编码和解码</h2><p>URI 通用资源标识符，进行编码，以便发送给浏览器，有效的URI编码不能包含某些字符，例如空格，而这URI编码方法就可以对URL进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent();   //把字符串作为 URI 组件进行编码</span><br></pre></td></tr></table></figure></p>
<p>包装类的介绍：<br>js中的数据类型包括以下几种，<br>基本数据类型：string,number,boolean,null,undefined<br>引用数据类型：object<br><strong>js为我们提供了3个包装类</strong><br>String(),将基本数据类型字符串，转化为String对象<br>Number(),将基本数据类型数字，转化为Number对象。<br>Boolean()：将基本数据类型的布尔值，转换为Boolean对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(3);</span><br><span class="line">var str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。<br>方法和属性只能添加给对象，不能添加给基本数据类型。<br>slice方法 从字符串中截取指定的内容，不会修改原字符串 而是将截取到的内容返回<br>(2,5)截取时，包左不包右<br>字符串 = str.slice(开始索引,结束索引);<br>(2)表示<strong>从指定的索引位置开始，截取到最后</strong><br>(-3)表示从倒数第几个开始，截取到最后<br>(1,-1)表示从第一个截取到倒数第一个<br>(5,2)表示前面的大，后面的小，返回值为空<br>substring,不能接受负值作为参数，如果传递了一个负值，默认使用0<br>substring还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。<br>substr从字符串中截取指定的内容，不会修改原来的字符串，而是将及截取到的内容返回。<br>  字符串 = str.substr(开始索引, 截取的长度);<br>  开始所以，截取的长度<br>  用逗号来隔开字符串，split<br>  trim去除字符串前后的空白。replace替换所有的<br>  toLowerCase()转换成小写<br>  定义：正则表达式用于定义一些字符串的规则。</p>
<p>作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);</span><br><span class="line">console.log(reg.test(str1));</span><br></pre></td></tr></table></figure></p>
<p>来进行测试，检查是否符合。</p>
<h2 id="let-var-function，eval的区别"><a href="#let-var-function，eval的区别" class="headerlink" title="let var function，eval的区别"></a>let var function，eval的区别</h2><p>let变量不存在变量提升问题，在我们声明(初始化)他们之前，他们是不可访问的。这被称为<strong>暂时死区</strong><br>let 的「创建」过程被提升了，但是初始化没有提升。<br>var 的「创建」和「初始化」都被提升了。<br>function 的「创建」「初始化」和「赋值」都被提升了。<br>eval会为字符串传递的代码求值，如果它是一个表达式，就像如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sum = eval(&quot;10 * 10 + 5&quot;);</span><br></pre></td></tr></table></figure></p>
<p>sum为105 先计算出来 再赋值<br>所有对象键：(不包括Symbol)都会被存储为字符串形式，即使你没有给定字符串类型的键。<br>默认情况下：事件处理程序在冒泡阶段执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof a);//返回function</span><br><span class="line">console.log*typeof null)//返回object</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1], [2, 3]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    return acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [1, 2]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>[1,2]是初始值，随后第一轮连接上[1,2,0,1]，第二轮连接上[1,2,0,1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aaa(...args) &#123;</span><br><span class="line">      console.log(args);</span><br><span class="line">  &#125;</span><br><span class="line">  aaa(2,34);</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，将会把传入的数据全都组装成一个数组。<br>所以，打印出的args为[2,34];<br>事件的三要素：事件源，事件，事件驱动程序<br>事件源：应发后续事件的html标签<br>事件：js已经定义好的<br>事件驱动程序：对样式和html的操作，也就是DOM<br>获取事件源：document.getElementById(“box”);<br>绑定事件：box.onclick = function(){}<br>书写事件驱动程序：关于DOM的操作<br>js的加载和html是同步加载的，因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。<br>建议是：整个页面上所有元素加载完毕之后执行js内容。<br>所以,window.onload可以预防使用标签在预定义之前。<br>DOM:文档对象模型，DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构，目的其实是为了能让js操纵DOM形成一种规范。<br>渲染引擎将把内存中把HTML文档，生成一个DOM树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = document.getElementsByTagName(&quot;div&quot;);     //方式二：通过 标签名 获得 标签数组，所以有s</span><br><span class="line"></span><br><span class="line">	var arr2 = document.getElementsByClassName(&quot;hehe&quot;);  //方式三：通过 类名 获得 标签数组，所以有s</span><br><span class="line">//返回数组</span><br><span class="line"> var div1 = document.getElementById(&quot;box1&quot;);      //方式一：通过id获取单个标签</span><br><span class="line">//返回object</span><br></pre></td></tr></table></figure></p>
<p>下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling<br>获取父节点：节点.parentNode获取到父节点<br>前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling<br>childNodes:标准属性，返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）<br>子节点数组 = 父节点.childNodes;<br>创建一个li标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a1 = document.createElement(&quot;li&quot;);</span><br></pre></td></tr></table></figure></p>
<p>插入节点<br>appendChild(新的子节点);<br>逐一获取属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myNode.getAttribute(&quot;src&quot;);</span><br></pre></td></tr></table></figure></p>
<p>设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(&quot;src&quot;,&quot;imgs&quot;);</span><br></pre></td></tr></table></figure></p>
<p>删除节点属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeAttributes(属性名);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;box&quot; value = &quot;111&quot;&gt;</span><br><span class="line">声明</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个标签就包含了3种标签，元素节点(标签) 属性节点 文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;box1&quot;);  //获取元素节点（标签）</span><br><span class="line">  var attribute = element.getAttributeNode(&quot;id&quot;); //获取box1的属性节点</span><br><span class="line">  var txt = element.firstChild;                   //获取box1的文本节点</span><br><span class="line"></span><br><span class="line">  var value = element.getAttribute(&quot;id&quot;);         //获取id的属性值</span><br></pre></td></tr></table></figure></p>
<p>nodeType = 1表示的是元素节点<br>nodeType = 2 表示属性节点<br>nodeType = 3表示文本节点<br>nodeName表示名称，nodeValue表示值<br>添加事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure></p>
<p>参数1：事件名(注意，没有on)<br>参数2：事件名（执行函数)<br>参数3：true表示捕获阶段触发，false表示冒泡阶段触发，如果不写，默认为false<br> //addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行<br>//第二种事件绑定的方法不会出现层叠。（更适合团队开发）<br>第二件添加的事件不会覆盖第一件的<br>DOM事件流：<br>事件传播的3个阶段：事件捕获，事件目标，事件冒泡<br>事件捕获：事件从上一级标签开始往下寻找，直到捕获到事件目标 target，从祖元素到子元素，DOM树结构，在这个过程中，事件相应的监听函数不会被触发。<br>事件目标：当到达目标元素之后，执行目标元素事件对应的处理函数，如果没有绑定监听函数，那就不执行。<br>事件冒泡：事件从事件目标target开始，网上逐渐冒泡到页面最上层一级。<br>在js中，如果想获取html节点，方法是document.documentElement<br>如果想获取body节点，方法是docuemt.body 二者不要混淆<br>事件冒泡：鼠标点击一个按钮，同样这个事件会在所有父元素上被触发。<br>通俗来讲，冒泡指的是：子元素的事件被触发时，父盒子的同样的事件也会被触发。取消冒泡就是取消这种机制。<br>冒泡顺序：<br>一般的浏览器: （除IE6.0之外的浏览器）<br>div -&gt; body -&gt; html -&gt; document -&gt; window<br>IE6.0：<br>div -&gt; body -&gt; html -&gt; document<br>不是所有的事件都能冒泡：<br>以下事件不冒泡：blur,focus,load,unload,onmouseenter,onmouseleave,意思是事件不会向父元素那里传递。<br>检查一个元素是否会冒泡，可以通过事件的如下参数：event.bubbles.<br>阻止冒泡的方法(火狐，谷歌，IE11)event.stopPropagation();<br>IE10以下则是event.cancelBubble = true;<br>事件委托：事件委托：通俗来说，就是把一个元素响应事件函数委托到另一个元素上<br>window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的 也可称为window子对象<br>window对象是js中的顶级对象，全局变量，自定义函数也是window对象的属性和方法<br>alert(1);confirm(1) prompt()不推荐使用 弹出框<br>打开窗口window.open(url,target,param)<br>url:打开地址 target:新窗口位置_blank _self _parent<br>param:新窗口的一些设置<br>返回值：新窗口的句柄<br>window.location简写成location,locaton相当于浏览器地址栏，可以将url解析成独立的字段<br>href:跳转 hash:返回url中#后面的内容 host:主机名 hostname:主机名 protocol 协议 一般是http、https<br>使用href的作用就是调用assign<br>window.location.assign(“<a href="https://www.baidu.com&quot;)" target="_blank" rel="noopener">https://www.baidu.com&quot;)</a>;<br>设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。assign会记录到历史记录中去<br>location.replace()：替换浏览器地址栏的地址，不会记录到历史中<br>navigator对象会获取客户端的一些信息<br>console.log(navigator.userAgent);<br>history.back() 表示后退 history.go(-1) 0是刷新<br>与普通函数相比，构造函数有以下明显特点：<br>用new关键字调用，不需要return显示返回值的，默认为返回this。建议函数名首字母大写，与普通函数区分开。<br>原型规则<br>规则1 所有的引用类型(数组，对象，函数)都具有对象特性，都可以自由扩展属性。null除外。<br>所有的引用类型(数组，对象，函数)都有<strong>proto</strong>属性，属性值是一个普通的对象。<em>proto</em>的含义是隐式原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p>
<p>所有的构造函数都有prototype类型 指向原型对象<br>通过for…in循环遍历对象，针对上面的那个fn对象，它自身有两个属性：name、printName，另外从原型中找到了第三个属性alertName。现在，如果我们对fn进行遍历，能遍历到两个属性还是三个属性呢？<br>答案：2个，因为高级浏览器已经屏蔽了来自原型的属性，。但是，为了保证代码的健壮性，我们最好自己加上判断，手动将第三个属性屏蔽掉：</p>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>这2个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call和apply时，函数会立即执行<br>都可以用来改变函数的this对象的指向<br>第一个参数都是this要指向的对象(函数执行时，this将指向这个对象)<br>thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。<br>传递一个别的函数名时，函数中的this将指向<strong>这个函数的引用。</strong><br>传递值为数字，布尔值，字符串时,this会指向这些基本类型的包装对象Number,Boolean,String<br>传递一个对象时，函数中的this则指向传递的这个对象。<br>call和apply的区别，<strong>call后面的实参和say方法中是一一对应的，而apply在传递实参时，要封装成一个数组，</strong>数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>call()和apply()的作用<br>改变this的指向<br>实现继承。Father.call(this)<br>bind()<br>都能改变this的指向<br>call()/apply()是<strong>立即调用函数</strong><br>bind()是将函数返回，因此后面还需要加()才能调用。<br>bind传参 xw.say.bind(xh,”实验”,”六年级”)();<br>或者xw.say.bind(xh)(“实验”,”小学”);<br>apply方法xw.say.apply(xh,[“实验小学”,”六年级”]);<br>call方法xw.say.call(xh,”实验小学”,”六年级”);<br>函数赋值给变量时，this指向window<br>var foo1 = args.getInfo;<br>foo1()<br>var foo2 = function() {};<br>foo2();<br>//this都是指向window<br>执行上下文主要有2种情况：<br>全局代码，一段script标签内，有一个全局的执行上下文。所做的事情是：变量定义，函数声明<br>函数代码：每个函数里面有一个上下文，所做的事情是：变量定义、函数声明、this,arguments<br>var定义的为全局变量 =&gt; undefined<br>function声明的全局变量 ===&gt; 赋值fun 添加为window的方法<br>this =&gt; 赋值(window)(<br>函数执行上下文：调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象，(虚拟的，存在于栈中)<br>对局部数据进行预处理<br>形参变量 ===&gt; 赋值(实参) 添加为执行上下文的属性<br>arguments ===&gt; 赋值(实参列表) 添加为执行上下文的属性<br>var 定义的局部变量 ===&gt; undefined 添加为执行上下文的属性<br>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法<br>this ===&gt; 赋值(调用函数的对象)<br>执行上下文栈：<br>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象<br>在全局执行上下文window确定后，将其添加到栈中<br>在函数执行上下文创建之后，将其添加到栈中<br>在当前函数执行完后，将栈顶的对象移除<br>当所有的代码执行完后，栈中只剩下window<br>this指的是，调用函数的那个对象。this永远指向函数运行时所在的对象。<br>解析器在调用函数的时候每次都会向函数内部传递一个隐藏的参数，这个隐藏的参数就是this<br>以函数形式调用,this会指向window<br>以构造函数创建，this是新创建的那个对象<br>使用call和apply调用时，this指向那个对象<br>作用域指一个变量的作用范围，是静态的(相对于上下文对象)<br>全局作用域 函数作用域<br>调用函数时会创建函数作用域，函数执行完毕以后，函数作用域会销毁。<br>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。<br>在函数作用域中可以访问到全局作用域中的变量，在全局作用域中无法访问到函数作用域中的变量。<br><strong>使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明</strong><br>在函数作用域中有效，而且会在函数中所有代码执行前会被声明。<br>全局执行上下文是在全局作用域确定之后，js代码马上执行之前就创建了。<br>函数执行上下文实在调用函数时，<strong>函数体代码执行之前创建</strong><br>作用域是静态的，只要函数定义好就一直存在,且不再变化<br>执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放<br>执行上下文(对象)是从属于所在的作用域<br>全局上下文环境 ===&gt; 全局作用域<br>函数上下文环境 ===&gt; 对应的函数使用域<br>闭包：能够读取其他函数内部数据(变量/函数)的函数<br>因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>object.prototype.toString.call(‘’) 检测类型[object:string]<br>this的值是在执行的时候才能确认，但是不能在定义的时候确认<br>箭头函数this指向：箭头函数没有自己的this,看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this,<br>如果没有，this就是window<br>执行栈认为是一个存储函数调用的结构，遵循先进后出原则。</p>
<h2 id="手写实现ajax"><a href="#手写实现ajax" class="headerlink" title="手写实现ajax"></a>手写实现ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;/api&quot;,false);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<h2 id="动态创建DOM元素的3种方式"><a href="#动态创建DOM元素的3种方式" class="headerlink" title="动态创建DOM元素的3种方式"></a>动态创建DOM元素的3种方式</h2><p>document.write()不常用 因为容易覆盖掉原来的页面<br>innerHTML = () 用的比较多，绑定属性和内容比较方便<br>document.createElement() 用的也比较多，，指定数量的时候一般用它。<br>vue双向绑定原理：通过数据劫持结合发布者-订阅者模式的方式来实现<br>利用object.defineProperty()这个方法重新定义了对象获取属性值(get)和设置属性值(set)。<br>jquery是事件驱动 而其余是数据驱动<br>jquery业务和UI更改混杂在一起，UI里面还涉及交互逻辑，让本来混乱的逻辑更加混乱<br>node js借助事件驱动，非阻塞I/O模型变得更加轻量和高效，非常适合于运行在分布式设备的数据密集型实时应用。<br>offsetWidth和offsetHight<br>offsetWitdh用于检测盒子<strong>自身的宽高+padding+border</strong><br>offsetWidth = width + padding + border;<br>offsetLeft 可以返回没有定位盒子的距离左侧的位置。如果父系盒子中都没有定位，以body为准。<br>style.left 只能获取行内式，如果没有，则返回””（意思是，返回空）;<br>scrollWidth = width + padding;<br>scrollHeight = height + padding;<br>client家族的形成<br>clientWidth:获取盒子区域宽度(padding + width)<br>clientHeight:获取盒子区域高度(padding + height)<br>body/html调用时，<br>clientWidth获取网页可视区域宽度<br>clientHeight获取网页可视区域高度</p>
<p>clientX:event调用：鼠标距离可视区域左侧距离<br>clientY:event调用：鼠标距离可视区域上侧距离</p>
<p>clientTop：盒子的上border。<br>clientLeft：盒子的左border。</p>
<p>宽高：<br>offsetWidth = width + padding + border;<br>offsetHeight = height + padding + border;</p>
<p>window.onresize事件指的是：在窗口或框架被调整大小时发生：<br>window.onscroll()屏幕滑动<br>window.onresize()浏览器大小变化<br><strong>window.onload()页面加载完毕</strong><br>div.onmousemove()鼠标在盒子上移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onresize = function() &#123;</span><br><span class="line">    document.title = window.screen.width + window.screen.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取显示屏的分辨率1920 * 1080<br>jQuery的两大特点 链式编程比如.show和.html可以连写成.show().html()<br>通常情况下：只有设置操作才能把链式编程延续下去，因为获取操作的时候，会返回获取到的相应值，无法返回this.<br>隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。<br>jquery加载完<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dom树生成即可</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>//文档加载完毕，图片不用加载完 写下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>onload是网页全部加载完毕，包括图片,ready只需要dom加载完毕，生成dom树即可</strong><br>通过jquery获取的元素是一个数组 数组中包含着原生JS中的DOM对象<br>通过原生js获取这些元素节点的方式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myBox = document.getElementById(&quot;box&quot;);           //通过 id 获取单个元素</span><br><span class="line">var boxArr = document.getElementsByClassName(&quot;box&quot;);  //通过 class获取的是数组</span><br><span class="line">var divArr = document.getElementsByTagName(&quot;div&quot;);    //通过标签获取的是数组</span><br></pre></td></tr></table></figure></p>
<p>总结：jquery就是把dom对象重新包装了一下，让其具有了jquery方法<br>子代选择器 &gt; 表示儿子 后代选择器  表示全部的都会被选中<br>属性选择器:$(“a[href]”) $(“a[href = ‘itcast’]”)<br>添加类样式<br>$(selector).addClass(“listItem”);<br>删除类样式<br>$(selector).removeClass(“listItem”);<br>判断是否有样式<br>$(selector).hasClass(“listItem”);<br>切换类样式<br>$(selector).toggleClass(“listItem”);<br>有则移除 没有则添加<br>jquery设置和获取属性<br>设置属性attr(“title”,”生命一号”);<br>获取属性attr(“title”);<br>val() 设置或返回form表单元素中的value值<br>$(selector).val();<br>获取文本内容<br>$(selector).text();<br>jquery设置宽度和高度<br>$(selector).height();//不带参数表示获取高度<br>$(selector).height(200);//带参数表示设置高度</p>
<p>$(selector).width();     //不带参数表示获取宽度<br>$(selector).width(200);  //带参数表示设置高宽度</p>
<p>$(“div”).css() //返回的是string类型，例如30px<br>$(“div”).height() 返回的是number类型,30常用于数学计算<br>click是单击事件 blur失去焦点 mouseenter鼠标进入 mouseleave 鼠标离开等<br>解除匹配元素的所有事件<br>$(selector).off()<br>阻止事件冒泡<br>event.stopProgation()<br>阻止默认行为<br>event.preventDefault()<br>$(selector).each(function(index,element){</p>
<p>})<br>参数一表示当前元素所在匹配元素中的索引号，<br>参数而表示当前元素<br>多库共存指的是：jquery占用了$和jquery两个变量，当在同一个页面引用了jquery和其他库时，恰好其他库也使用了jquery或者$<br>,那么要保证多库共用，<br>获取jquery库的版本号console.log($.fn.jquery);<br>办法一：让jquery放弃对$的使用权<br>$.noConflict();<br>办法二：同时放弃2个符号的使用权，并定义一个新的使用权<br>$.noConflict(true);<br>zepto库介绍<br>zepto是轻量级js库，专门为移动端定制<br>与jquery有类似的API,俗称：会jquery就会zepto<br>css3现状<br>浏览器支持程度不够好，有些需要添加私有前缀<br>移动端支持优于PC端<br>不断改进中<br>应用相对广泛<br>过渡:transition 2D转换:transform 3D转换:transform 动画:animation<br>实现不同状态间的平滑过渡<br>transition-property: all; 如果希望所有的属性都发生过渡，就使用all。<br>transition-duration:1s;过渡的持续时间<br>transition-timing-function: linear; 运动曲线<br>transition:all 3s linear 0s;<br>缩放：scale<br>transform:scale(x,y);x轴的缩放和y轴的缩放<br> x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。<br> translate 参数为百分比，表示相对于自身移动<br> 正值：向右和向下 负值：向左和向上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">width:600px;</span><br><span class="line">height:60px;</span><br><span class="line">background-color:red;</span><br><span class="line">position:absolute; 绝对定位</span><br><span class="line">left:50%; 让左边线居中</span><br><span class="line">top:0;</span><br><span class="line">transform:translate(-50%); 然后利用translate,往左走自己一半的宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform:rotate(角度);rotate(45deg); 正值：顺时针 负值：逆时针<br>3D旋转 rotateX,rotateY,rotateZ<br>动画可通过设置多个节点，来精确控制一个或一组动画，常用来实现复杂的动画效果。<br>@keyframes 动画名{<br>    from{初始状态}<br>    to{结束状态}<br>}</p>
<p>@keyframes move1 {<br>            from {<br>                transform: translateX(0px) rotate(0deg);<br>            }<br>            to {<br>                transform: translateX(500px) rotate(555deg);<br>            }<br>        }</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向，从左向右。<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。<br>flex-direction:row;reverse-row; column; reverse-column<br>justify-content:设置子元素在主轴上的对齐方式<br>justify-content:flex-start flex-end center space-around space-between<br>align-items：设置子元素在侧轴上的对齐方式。</p>
<p>align-items:flex-start; 设置子元素在侧轴上的对齐方式。属性值可以是：<br>flex-start 从侧轴开始的方向对齐<br>flex-end 从侧轴结束的方向对齐<br>baseline 基线 默认同flex-start<br>center 中间对齐<br>stretch 拉伸<br>通过window.online来检测用户当前的网络状况，返回一个布尔值。另外：<br>window.online用户网络连接时被调用 window.offline用户网络断开时被调用<br>boostrap标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta = http-equiv = &quot;X-UA-Compatible&quot; content = &quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>解释：设置浏览器的兼容模式版本，表示如果在IE浏览器下则使用最新的标准，渲染当前文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name = &quot;viewport&quot; content = &quot;width=device-width,inital-scale=1.0,user-scalable=no&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>解释：声明当前网页在移动端浏览器中展示的相关位置，我们在做移动 web 开发时，就用上面这行代码设置 viewport。<br>视口的作用：在移动浏览器中，当页面超出设备时，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示。<br>目前大多数手机浏览器视口：宽度都是980<br>此属性为移动端页面视口设置，上方代码设置的值，表示在移动端页面的宽度为设备的宽度，并且不缩放(缩放级别为1)<br>width:设置viewport的宽度 initial-scale:初始化缩放比例 minimum-scale:最小缩放比例 maximum-scale:最大缩放比例<br>user-scalable:是否允许用户手动缩放（值可以写成yes/no，也可以写成1/0）<br>C/S架构和B/S架构<br>是Client/Server这两个单词的首字母，指的是客户端和服务器<br>优点：<br>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可。<br>界面酷炫:客户端可以使用更多系统提供的效果,做出更为炫目的效果。<br>缺点:<br>更新软件：如果有新的功能，就要推出新的版本。<br>不同设备访问：如果使用其他的电脑，没有安装客户端的话就无法登陆软件。<br>B/S架构：浏览器/服务器类型<br>优点：<br>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容，对用户而言只需要刷新浏览器即可。<br>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用。<br>缺点:<br>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小。<br>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一。移动设备兼容性较好，ie6已经越来越少人用了。<br> php代码执行方式：在服务器端执行，然后返回给用户结果，如果直接使用浏览器打开，则会是一串文本<br> 意思：需要浏览器通过http请求，才能够执行php页面。<br> ajax:可以在不刷新页面的情况下，通过ajax方式去获取一些新的内容<br> ajax的核心是js对象：XMLHttpRequest<br> 发送请求<br> open(method,url,async);<br> method 请求的类型 get或post<br> url:文件在服务器上的位置<br> async:true(异步) 或 false(同步)<br> send(string)仅用于post请求<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.php&quot;, true);</span><br><span class="line"></span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line"></span><br><span class="line">xmlhttp.send(&quot;name=smyhvae&amp;age=27&quot;);</span><br></pre></td></tr></table></figure></p>
<p>注册onreadystatechange事件，每当readyState属性改变时，就会调用该事件<br>readyState:0请求未初始化 1服务器建立连接 2请求已接收<br>3请求处理中 4请求已完成<br>200 “OK” 404 “未找到页面”<br>jquery已经封装好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;01.php&quot;,</span><br><span class="line">    data:&quot;name=fox&amp;age=18&apos;,</span><br><span class="line">    type:&quot;GET&quot;,</span><br><span class="line">    success:function()&#123;</span><br><span class="line">     &#125;,</span><br><span class="line">    beforeSend:function()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同源策略：是浏览器的一种安全策略，指的是域名，协议，端口完全相同<br>jsonp 带补丁的json,本质是利用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>标签具有可跨域性，由服务端返回一个预先定义好的js函数的调用，并且将服务器数据以该函数参数的形式传递过来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;  src=&apos;http://192.168.141.137/2018-02-28/myData.php&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/BFC笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/BFC笔记/" itemprop="url">BFC笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T13:16:17+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>formatting context是w3c css2.1规范中的一个概念，是页面中的一块渲染区域，并且有一套渲染规则，他决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的便是BFC(块级格式化上下文)<br>是一个独立的渲染区域，只有block-level box参与，规定了内部的block-level box如何布局，并且与这个区域外部毫不相干，通俗的讲，bfc是一个容器，用于管理块级元素。<br>如何创建<br>float为left|right overflow为hidden|auto|display display为table-cell position为absolute 根元素<br>BFC布局规则：内部box在垂直方向，一个一个排列。<br>BFC的区域不会与float box重叠(利用这点可以实现自适应两栏布局)。<br>内部垂直方向距离有margin决定。属于同一个bfc的2个相邻box会发生margin重叠。<br>margin重叠3个条件：同属于一个bfc,相邻，块级元素<br>计算bfc高度时，浮动元素也参与运算。<br>bfc是页面上的一个独立容器，容器内部的子元素不会影响到外部。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KevinSwift">
            
              <p class="site-author-name" itemprop="name">KevinSwift</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
 
           <div>
              <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="50" height="60" src="//music.163.com/outchain/player?type=2&id=34532273&auto=1&height=66"></iframe>
           </div>
 
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinSwift</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
