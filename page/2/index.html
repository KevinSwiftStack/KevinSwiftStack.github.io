<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KevinSwift">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="KevinSwift">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KevinSwift">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>KevinSwift</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KevinSwift</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/浏览器缓存机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/浏览器缓存机制/" itemprop="url">浏览器缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T14:19:19+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/浏览器相关/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>缓存可以说是性能优化中简单高效的一种优化方式了，一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，<br>并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。<br>数据请求的步骤：发起网络请求，后端处理，浏览器响应。<br>浏览器缓存在第一步网络请求和浏览器响应2个环节中做性能优化。<br>缓存位置：<br>service worker:运行在浏览器背后的独立线程，一般可以用来实现缓存功能，<br>。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。service workder的缓存与浏览器其余内建缓存不同，它可以让我们<br><strong>控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是持续性的</strong><br>2.memory cache<br>memory cache也是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载好的样式，脚本等，<br>读取内存中的数据肯定比磁盘来得快，内存读取高效，可是缓存持续性很低，会随着进程的释放而释放，<br><strong>一旦关闭tab页面，内存中的缓存也就被释放了</strong>.<br><strong>内存缓存在缓存资源时并不关心返回的资源的http缓存头cache-control是什么，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。<br>3.disk cache 顾名思义也就是硬盘中的缓存，读取速度较低，但是什么都可以存储到磁盘中，，比之 Memory Cache 胜在容量和存储时效性上。
</strong>对于大文件来说，大概率是不会存储在内存中的，反之优先<strong>,
</strong>当前系统内存使用率高的话，文件优先存储进硬盘中<strong>.<br>4.push cache是http/2中的内容，当以上3种缓存都没有命中的时候，才会被使用，只在会话session中使用，一旦会话session结束，也就被释放，并且缓存时间很短。<br>出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个http连接。<br>大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为2种，</strong>强缓存和协商缓存<strong>,<br>并且缓存策略都是通过设置</strong>http header<strong>来实现的。<br>浏览器与服务器通信为应答模式，浏览器发出http请求，服务器响应后拿到数据，<br>浏览器如何确定一个资源该不该被缓存，如何去缓存呢。<br>浏览器第一次向服务器发起请求后拿到请求结果后，</strong>将请求结果和缓存标识<strong>存入浏览器缓存中，
</strong>浏览器每次发出请求，都会现在浏览器缓存中查找请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览<strong>
</strong>器缓存中<strong><br>确保了每个请求的缓存存入与读取，<br>是否需要向服务器重新发起http请求将缓存分为2个部分，分别是</strong>强缓存和协商缓存<strong><br>强缓存：不会向服务器发送请求，直接从缓存中读取资源，强缓存通过设置2种http header来实现，<br>expires 和 cache-control.<br>expires:</strong>用来指定资源到期的时间，是服务器端的具体的时间点<strong>,<br>expires = max-age + 请求时间，。需要和last-modified结合使用，<br>是web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器都可以直接从浏览器缓存中读取数据，而无需再次请求。<br>cache-control主要用来控制网页缓存，cache-control:max-age=300,则代表在这个请求正确返回时间，5分钟内再次加载该网页，就会命中强缓存，cache-control可以在请求头或者响应头中设置。<br>expires是http1.0的产物，cache-control是http1.1的产物，同时存在，</strong>cache-control优先级高于expires.<strong><br>expires是一个过期的产物，现阶段它的存在只是一种兼容性的写法。<br>强缓存判断是否缓存的依据是是否超出某个时间或者某个时间段，</strong>而不用去关心服务器端的数据是否跟新了<strong>.<br>可能导致加载文件不是服务器端最新的文件，那我们如何得知</strong>服务器端内容是否已经发生了更新呢<strong>这时候就要用到协商缓存。<br>5.协商缓存。<br>协商缓存是强缓存失效后，浏览器携带着</strong>缓存标识向服务器发起请求,由服务器根据缓存标识决定是否使用缓存的过程，<strong>,<br>主要有以下情况，
</strong>协商缓存生效，返回304和not modified<strong> 
</strong>协商缓存失效，返回200和请求结果<strong><br>协商缓存可以通过设置http header来实现，last-modified和if-modified-since.<br>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加last-modifed的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；<br>last-modifed是文件在服务器上的最后修改时间。<br>浏览器下一次请求资源时，浏览器首先检测有last-modified这个header,于是添加if-modified-since这个header,值就是last-modified中的值，服务器收到资源后，会根据if-modified-since中的值和服务器中的最后修改时间作比较，如果没有变化，就返回304和空的响应体，直接读取缓存，如果If-Modified-Since的时间小于浏览器的最后修改时间，说明文件有更新，于是返回新的资源文件和200.<br>如果本地打开了缓存文件，即时没有修改文件，也会造成last-modified被修改，服务器不能命中缓存导致发送相同的资源。<br>既然根据文件修改时间来决定是否缓存尚有不足，能否根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了ETag和If-None-Match.<br>ETag是服务器响应请求时，返回当前资源文件的一个唯一标示，(由服务器生成)，只要资源有变化，ETag就会重新生成，浏览器在下一次加载资源并向服务器端发送请求时，，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传过来的if-none-match和自己服务器上的etag标签是否一致即可。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。<br>etag优于last-modified<br>强缓存优于协商缓存进行。，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，</strong>协商缓存有服务器决定是否使用缓存**，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。<br>用户行为对浏览器缓存的影响：指的是用户在浏览器操作时，会触发怎样的缓存策略。<br>打开网页：直接输入地址，查找disk cache中是否有匹配。。如有则使用；如没有则发送网络请求。<br>普通刷新(f5),因为tab并没有关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache.<br>强制刷新(ctrl + f5),浏览器不使用缓存，存，因此发送的请求头是:cache-control:no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/05/深入浅出浏览器渲染定理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/05/深入浅出浏览器渲染定理/" itemprop="url">深入浅出浏览器渲染定理与模块化概念，类型转换等</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-05T20:47:26+08:00">
                2019-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/浏览器相关/" itemprop="url" rel="index">
                    <span itemprop="name">浏览器相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浏览器的内核是指支持浏览器运行的最核心的程序，分为2个部分，一是渲染引擎，另一个是js引擎，<br>渲染引擎在不同的浏览器中也是不同的，目前市面上常见的浏览器内核有Trident(IE),Gecko(火狐，<br>Blink(Chrome),Webkit(Safari),<br>webkit是当下浏览器世界真正的霸主<br>页面加载过程：<br>浏览器根据dns服务器得到域名的ip地址<br>向这个ip的机器发送http请求<br>服务器收到，处理并返回http请求<br>浏览器得到返回内容</p>
<p>一堆HTML格式的字符串，因为只有HTML格式浏览器才能正确解析，<br>HTML树 -&gt; DOM树形结构<br>CSS -&gt; CSS规则树<br>js脚本，等到js脚本文件加载后，通过dom api和cssom api来操作dom树和css规则树<br>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造render tree,渲染树。<br>渲染树会包括需要显示的节点和这些节点的样式信息。<br>css的规则树主要为了完成匹配吧css规则添加到渲染树上的每个节点<br>最后，计算每个frame的位置，这又叫layout和reflow过程。<br>字节数据 =&gt; 字符串 =&gt; token =&gt; node =&gt; dom<br>在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。<br>将字符串转化为token,例如<html>，<body>等。Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息。<br><strong>渲染树只会包括需要显示的节点和这些节点的样式信息</strong><br>渲染过程中，如果遇到script就停止渲染，执行js代码，因为浏览器有GUI渲染线程和JS引擎线程。为了防止渲染出现不同的结果，这两个线程是<strong>互斥</strong>的关系，JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。<br>首屏渲染的越快的话，就越不应该在首屏就加载js文件，这也是将js放在body底部的原因。<br>js不仅阻塞dom的构建，也会导致cssom和dom的构建。<br>因为js不仅可以修改DOM，也可以修改样式。<br>因为js需要修改cssom.所以浏览器将延迟脚本执行和dom构建，直至完成cssom的下载和构建，<br><strong>在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM</strong><br>根据渲染树进行布局，也可以叫做<strong>回流</strong>,<br>输出一个精准的<strong>盒模型</strong>,每个元素在视口内的准确位置。<br><strong>重绘</strong>：当我们对dom的修改导致了样式的变化，却并未影响到几何属性，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式<br><strong>回流</strong>：当我们对dom的修改引发了dom几何尺寸的变化，浏览器会重新计算，这个过程就是回流。<br><strong>回流一定会引发重绘，但重绘不一定引发回流</strong>.<br>减少重绘或者回流：<br>使用visibility替换display:none.因为前者会引发重绘。<br>不要使用table布局。<br>动画速度越快，回流次数越多<br>defer 使脚本在文档解析完成后执行。不会影响html的解析。<br>async:用于异步下载文件，下载完后立即解释执行。不会阻塞html的执行</body></html></p>
<h2 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h2><p>将一个复杂的程序依据一定的规则封装成几个块(文件),并进行组合在一起<br>块的内部数据与实现是私有的，只是向外部暴露一些接口(方法),与外部其他模块通信。<br>模块化的好处<br>避免命名冲突(减少命名空间污染)<br>更好的分离，按需加载<br>更高复用性<br>高可维护性<br>引入多个script后出现的问题<br>请求过多，会发送多个请求。依赖模糊，难以维护<br>可能出现牵一发而动全身的情况。<br>模块化规范：commonjs,AMD,ES6,CMD规范<br>commonjs node应用由模块组成，采用commonjs模块规范，<br>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong><br>暴露模块 module代表当前模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">exports.xxx = value;</span><br></pre></td></tr></table></figure></p>
<p>引入模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(xxx);</span><br></pre></td></tr></table></figure></p>
<p>commonjs规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作<br>amd规范则是非同步的，允许指定回调函数，由于node js主要用于服务端编程，，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，<br>浏览器环境，要从服务器端加载模块，这时必须采用非同步模式，这时AMD就比较实适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define[&apos;modlue1&apos;,&apos;module2&apos;],function(m1,m2)&#123;</span><br><span class="line">    return 模块;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>引入使用模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;module1&apos;,&apos;module2&apos;,function(m1,m1)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>requurejs是一个工具库，，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<br>基本思想：通过define,将代码定义为模块，通过require,实现代码的模块加载。<br>CMD<strong>规范专门用于浏览器端，模块的加载是异步的</strong>,模块使用时才会加载执行。<br>CMD整合了commonjs和amd规范的特点，在sea.js中，<br>通过define配置文件，通过requre导入文件。<br>AMD和CMD都适用于浏览器端，AMD同步，CMD异步。<br>ES6的模块化语法<br>export{basicNum,add};<br>import{add} from ‘./main’;<br>commonjs提出的是一个值的拷贝，而es6是值的引用。<br>commonjs是模块运行时加载，es6模块是**编译时输出的接口。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>js是一门动态类型语言，所谓的动态类型可以确定是在语言中一切内容是不确定的<br>如果运算符发现，运算子的类型与预期不符合，就会自动进行转换。<br><strong>自动转换时基于强制转换的，</strong><br>强制转换主要指使用Number,String,Boolean.3个函数<br>其他数据类型转换为string<br>toString()方法<br>null和undefined这2个值没有toString方法，如果调用，会报错<br>采用number类型的toString()方法的基模式，可以用不同的基输出数字，<br>例如二进制基为2，八进制为8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = 10;</span><br><span class="line">alert(num.toString(2)); //输出1010</span><br></pre></td></tr></table></figure></p>
<p>方式二 采用string函数<br>string函数作强制转换，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br><span class="line">String(a);//为字符串&quot;null&quot;</span><br><span class="line">String(&#123;a:1&#125;);//转化为[object Object]</span><br></pre></td></tr></table></figure></p>
<p>转为数字<br>如果字符串中有非数字的内容，则转为NaN,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number(&quot;324&quot;);//324</span><br><span class="line">Number(&quot;324anc&quot;);//NaN</span><br><span class="line">Number(undefined);//转为NaN</span><br><span class="line">Number(&#123;a:1&#125;) //转化为NaN</span><br></pre></td></tr></table></figure></p>
<p>parseInt()把一个字符串转为整数，有效体转为整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(10.43a&quot;) //为10</span><br></pre></td></tr></table></figure></p>
<p>parseFloat()把一个字符串转为浮点数。<br>空字符串，null,undefined,+0,-0,和NaN转为布尔型为false.</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>作用域是一个独立的地盘，让变量不会外泄，暴露出去，作用域最大的好处是隔离变量，不同作用域下的同名变量不会冲突。</strong><br>es6之间只有全局作用域和函数作用域。<br>es6提供了块级作用域。<br>let和const的声明并不会提升到当前代码块的顶部，因此需要手动提升。<br>let不能重复声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var count = 30;</span><br><span class="line">   function outFun2() &#123;</span><br><span class="line">   let count = 20;</span><br><span class="line">    console.log(count);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上这种情况 在嵌套的作用域内使用let声明一个同名的新变量，<br>并不会抛出错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var cnt = 30;</span><br><span class="line">let cnt = 40;</span><br></pre></td></tr></table></figure></p>
<p>作用域链，更确切的说是在<strong>创建这个函数的时候的作用域，而不是调用时候的</strong><br>以上这种情况便会报错。<br>js的执行分为解释阶段和执行阶段<br>解释阶段：词法分析，语法分析，作用域规则确定<br>执行阶段：创建执行上下文，执行函数代码，垃圾回收<br>执行上下文最明显的就是this的指向是在执行时候确定的。</p>
<h2 id="js事件循环机制"><a href="#js事件循环机制" class="headerlink" title="js事件循环机制"></a>js事件循环机制</h2><p>js是单线程任务，所有任务都需要排队，前一个任务结束，后一个任务才会接上，js中有2种任务，一种是同步任务，一种是异步任务，<br>异步任务指的是，不进入主线程，而进入<strong>消息队列</strong>的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入<strong>主线程</strong>,异步任务又包括<strong>宏任务</strong>和<strong>微任务</strong>,<br><strong>在所有同步任务执行完之前，异步任务是不会执行的</strong>.<br>event loop,只要主线程空了，就会去读取”任务队列”内的东西。<br>放入异步任务的代码：setTimeout,DOM事件，promise,ajax请求。<br>setTimeout和setInterval是过几秒后被放入异步队列<br>异步任务分为宏任务和微任务，<strong>宏任务队列可以有多个，而微任务队列只有一个</strong><br>宏任务包括:script全局任务，setTimeout,setInterval, setImmediate, I/O, UI rendering。<br>微任务包括：new Promise().then,<br>由于执行代码入口都是全局任务scrpit,而全局任务是属于宏任务，所以当栈为空的时候，首先执行微任务队列里的任务，再去执行宏任务队列中最前面的任务。执行宏任务过程中，遇到微任务，再依次加入微任务队列。<br>栈空后，再次读取微任务队列里的任务，以此类推。<br>当某个宏任务中代码全部执行完毕后，会查看是否有微任务队列，如果有，先执行微任务队列中的任务，如果没有，就查看是否有其他宏任务队列。</p>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，<strong>新旧对象还是共享同一块内存</strong>,<br>但是深拷贝会另外创建一个一模一样的对象，新对象和原对象不共享内存，修改新对象不影响原对象。<br>赋值赋的是栈中的地址，而不是堆中的地址。<br>浅拷贝的实现方式object.assign()<br>var initObj = Object.assign({},obj);<br>initObj.a.a = “wade”;<br>console.log(obj.a.a);//打印出来wade<br>深拷贝实现方式<br>json.parse(json.stringfy())<br>函数库loadash<br>该函数库有提供_.cloneDeep来做深拷贝</p>
<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>函数柯里化<br>只传递函数一部分参数来调用他，让他返回一个函数去处理剩余的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通add函数</span><br><span class="line">function add(x,y)&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">//柯里化后</span><br><span class="line">function curryAdd(x)&#123;</span><br><span class="line">    return function(y)&#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add(1,2);</span><br><span class="line">curryAdd(1)(2);</span><br></pre></td></tr></table></figure></p>
<p>柯里化作用 可以起到参数服用 复用的结果<br>可以将一个reg返回后，返回一个带有一个正则表达式校验的函数，<br>在剩余函数中调用。</p>
<h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>代表当前可见的计算机图形区域，在web浏览器中，通常与浏览器窗口相同，但不包括浏览器的UI，菜单栏等。<br>布局视口：布局视口是网页布局的基准窗口，在 PC浏览器上，布局视口就等于当前浏览器窗口大小（不包括 borders 、 margins、滚动条）。，移动端默认为980px<br> document.documentElement.clientWidth/clientHeight来获取<br>视觉视口：用户通过屏幕真实看到的区域：<br> 相当于浏览器的窗口大小，当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小<br>window.innerWidth和innerHeight来获取<br>理想视口：网站页面在移动端显示的理想大小。<br>当页面缩放比例为 100%时， CSS像素=设备独立像素， 理想视口=视觉视口。<br>screen.width /height</p>
<p>window.innerHeight 获取浏览器视觉视口高度<br>window.screen 屏幕理想视口宽度，设备的分辨率，设备像素比<br>document.clientHeight 布局视口高度<br>offsetHeight 获取包括内边距，滚动条，边框和外边距<br>scrollHeight在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。<br>移动端适配 @media移动端查询 flexible方案，统一使用rem来布局，<br>vh,vw方案将视觉视口window.innerWidth和height等分为100份<br>(连接)[<a href="https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ]</a></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是js的一个难点，<br>作用：可以访问函数内部的变量，使变量的值长期保存在内存中<br>形成条件：<strong>函数嵌套，内部函数引用外部函数的局部变量</strong><br>能够读取其他函数内部变量的函数<br>只有函数内部的子函数才能读取内部变量，因此可以把闭包理解为”定义在一个函数内部的函数”,<br>闭包的特点<strong>记住诞生的环境,比如f2记住了它诞生的环境f1,所以从f2可以得到f1的内部变量.
</strong>闭包将内部函数和外部函数连接起来的一座桥梁**<br>内存泄漏指的是任何对象在您不需要拥有或者使用的时候它仍然存在，闭包不能滥用，否则导致内存泄漏，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null.<br>闭包作用：读取函数内部的变量，可以使变量的值长期保存在内存中，生命周期比较长。<br>用来实现js模块，js模块:具有特定功能的js文件，将所有数据和功能都封装在一个函数内部，只向外暴露一个具有n个方法的对象或者函数，只需要通过暴露模块的对象调用来实现对应的功能即可。<br>forEach,map,filter,find,every,some,reduce它们都有共同的特点，不会改变原来数组。<br>线程与进程的区别</p>
<h2 id="node中的事件循环"><a href="#node中的事件循环" class="headerlink" title="node中的事件循环"></a>node中的事件循环</h2><p><strong>一个进程只有一个主线程</strong><br><strong>进程是cpu资源分配的最小单位,线程是cpu调度的最小单位</strong>,<br>一个进程可以由一个线程或多个线程组成，线程是一个进程中代码的不同执行路径<br><strong>进程的内存空间是共享的，每个线程都可以共享这些内存</strong><br>浏览器内核是多线程的，在内核控制下各个线程互相配合以保持同步，<br>GUI渲染线程，js引擎线程，定时触发线程，事件触发线程，异步http请求线程。<br>node中的event loop<br>node中的event loop和浏览器中的完全是不相同的东西，node js采用v8作为js的解析引擎，而I/O处理方面采用了自己设计的libuv.<br>libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统的底层特性，对外提供统一的api,事件循环机制也是这里面实现的。<br>node js运行机制如下:<br>v8引擎解析js脚本。<br>解析后的代码，调用node api.<br>libuv库负责node api的执行，将不同的任务分给不同的线程执行，形成一个event loop,以异步的方式将<strong>任务的执行结果返回v8引擎</strong>.<br>v8引擎将结果返回给用户</p>
<p>libuv执行node api分为以下几个阶段<br>事件循环分为6个阶段，会按照顺序反复执行，每当进入一个阶段时，都会从对应的回调队列中取出函数去执行，当队列为空或者执行的回调函数达到系统设定时，将会进入下一个阶段。<br>外部输入数据 -&gt; 轮询阶段(poll) -&gt; 检查阶段(check) -&gt; 关闭事件回调阶段(close callback) -&gt; 定时器检测阶段(timer) -&gt; I/O事件回调阶段(I/O callbacks) -&gt; 闲置阶段(idle,prepare)<br>timers阶段(这个阶段执行timer(setTimeout,setInterval))的回调<br>i/o callback阶段，处理一些上一轮循环中少数的未执行的i/o回调<br>idle 仅node内部使用<br>poll阶段 获取新的i/o事件。<br>check阶段 执行setimmediate的回调<br>close callback 执行socket的close事件回调</p>
<p>poll阶段<br>1.回到timer阶段执行回调<br>2.执行i/o回调<br>并且在进入该阶段如果没有设定timer的话，会发生如下事件<br>如果poll队列不为空，会遍历回调队列并且同步执行，直到队列为空或者达到系统上线<br>如果poll队列为空，如果有setimmediate回调需要执行，poll阶段停止并且进入到 check 阶段执行回调<br>如果没有setimmediate，会等待回调被加入到队列中并立即执行。<br>check阶段 setimmediate的回调会被加入到check中<br>node中事件也有宏任务(macro)和微任务(micro)<br>macro:setTimeout,setInterval,setImmediate,script代码<br>micro:process.nextTick,new Promise().then(回调)<br>process.nextTick,独立于event loop外，有自己的一个队列，<br>当每个阶段完成后，如果存在nextTick队列，会清空队列中的所有回调函数，并且优于其余的微任务执行。<br>浏览器环境中，microtask的任务队列是每个macrotask执行完后再执行<br>而在node js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask中的任务。</p>
<h2 id="js中的垃圾回收和内存泄漏"><a href="#js中的垃圾回收和内存泄漏" class="headerlink" title="js中的垃圾回收和内存泄漏"></a>js中的垃圾回收和内存泄漏</h2><p>内存泄漏指的是：不再用到的内存，没有来级的释放。js具有<strong>自动回收垃圾机制</strong><br>js的垃圾回收机制：找出不再使用的变量，然后释放掉其内存即可。<strong>垃圾回收期会按照固定的时间间隔周期性的回收</strong><br>垃圾回收有2种方法：标记清除和引用计数<br>标记清除：<strong>当变量进入执行环境时，就标记这个变量进行环境</strong>，逻辑上讲，永远不要释放进入环境的变量所占用的内存，因为只要执行刘进入相应的环境，就可能会用到他们，<strong>当变量离开环境的时候，就将其标记为离开环境。</strong><br>引用计数：是指语言引擎有一张‘引用表’，保存了内存里面的所有资源(通常是各种值)的引用计数。<br>如果一个值的引用计数为0，就表示该值不会再用到，因此可以将该值释放。<br>如果一个值不再需要了，引用计数却不为0，垃圾回收机制将无法识别这块内存。从而导致内存泄漏。<br>哪些情况会造成内存泄漏：<br>会让<strong>变量一直处于进入环境的状态</strong>，而无法被回收。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(arg)&#123;</span><br><span class="line">    bar = &quot;this&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创造了一个全局变量，在页面关闭之前是不会释放的。<br>被遗忘的计时器或者回调函数 闭包可以维持内部函数的局部变量，使其得不到释放。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/web前端入门和进阶js笔记-node-js笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/29/web前端入门和进阶js笔记-node-js笔记/" itemprop="url">web前端入门和进阶js笔记-node js笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-29T09:29:13+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/node相关/" itemprop="url" rel="index">
                    <span itemprop="name">node相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>异步编程<br>node 采用google v8引擎来处理js脚本，js最大特点就是单线程运行，一次只能运行一个任务<br>node 大量采用异步操作，即任务不是马上执行，<strong>而是插在任务队列的尾部，等到前面的任务执行完再去执行</strong>.<br>提高代码的响应能力。<br>异步IO也叫非阻塞IO，例如读文件，传统的语言，基本都是读取完毕才能进行下一步操作。非阻塞就是Node的callback，不会影响下一步操作，等到文件读取完毕，回调函数自动被执行，而不是在等待。<br>所以只有把错误交给<strong>回调函数</strong>来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(&quot;找小黑&quot;,function(error,data)&#123;</span><br><span class="line">    if(error)</span><br><span class="line">    throw error;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>异步线程不容易维护，阅读，调试，可以通过es5的promise机制和es6最新提出的async/await机制来实现<br>进程：每一个<strong>正在运行</strong>的应用程序被称为进程。进程是<strong>操作系统为应用程序分配资源的一个单位</strong><br>线程：用来执行应用程序中的代码，一个进程内部，可以分为<strong>多线程</strong><br>在一个线程内部，同时只可以干一件事<br>传统的开发方式大部分都是 I/O 阻塞的，所以需要多线程来更好的利用硬件资源。<br>多线程弊端：<br>创建线程耗费，线程数量有限，cpu需要在不同线程之间切换。</p>
<p>事件驱动和非阻塞机制：<br>node中将所有的阻塞操作都交给了内部线程池来实现。<br>node主线程本身。主要是不断的往返调用。<br>node js基本上所有的事件机制都是利用设计模式中的<strong>观察者模式</strong>来实现。<br>node js单线程类似于进入一个while(true)循环，直到没有事件观察者退出，每个异步事件生成一个事件观察者，如果有事件发生就调用回调函数。<br>node js使用事件驱动模型，当web-server接收到后，就把他关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。<br>node采用事件驱动的运行模型，通过事件驱动的方式处理请求时无需为每一个请求额外创建线程。在事件驱动的模型当中，每一个IO工作被添加到事件队列中，线程循环的来处理队列上的工作任务，当执行过程中遇到阻塞，线程不会阻塞下来，而是会返回一个回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在阻塞任务结束后才会被执行。<br>nginx是<strong>多进程单线程</strong><br><strong>每个Tick周期中会从事件队列查看是否有事件需要处理，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于堵塞IO的处理在幕后使用线程池来确保工作的执行。Node从池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止堵塞IO占用空闲资源。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。</strong><br>node内部采用google v8引擎，作为js引擎解释器<br><strong>通过自行开发的libuv库，调用操作系统资源</strong><br>总结<br><strong>node js</strong>是一个js的运行环境(平台)，不是一门语言，也不是一个框架。<br>node js环境即REPL环境<br>REPL:ead,eval,print,loop类似于浏览器的控制台<br><strong>接收用户输入，执行用户输入，打印执行结果到控制台，循环下一次</strong></p>
<h2 id="程序模块化："><a href="#程序模块化：" class="headerlink" title="程序模块化："></a>程序模块化：</h2><p>js文件越来越多，会遇到一些问题：文件污染，全局污染，命名冲突<br>程序模块化：<br>日期模块，数学计算模块，日志模块<br>模块化：将一个复杂的程序依据一定的规则(规范)封装成几个文件，并且组合在一起。<br>模块的内部数据：实现是私有的，只是向外部暴露一些接口。<br>模块化的好处<br>避免命名冲突，减少命名空间污染<br>降低耦合性；更好地分离、按需加载<br>高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。<br>高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。<br>部署方便<br>模块化规范：<br>模块化起源于node js,node js中把很多js打包成package,需要的时候直接(require) common.js要求 导入进来，这就是模块化的方式。<br>服务端模块化：commonjs是node js使用的模块化规范，约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。<br>浏览器端规范：amd规范:是requrejs在推广过程中对模块化定义的规范化产出。异步加载模块<br>同步加载模块：cmd是seajs在推广过程中对模块化定义的规范化产出。淘宝团队开发。<br>暴露模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">exports.xxx = value;</span><br><span class="line">引入requre(xxx);</span><br></pre></td></tr></table></figure></p>
<p>自定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    name:&quot;我是module1&quot;,</span><br><span class="line">    foo()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let module1 = require(&quot;./modules/module1&quot;);</span><br><span class="line">module1.foo();</span><br></pre></td></tr></table></figure></p>
<p>AMD:异步模块定义：AMD专门用于浏览器端，模块的加载是<strong>异步</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function() &#123;</span><br><span class="line">    return 模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;module1&apos;,&apos;module2&apos;],function(m1,m2)&#123;</span><br><span class="line">    //使用</span><br><span class="line">    m1 / m2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>CMD同步模块加载，CMD专门用于浏览器端，模块的加载是<strong>同步</strong>的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = value;</span><br><span class="line">//引入依赖的模块(同步的方式)</span><br><span class="line">    var module2 = require(&apos;./module2&apos;)</span><br><span class="line"></span><br><span class="line">    //引入依赖的模块(异步的方式)</span><br><span class="line">    require.async(&apos;./module3&apos;, function (m3) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>es6模块化的说明<br>依赖模块需要编译打包处理<br>1.有些浏览器不支持es6的语法，写完es6的代码后，需要babel将es6转化为es5<br>export<br>引入模块 import xxx from ‘路径’<br>默认暴露的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default() =&gt; &#123;</span><br><span class="line">    console.log(&quot;我暴露了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>es6语法概览：<br>块级作用域，字符串，对象扩展，解构，类，模块化。<br>let定义变量，代替var</p>
<h2 id="http状态"><a href="#http状态" class="headerlink" title="http状态"></a>http状态</h2><p>http协议是无状态的，服务器只会响应来自客户端的请求，但是他与客户端之间不具备持续连接。<br>服务端发送事件后，无法推送到客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。<br>知道服务器的状态：<br>轮询：客户端每隔很短的时间，都会向服务器发出请求，，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。<br>长连接：客户端只请求一次，但是服务器会保存这次连接，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。<br>websocket协议：允许客户端与服务器端以<strong>全双工</strong>的形式进行通信。<br>WebSocket 的原理非常简单：利用HTTP产生请求握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者之间使用TCP进行交流（QQ的协议）。<br>HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>
<p>websocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。</p>
<p>keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。<br>es6中新语法<br>如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：<br>arr1是一个数组，arr2不需要指向arr1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = [...arr1];</span><br></pre></td></tr></table></figure></p>
<p>angularJS提供更多的是一套解决方案，更像是一个生态<br>vue和react目前都使用了virtual dom<br>vue和react的相同点<br>利用虚拟DOM实现快速渲染<br>轻量级<br>响应式组件<br>支持服务端渲染<br>易于集成路由工具，打包工具以及状态管理工具<br>虚拟dom:可以在js内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据完整解析，一次性插入到DOM里面去，这就形成了虚拟DOM。</p>
<h2 id="promise机制"><a href="#promise机制" class="headerlink" title="promise机制"></a>promise机制</h2><p>promise:简单来说就是一个容器，里面保存着某个未来才会结束的事件的结果，从语法上说，promise是一个对象，从他可以获取异步操作的结果，promise提供一个统一的api,各种异步操作都可以用同样的方法处理，让开发者不用再关心时序和底层的结果，promise的状态具有<strong>不受外界影响和不可逆</strong>的特点。传统回调存在bug:调用回调次数过少或过多。对于Promise来说，即使是立即完成的Promise也无法被同步观察到，也就是说一个Promise调用then()的时候，即使这个Promise已经决议了，提供给then的回调也总会被异步调用。<br>对于一个proise对象来说，对象的注册和每一个观察回调都是相对独立的，互不干预的，而promise对象调用reslove和reject,每个注册的观察回调也都会被自动调度。所以这些观察回调的任意一个都无法影响或延误对其他回调的调用。<br>css中的BFC概念。</p>
<h2 id="BFC概念"><a href="#BFC概念" class="headerlink" title="BFC概念"></a>BFC概念</h2><p>文档流，常说的文档流其实分为<strong>定位流，浮动流，普通流</strong>,3种，而普通流就是指BFC中的FC(fomatting context),直译过来就是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用，常见的FC有BFC,IFC,还有GFC和FFC。<br>BFC，块级格式化上下文，是用于布局块级盒子的一块渲染区域。MDN上的解释就是：BFC是web页面css视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响的一个区域。<br>一个BFC的范围包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。这从另一方角度说明，一个元素不能同时存在2个BFC中，因为如果一个元素能够同时处于两个BFC中，那么就意味着这个元素能与两个BFC中的元素发生作用，就违反了BFC的隔离作用。<br>常规流：盒一个接着一个排列。<br>浮动：floats，左浮动元素尽量靠左，靠上，右浮动。<br>绝对定位：盒从常规流中被移除，不影响常规流的布局。<br>根元素，即HTML标签<br>浮动元素：float值为 left、 right<br>overflow值不为 visible，为 auto、 scroll、 hidden<br>display值为 inline-block、 table-cell、 table-caption、 table、 inline-table、 flex、 inline-flex、 grid、 inline-grid<br>定位元素：position值为 absolute、 fixed</p>
<ol start="5">
<li>作用<br>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。<br>5.1阻止元素被浮动覆盖。5.2可以包含浮动元素，通过改变包含浮动子元素的父盒子的属性值，触发BFC，以此来包含子元素的浮动盒子。<br>5.3阻止因为浏览器因为四舍五入造成的多列布局换行的情况<br>5.4阻止相邻元素的margin合并</li>
</ol>
<p>node js是一个基于google v8引擎的js运行环境，所以v8就是node js中使用的虚拟机环境，在之后讲解的 Node.js 中的 GC 其实就是在讲 V8 的 GC。<br>node js与v8的关系好比java与JVM之间的关系，另外 Node.js 之父 Ryan Dahl 在选择 V8 做为 Node.js 的虚拟机时 V8 的性能在当时已经领先了其它所有的 JavaScript 虚拟机，至今仍然是性能最好的，因此我们在做 Node.js 优化时，只要版本升级性能也会伴随着被提升<br>提供了process.memortUsage方法来查看当前进程的使用情况。<br>垃圾回收是指回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象<strong>就会作为垃圾回收的候选对象</strong>,这里的根对象为全局对象，局部变量，无法从根节点访问指的是不会再被任何其他活动对象所引用。<br><img src="/uploads/v8.jpg" width="50%" height="50%"><br>v8中分为新生代和老生代空间，新生代空间中存储频繁的数目，随后将长期驻存的移到老生代空间中。<br>IE盒子模型包含border和padding<br>box-sizing:content-box;标准盒模型<br>box-sizing:border-box;IE盒模型<br>获取样式高度 宽度<br>window.getComputedStyle(element).width/height;<br>BFC:块级格式化上下文<br>BFC渲染原理：BFC内部的子元素，在垂直方向，边距会发生重叠。<br>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然<br>BFC区域不会与旁边的float box区域重叠。<br>计算BFC的高度时，浮动的元素也参与计算<br>DOM事件的级别：<br>准确来说，是DOM标准定义的级别：<br>dom0级别的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dom2级别的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&quot;click&quot;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure></p>
<p>true表示捕获阶段触发,false<br>dom3级别的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&quot;keyup&quot;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>DOM3中，增加了很多事件类型，比如鼠标事件，键盘事件等。<br>为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。<br>window -&gt; document -&gt; html -&gt; body -&gt; 目标元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myEvent = new Event(&quot;clickTest&quot;);</span><br><span class="line">element.addEventListener(&quot;clickTest&quot;,function() &#123;</span><br><span class="line">     console.log(&apos;smyhvae&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">element.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure></p>
<p>http协议：<br>客户端和服务器端是两种身份，第一次请求结束后，就断开了，第二次请求时，<strong>服务器没有记住之前的状态</strong>,<br>HTTP报文的组成：<br>请求报文：请求行，请求头，空行，请求体<br>响应报文：状态行，响应头，空行，响应体<br>请求行：post方法，请求的url,http协议以及版本<br>请求头：一大堆键值对<br>请求体：数据部分<br>响应报文：<br>状态行：http协议以及版本，状态码以及描述<br>响应头：http/1.1 200 OK<br>响应体：返回的数据<br>http状态码：1xx 指示信息-表示请求已经接受 基础处理<br>2xx 成功 表示请求已被成功接受<br>3xx 重定向 要完成请求必须进一步操作<br>4xx 客户端错误<br>5xx 服务器错误<br>instanceof的作用：用于判断<strong>实例</strong>属于哪个构造函数<br>原理：判断实例对象的<strong>proto</strong>属性，和构造函数的prototype属性，是否是同一个引用(即是否是同一个地址)<br>foo instanceof Object的结果也是true,<br>new 运算符发生了什么<br>1.创建了一个<strong>新的空对象实例</strong><br>2.将此空对象的隐式原型指向其构造函数的显示原型<br>3.执行构造函数，同时 this 指向这个新实例。<br>4.如果返回值是一个新对象，就返回该对象，如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.name = &quot;sym&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用class声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ajax：不支持跨域<br>websocket:不受同源策略的限制，支持跨域<br>cors:不受同源策略的限制，支持跨域。同时支持同源和跨域的Ajax。<br>jsonp实现原理：通过script标签的异步加载来实现，比如说，实际开发中，head标签里，可以通过script标签的src,里面来放url,加载很多在线的插件，这里就是通道了jsonp</p>
<h2 id="反射型xss"><a href="#反射型xss" class="headerlink" title="反射型xss"></a>反射型xss</h2><p>在没有网站登出的情况下去访问非法网站，非法网站就要求A去访问新的网站，并且携带者A的cookie -&gt; CSRF<br>跨域脚本攻击：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本，可能是js,html代码块，最后导致结果：盗用cookie,破坏页面解构，插入广告等。d-doss攻击。 -&gt; xss<br>随表单一起提交给服务器，服务器随后解析，xss代码随响应体一起传回，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。<br>存储型：提交的代码会存储在服务器端，下次请求目标页面时就不用再提交XSS代码了。</p>
<h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><p>DTD(文档类型定义)：<br>是一系列的语法规则，用来定义XML或者(x)HTML文件类型，浏览器使用<strong>DTD判断文档类型</strong>.决定使用哪种协议来解析，以及切换浏览器模式。告诉浏览器，我是什么文档类型，你要用什么协议来解析我。<br>&lt;!DOCTYPE html&gt;<br>DOM tree和CSS Rule Tree合并成Render Tree,（虽然有了Render Tree，但并不知道节点的位置，需要依靠接下来的layout）<br>有了render Tree,浏览器已经知道网页中有哪些节点，各个节点的css定义以及他们的从属关系，<strong>从而去计算每个节点在屏幕上的位置(宽高，颜色等)</strong>.<br>painting:按照计算出来的规则，通过显卡，把内容绘制到屏幕上。<br>display:打击看到最终的效果。<br>reflow:重排，dom节点中的各个元素都有自己的盒子，这些都需要浏览器<strong>根据各种样式来进行计算，并根据计算结果将元素放在他该出现的位置</strong>，这个过程称为reflow.<br>触发reflow:增加，删除，修改dom节点。 导致reflow和repaint<br>移动dom位置。修改css样式，宽高，display为none时。<br>repaint:重绘制，当各种盒子的位置，大小以及其余属性，例如颜色，字体大小都确定后，浏览器便会把这些元素按照各自的特性绘制一遍，于是页面的内容也就出来了。<br><strong>页面呈现的内容，绘制在屏幕上，叫做重绘</strong><br><strong>页面元素的位置，叫做重排</strong><br>js是单线程(同一时间只能做意见事情),而且只有一个任务队列，全部的同步任务执行完毕后，才会去执行异步任务，<br>遇到异步任务，setTimeout等，先挂起。全部的同步任务执行完毕后，再来执行异步任务。<br>什么时候需要等待，就什么时候需要用异步。<br>定时任务：setTimeout,网络请求,ajax,动态img增加。<br>事件绑定。比如所，按钮绑定点击事件，用户爱点不点，我们不可能一直卡在那里，，什么都不做。所以，应该用异步）<br>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>总结：只要主线程空了，就去读取“任务队列”。<br>提升页面性能方法<br>1.资源压缩合并，减少http请求。<br>2.非核心代码异步加载，<br>document.createElement() defer加载，async加载<br>defer:在html解析完之后才会执行，如果是多个，则按照加载顺序依次执行。<br>async:在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。<br>3.利用浏览器缓存，和存储不是一件事<br>缓存 资源文件<br>强缓存：不用请求服务器，直接使用本地缓存<br>强缓存是利用HTTP响应头中的express或cache-control实现<br>Cache-Control的优先级高于Expires。<br>4.使用CDN<br>5.DNS预解析<br>前端错误监控：<br>1.前端错误的分类 2.每种错误的捕获方式 3.上报错误的基本原理<br>try…catch window.onerror函数 这个函数是全局的<br><strong>手机端的web开发，怎么和原生做交互？</strong><br><strong>调用原理需清楚,怎么调用原生的插件的</strong></p>
<h2 id="let-var-function"><a href="#let-var-function" class="headerlink" title="let var function"></a>let var function</h2><p>let的<strong>创建</strong>过程被提升了，但是初始化没有被提升<br>var的<strong>创建</strong>和<strong>初始化</strong>都被提升了<br>function的<strong>创建</strong>和<strong>初始化</strong>和<strong>赋值</strong>都被提升了<br>声明时的重名问题：<br>假设a被声明为变量，紧接着又被声明为函数，原则是：：<strong>声明会被覆盖（先来后到，就近原则）。</strong><br>如果a已经有值，再用var声明是无效的<br>如果a已经有值，紧接着又被赋值，则<strong>赋值会被覆盖</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fn;</span><br><span class="line">function fn() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(fn); //打印函数fn</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var fn;//再用var 无效</span><br><span class="line">console.log(fn);//打印结果 函数fn</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;&#125;  //fn被声明为function，且此时fn已经有值，这个值就是function的对象</span><br><span class="line"></span><br><span class="line">    function fn() &#123;   //此时fn被重复赋值，会覆盖上一行的值</span><br><span class="line">        console.log(&apos;smyhvae&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(fn)</span><br></pre></td></tr></table></figure>
<p>下面的fn声明会覆盖上面的<br>使用var关键字声明的变量，是在函数作用域中有效，而且会在函数中所有的代码之前被<strong>声明</strong>.<br>函数声明也会在函数中所有的代码执行之前执行。<br>在函数中，没有var声明的变量会成为<strong>全局变量</strong>,而且不会提前声明。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/web前端入门和进阶js笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/web前端入门和进阶js笔记/" itemprop="url">web前端入门和进阶js笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T17:44:09+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="js和esmscript的关系"><a href="#js和esmscript的关系" class="headerlink" title="js和esmscript的关系"></a>js和esmscript的关系</h2><p>js和ecmscrpit的关系<br>ecmscript是一种有ecma国际制定和发布的脚本语言规范<br>ecmscript不是一门语言，而是一种标准<br>js包括ecmpscript(语言核心功能基于ES规范)<br>DOM js需要支持对DOM的维护，通过document element<br>BOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的<br>提一下nodejs.nodejs是基于chrome V8引擎。上文提到V8引擎是用来解析执行JS，并且V8是基于ECMAscirpt标准实现的.换个角度说,nodejs里头没有DOM和BOM的操作,只保留的javascript的语法核心(ES),并且增加了事件驱动的非阻塞I/O模型，使其轻量级和高效。nodejs作为服务运行在linux,mac,window,把javascipt的角色从前台开发,转移到了后台开发。<br><a href="https://www.jianshu.com/p/10cfcb536d4a" target="_blank" rel="noopener">js与ecmscript的关系</a><br>js是<strong>弱变量</strong>类型的语言，变量声明用var来实现。而java中必须带类型<br>var a;</p>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><p><img src="/nowcoder/webjs.jpg" width="50%" height="50%"><br>1、User Interface 用户界面，我们所看到的浏览器</p>
<p>2、Browser engine 浏览器引擎，用来查询和操作渲染引擎</p>
<p>3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS</p>
<p>4、Networking 网络，负责发送网络请求</p>
<p>5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码</p>
<p>6、UI Backend UI后端，用来绘制类似组合框和弹出窗口</p>
<p>7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage</p>
<p>js分为3部分组成<br>ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。<br>DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。<br>BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。<br>PS：JS机械重复性的劳动几乎为0，基本都是创造性的劳动。而不像HTML、CSS中margin、padding都是机械重复劳动。<br>js是解释型语言，事先不需要被编译成机器码再执行，逐行执行，无需进行严格的变量声明。<br>解释型语言：边解析边执行，不需要事先编译。例如：JavaScript、php。</p>
<p>编译型语言：事先把所有的代码翻译成计算机能够执行的指令，然后整体执行。例如：c、c++。<br>分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。<br>用户输入<br>prompt()就是专门用来弹出能够让用户输入的对话框，用得少，测试的时候会用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = prompt(&quot;请随便输入点东西&quot;); //不管是什么语句 输入都是字符串</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="基本对象和引用对象"><a href="#基本对象和引用对象" class="headerlink" title="基本对象和引用对象"></a>基本对象和引用对象</h2><p>基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。<br>引用数据类型（引用类型）：Object 对象。<br>注意：内置对象function、Array、Date、RegExp、Error等都是属于Object类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。<br>面试问：引用数据类型有几种？<br>面试题：只有一种，即object类型。<br>基本数据类型：参数赋值的时候，传数值<br>引用数据类型：参数赋值的时候，传地址<br>（2）引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。但是单引号里可以嵌套双引号。<br>\” \’ \n换行<br>无穷大 Infinity 无穷小 -Infinity<br>注意：typeof Infinity的返回结果是number。<br>NaN:是一个特殊的数字，表示Not a Number<br>typeof NaN返回的是number<br>null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。<br>其他数据类型 -&gt; Number<br>字符串 -&gt; 数字<br>1.字符串是纯数字 则将其转化为数字<br>2.字符串有非数字的内容，则转化为NaN,<br>3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0。<br>null -&gt; 数字 0 undefined -&gt; 数字 NaN<br>parseInt的作用，将字符串中有效的整数内容转化为数字<br>console.log(parseInt(“2017.01在公众号上写了6篇文章”));  //打印结果仍是：2017   （说明只会取整数）<br>只能取开头的，中间的不能截取<br>对非String使用parseInt()或者parseFloat() 先转换成string再操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = true;</span><br><span class="line">console.log(parseInt(a));</span><br></pre></td></tr></table></figure></p>
<p>转化为字符串”true”,然后再操作，打印出来NaN<br>转化为Boolean<br>数字 -&gt; 布尔 除了0和NaN 其余都转化为true<br>字符串 -&gt; 布尔 除了空串 其余都是true<br>null和undefined 转化为false<br>对象转化为true<br>布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，<strong>但返回结果是原值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = 5 &amp;&amp; 6;</span><br><span class="line">console.log(&apos;result&apos; + result);</span><br></pre></td></tr></table></figure></p>
<p>与运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则必然返回第二个值（所以说，如果所有的值都为true，则返回的是最后一个值）</p>
<p>如果第一个值为false，则直接返回第一个值</p>
<p>或运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则直接返回第一个值</p>
<p>如果第一个值为false，则返回第二个值<br>== 这个符号并不严谨，会将不同类型的东西，转为相同类型进行比较（大部分情况下，都是转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> console.log(&quot;6&quot; == 6);		// 打印结果：true。这里的字符串&quot;6&quot;会先转换为数字6，然后再进行比较</span><br><span class="line">console.log(true == &quot;1&quot;);   // 打印结果：true</span><br><span class="line">console.log(0 == -0);       // 打印结果：true</span><br><span class="line"></span><br><span class="line">console.log(null == 0);   // 打印结果：true</span><br><span class="line">   console.log(undefined == null) //打印true</span><br><span class="line">   console.log(NaN == NaN) //false</span><br></pre></td></tr></table></figure></p>
<p>如果要保证完全等于，我们就要用三个等号===。全等不会做类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;6&quot; === 6);		//false</span><br><span class="line">console.log(6 === 6);</span><br></pre></td></tr></table></figure></p>
<h2 id="js中的代码块"><a href="#js中的代码块" class="headerlink" title="js中的代码块"></a>js中的代码块</h2><p>js中的代码块，只具有分组的作用，没有其他用途<br>代码块中的内容，在外部是完全可见的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	var a = 2;</span><br><span class="line">&#125;	</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<p>switch语句，条件分支语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case 1:</span><br><span class="line">	break;</span><br><span class="line">	case 2:</span><br><span class="line">	break;</span><br><span class="line">	default:</span><br><span class="line">	breeak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>break语句一般建议不要省略，否则会出现<strong>case穿透现象</strong><br>continue用来跳过当次循环<br>基本数据类型是直接保存在<strong>栈内存</strong>中，值与值之间是独立存在的，修改一个变量不会影响其他变量。<br>对象：只要不是那5种基本数据类型，就全都是对象。<br>如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。<br>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。<br>对象是保存到<strong>堆内存</strong>中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，变量保存的是对象的内存地址(对象的引用)<br>换言之，对象的值是保存在堆内存里的，但是对象的引用是保存在栈内存中的<br>对象的分类：内置对象，由ES标准定义的对象，在任何的ES的实现中都可以使用<br>比如Math,String,Number,Boolean,Function,Object<br>宿主对象：由js运行环境提供的对象，就是主要由浏览器提供的对象<br>比如DOM,BOM,console document等<br>自定义对象 由开发人员自己创建的<br>in运算符，通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true,没有返回false<br>“属性名” in 对象<br>console.log(“name” in obj);<br>js中 所有的<strong>变量</strong>都是保存在栈中的。<br>基本数据类型:基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。<br>引用数据类型:对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟一块新的空间，<strong>而变量保存了对象的地址</strong>,对象的引用，如果两个变量保存了同一个对象的引用，当一个通过变量去修改属性时，另一个也会修改。<br>函数的介绍：将一些功能语句进行封装 函数也是一个对象 使用typeof检查一个函数对象时，返回<strong>function</strong><br>函数表达式:<strong>将匿名函数赋值给一个变量</strong><br>fn()与fn的区别<br>fn()调用函数，相当于获取了函数的返回值<br>fn:函数对象，相当于直接获取了函数对象<br>在js中，只有2种作用域：全局作用域和函数作用域<br>直接编写在script标签中的JS代码，都在全局作用域。</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁。</p>
<p>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。</p>
<p>在全局作用域中：</p>
<p>创建的变量都会作为window对象的属性保存。</p>
<p>创建的函数都会作为window对象的方法保存。</p>
<p>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到<br>变量的声明提前(变量提升)<br>使用var关键字声明的变量var = 1 <strong>会在所有代码执行之前声明(但不赋值)</strong><br>但是如果声明时不用var 比如a = 1 则变量不会被声明提前<br>函数声明：下面就为函数声明的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">	console.log(&quot;我是函数fn1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以函数的声明会提前，也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。<br>fn1()后再声明函数<br>函数表达式不会提前<br>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。<br>当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁。参考链接：<br>this:解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数便是this,this指向的是一个对象，这个对象我们称之为函数的执行<strong>上下文对象</strong>,<br>以函数形式调用,this指向window,比如func()<br>以方法形式调用，this是调用方法的那个对象<br>以构造函数形式调用，this是新创建的那个对象<br>使用call和apply调用，this指定的是那个对象</p>
<h2 id="箭头函数中this的指向"><a href="#箭头函数中this的指向" class="headerlink" title="箭头函数中this的指向"></a>箭头函数中this的指向</h2><p>es6的箭头函数中并不会使用上面4条标准的绑定规则，而是会继承外层函数调用的this绑定(无论this绑定到什么)<br>在调用函数式，浏览器每次都会传递2个隐含参数,this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	console.log(typeof arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。<br>arguments代表的是<strong>实参</strong>,我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments只在函数中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">	console.log(fn.length);//获取形参个数</span><br><span class="line">	console.log(arguments.length);//获取实参个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、arguments可以修改元素<br>之所以说arguments是伪数组，是因为：arguments可以修改元素，但不能改变数组的长短。举例：<br>new 一个构造函数的执行流程<br>(1)开辟内存空间，存储新创建的对象<br>(2)将新建的对象设置为构造函数中的this,在构造函数中可以使用this来引用新对象。<br>(3)执行函数中的代码，(包括设置对象属性和方法等)。<br>(4)将新建的对象作为返回值返回<br><strong>所有的对象都是Object的后代</strong>，因此，任何对象instanceof Object返回的结果都是true.<br>JSON:json的属性必须用双引号来括起来，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            &quot;name&quot; : &quot;zs&quot;,</span><br><span class="line">            &quot;age&quot; : 18,</span><br><span class="line">            &quot;sex&quot; : true,</span><br><span class="line">            &quot;sayHi&quot; : function() &#123;</span><br><span class="line">                console.log(this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>json的遍历与对象的遍历一样，用for…in…来进行遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myJson = &#123;</span><br><span class="line">       &quot;name&quot;: &quot;smyhvae&quot;,</span><br><span class="line">       &quot;aaa&quot;: 111,</span><br><span class="line">       &quot;bbb&quot;: 222</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   //json遍历的方法：for...in...</span><br><span class="line">   for (var key in myJson) &#123;</span><br><span class="line">       console.log(key);   //获取 键</span><br><span class="line">       console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）</span><br><span class="line">       console.log(&quot;------&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><p>原型prototype的概念：<br>认识1：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象，<br>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">	var per1 = new Person();</span><br><span class="line">	var per2 = new Person();</span><br><span class="line">console.log(Person.prototype); //打印结果[object object]</span><br><span class="line">console.log(per1.__proto__ == Person.prototype); //相等</span><br></pre></td></tr></table></figure></p>
<p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。<br>使用in来检查，如果对象中没有但是原型中有，也会返回true.<br>可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。</p>
<h2 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h2><p>当一个对象没有任何的变量或者属性对他进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。<br>在堆内存中：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。<br>js中有自动的垃圾回收机制，会自动回收这些垃圾。如果你不再使用这些对象，将其置为null即可。<br>数组Array是属于内置对象。<br>数组和普通对象的功能类似，也是用来存储一些值的。不同的是：<br>普通对象是使用字符串来作为属性名的，而数组是使用数字来作为索引来操作元素。<br>数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(&quot;参数&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>如果修改的length大于原长度，则多出来部分会空出来，置为null.<br>如果修改的length小于原长度，则多出来部分会被删除，数组将从后面删除元素。<br>数组的基本方法<br>unshift(),在数组最前面插入一个或多个元素，返回结果为数组新的长度。<br>shift(),删除数组的第一个元素，返回结果为被删除的元素<br>forEach()没有返回值，也就是说，返回值是undefined.<br>filter()返回结果是true的项，将组成新的数组，可以起到过滤的作用。<br>map()对原数组中的每一项进行加工<br>every()如果有一项返回false,则停止遍历<br>some()只要有一项返回true,则停止遍历<br>注意：这几个方法不会修改原数组。都会组成新的数组等。<br>forEach循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;网一&quot;,&quot;网二&quot;];</span><br><span class="line">arr.forEach(function(item,index,obj)&#123;</span><br><span class="line">	console.log(item);</span><br><span class="line">	console.log(index);</span><br><span class="line">	console.log(obj);</span><br><span class="line">&#125;)</span><br><span class="line">//表示当前正在遍历的元素，正在遍历元素的索引，和正在遍历的数组</span><br><span class="line">//filter函数</span><br><span class="line">var arr1 = [1,2,3,4,5,6];</span><br><span class="line">var arr2 = arr1.filter(function(item,index)&#123;</span><br><span class="line">	if(item &gt; 2)</span><br><span class="line">	return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;)</span><br><span class="line">//map方法 解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。</span><br><span class="line"></span><br><span class="line">  var arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">    var arr2 = arr1.map(function (item, index) &#123;</span><br><span class="line">        return item + 10;  //让arr1中的每个元素加10</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(arr2);</span><br><span class="line">	//every方法 只有全部返回true,才返回true</span><br><span class="line">	 var arr1 = [&quot;千古&quot;, &quot;宿敌&quot;, &quot;南山忆&quot;, &quot;素颜&quot;];</span><br><span class="line">    var bool1 = arr1.every(function (element, index, array) &#123;</span><br><span class="line">        if (element.length &gt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(bool1);  //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false</span><br><span class="line"></span><br><span class="line">some()方法</span><br><span class="line">解释：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。</span><br><span class="line">如果都返回false,则返回值是false。如果有一项返回true,则停止遍历，返回true.</span><br></pre></td></tr></table></figure></p>
<p>数组的常用方法<br>slice 从数组中提取指定的一个或多个元素，返回新的数组，不会改变原数组<br>splice从数组中删除指定的一个或多个元素，返回新的数组，会改变原数组<br>concat连接两个或多个数组，返回新的数组，不会改变原数组<br>jon将数组转化为字符串，返回转换后的字符串，不会改变原数组<br>reverse反转数组，返回翻转后的数组，会改变原数组<br>sort,对数组元素，按unicode编码，从小到大排序，会改变原数组。<br>slice<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result1 = arr.slice(2);//从第二个位置开始提取</span><br><span class="line">var result2 = arr.slice(-2);//提取最后2个元素</span><br><span class="line">var result3 = arr.slice(2,4);//提取从第二个到第四个 不包含4</span><br></pre></td></tr></table></figure></p>
<h2 id="将伪数组转化为真数组"><a href="#将伪数组转化为真数组" class="headerlink" title="将伪数组转化为真数组"></a>将伪数组转化为真数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = Array.from(arrayLike);</span><br></pre></td></tr></table></figure>
<p>splice 删除一个或多个元素，返回新的数组，会改变原数组<br>新数组 = 原数组.splice(起始索引index,需要删除的个数,第三个参数，第四个参数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];</span><br><span class="line">   var result1 = arr1.splice(1);</span><br><span class="line">   console.log(arr1); //第1个删除后返回arr1</span><br><span class="line">   console.log(result1); //原数组的第一个删除了 给result</span><br></pre></td></tr></table></figure></p>
<p>从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr4 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素</span><br><span class="line">var result4 = arr4.splice(1, 3, &quot;千古壹号&quot;, &quot;vae&quot;);</span><br></pre></td></tr></table></figure></p>
<p>concat连接 arr1.concat(arr2);将arr2中的元素追加到arr1的尾部<br>join方法指定一个字符串作为参数，这个字符串将会成为数组元素连接的连接符，如果不指定连接符，则默认使用’,’作为连接符，此时和 toString()的效果是一致的。<br>reverse反转字符串<br>sort函数中的自定义方法，<br><strong>如果返回一个大于0的值，则元素会交换位置，</strong><br><strong>如果返回一个小于0的值，则元素位置不变</strong><br>如果返回0，则认为2个元素相等，则不交换位置。<br>var result = arr3.sort(function(a,b){<br>    if(a &gt; b){<br>        return a - b; //升序排列<br>        return b - a;//降序排列<br>        return 1;//如果a &gt; b则交换a和b的位置，就是进行升序排列<br>    }else if(a &lt; b){<br>        return -1; //元素位置保持不变<br>    }else<br>return 0;<br>})<br>indexOf,lastIndexOf获取数据的索引<br>从后往前索引，获取 value 在数组中的最后一个下标    从后往前，找到最后一次出现的，也就是排在最后的出现的那位。<br>find(function (item, index){</p>
<p>})<br>Array.from将伪数组转化为真数组<br>伪数组的原型链中没有Array.prototype,而真数组的原型链中有Array.prototype<br>Array.of(1,’abc’,true);//将一系列值转化成数组<br>isArray 判断是否是数组<br>valueOf,返回数组本身 数组本身 = 数组.valueOf();<br>内置对象简介：内置对象就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用的或是最基本而必要的功能。<br>内置对象    对象说明<br>Arguments 函数参数组合<br>Array    数组<br>Boolean    布尔对象<br>Date    日期时间<br>Error    异常对象<br>Function    函数构造器<br>Math    数学对象<br>Number    数值对象<br>Object    基础对象<br>RegExp    正则表达式对象<br>String    字符串对象<br>Date对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure></p>
<p>传递一个表示时间的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date2 = new Date(&quot;2017/09/06 09:00:00&quot;);</span><br><span class="line">console.log(date2);</span><br></pre></td></tr></table></figure></p>
<h2 id="Date和Math方法"><a href="#Date和Math方法" class="headerlink" title="Date和Math方法"></a>Date和Math方法</h2><p>获取日期和时间<br>getDate() //获取日子 1-31<br>getDay() //获取星期0-6 0代表周末 1代表周一<br>getMonth() //获取月份0-11 0代表1月<br>getTime() //获取时间戳<br>时间戳指的是从格林威治标准时间的1970.1.1号0时0分0秒到现在日期所花费的毫秒数(1s = 1000 ms)<br>内置对象Math的常见方法<br>Math.abs()返回绝对值<br>Math.floor()向下取整(向小取)<br>Math.ceil()向上取整(向大取)<br>Math.round()四舍五入(正数四舍五入,负数五舍六入)<br>Math.random()生成0-1之间的随机数<br>Math.max(x,y,z)返回多个数中的最大值<br>Math.min(x,y,z)返回多个数中的最小值<br>生成0-x之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * x);</span><br></pre></td></tr></table></figure></p>
<p>生成x-y之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * (y - x) + x);</span><br></pre></td></tr></table></figure></p>
<h2 id="url编码和解码"><a href="#url编码和解码" class="headerlink" title="url编码和解码"></a>url编码和解码</h2><p>URI 通用资源标识符，进行编码，以便发送给浏览器，有效的URI编码不能包含某些字符，例如空格，而这URI编码方法就可以对URL进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent();   //把字符串作为 URI 组件进行编码</span><br></pre></td></tr></table></figure></p>
<p>包装类的介绍：<br>js中的数据类型包括以下几种，<br>基本数据类型：string,number,boolean,null,undefined<br>引用数据类型：object<br><strong>js为我们提供了3个包装类</strong><br>String(),将基本数据类型字符串，转化为String对象<br>Number(),将基本数据类型数字，转化为Number对象。<br>Boolean()：将基本数据类型的布尔值，转换为Boolean对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(3);</span><br><span class="line">var str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。<br>方法和属性只能添加给对象，不能添加给基本数据类型。<br>slice方法 从字符串中截取指定的内容，不会修改原字符串 而是将截取到的内容返回<br>(2,5)截取时，包左不包右<br>字符串 = str.slice(开始索引,结束索引);<br>(2)表示<strong>从指定的索引位置开始，截取到最后</strong><br>(-3)表示从倒数第几个开始，截取到最后<br>(1,-1)表示从第一个截取到倒数第一个<br>(5,2)表示前面的大，后面的小，返回值为空<br>substring,不能接受负值作为参数，如果传递了一个负值，默认使用0<br>substring还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。<br>substr从字符串中截取指定的内容，不会修改原来的字符串，而是将及截取到的内容返回。<br>  字符串 = str.substr(开始索引, 截取的长度);<br>  开始所以，截取的长度<br>  用逗号来隔开字符串，split<br>  trim去除字符串前后的空白。replace替换所有的<br>  toLowerCase()转换成小写<br>  定义：正则表达式用于定义一些字符串的规则。</p>
<p>作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);</span><br><span class="line">console.log(reg.test(str1));</span><br></pre></td></tr></table></figure></p>
<p>来进行测试，检查是否符合。</p>
<h2 id="let-var-function，eval的区别"><a href="#let-var-function，eval的区别" class="headerlink" title="let var function，eval的区别"></a>let var function，eval的区别</h2><p>let变量不存在变量提升问题，在我们声明(初始化)他们之前，他们是不可访问的。这被称为<strong>暂时死区</strong><br>let 的「创建」过程被提升了，但是初始化没有提升。<br>var 的「创建」和「初始化」都被提升了。<br>function 的「创建」「初始化」和「赋值」都被提升了。<br>eval会为字符串传递的代码求值，如果它是一个表达式，就像如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sum = eval(&quot;10 * 10 + 5&quot;);</span><br></pre></td></tr></table></figure></p>
<p>sum为105 先计算出来 再赋值<br>所有对象键：(不包括Symbol)都会被存储为字符串形式，即使你没有给定字符串类型的键。<br>默认情况下：事件处理程序在冒泡阶段执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof a);//返回function</span><br><span class="line">console.log*typeof null)//返回object</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1], [2, 3]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    return acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [1, 2]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>[1,2]是初始值，随后第一轮连接上[1,2,0,1]，第二轮连接上[1,2,0,1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aaa(...args) &#123;</span><br><span class="line">      console.log(args);</span><br><span class="line">  &#125;</span><br><span class="line">  aaa(2,34);</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，将会把传入的数据全都组装成一个数组。<br>所以，打印出的args为[2,34];<br>事件的三要素：事件源，事件，事件驱动程序<br>事件源：应发后续事件的html标签<br>事件：js已经定义好的<br>事件驱动程序：对样式和html的操作，也就是DOM<br>获取事件源：document.getElementById(“box”);<br>绑定事件：box.onclick = function(){}<br>书写事件驱动程序：关于DOM的操作<br>js的加载和html是同步加载的，因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。<br>建议是：整个页面上所有元素加载完毕之后执行js内容。<br>所以,window.onload可以预防使用标签在预定义之前。<br>DOM:文档对象模型，DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构，目的其实是为了能让js操纵DOM形成一种规范。<br>渲染引擎将把内存中把HTML文档，生成一个DOM树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = document.getElementsByTagName(&quot;div&quot;);     //方式二：通过 标签名 获得 标签数组，所以有s</span><br><span class="line"></span><br><span class="line">	var arr2 = document.getElementsByClassName(&quot;hehe&quot;);  //方式三：通过 类名 获得 标签数组，所以有s</span><br><span class="line">//返回数组</span><br><span class="line"> var div1 = document.getElementById(&quot;box1&quot;);      //方式一：通过id获取单个标签</span><br><span class="line">//返回object</span><br></pre></td></tr></table></figure></p>
<p>下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling<br>获取父节点：节点.parentNode获取到父节点<br>前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling<br>childNodes:标准属性，返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）<br>子节点数组 = 父节点.childNodes;<br>创建一个li标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a1 = document.createElement(&quot;li&quot;);</span><br></pre></td></tr></table></figure></p>
<p>插入节点<br>appendChild(新的子节点);<br>逐一获取属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myNode.getAttribute(&quot;src&quot;);</span><br></pre></td></tr></table></figure></p>
<p>设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(&quot;src&quot;,&quot;imgs&quot;);</span><br></pre></td></tr></table></figure></p>
<p>删除节点属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeAttributes(属性名);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;box&quot; value = &quot;111&quot;&gt;</span><br><span class="line">声明</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个标签就包含了3种标签，元素节点(标签) 属性节点 文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;box1&quot;);  //获取元素节点（标签）</span><br><span class="line">  var attribute = element.getAttributeNode(&quot;id&quot;); //获取box1的属性节点</span><br><span class="line">  var txt = element.firstChild;                   //获取box1的文本节点</span><br><span class="line"></span><br><span class="line">  var value = element.getAttribute(&quot;id&quot;);         //获取id的属性值</span><br></pre></td></tr></table></figure></p>
<p>nodeType = 1表示的是元素节点<br>nodeType = 2 表示属性节点<br>nodeType = 3表示文本节点<br>nodeName表示名称，nodeValue表示值<br>添加事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure></p>
<p>参数1：事件名(注意，没有on)<br>参数2：事件名（执行函数)<br>参数3：true表示捕获阶段触发，false表示冒泡阶段触发，如果不写，默认为false<br> //addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行<br>//第二种事件绑定的方法不会出现层叠。（更适合团队开发）<br>第二件添加的事件不会覆盖第一件的<br>DOM事件流：<br>事件传播的3个阶段：事件捕获，事件目标，事件冒泡<br>事件捕获：事件从上一级标签开始往下寻找，直到捕获到事件目标 target，从祖元素到子元素，DOM树结构，在这个过程中，事件相应的监听函数不会被触发。<br>事件目标：当到达目标元素之后，执行目标元素事件对应的处理函数，如果没有绑定监听函数，那就不执行。<br>事件冒泡：事件从事件目标target开始，网上逐渐冒泡到页面最上层一级。<br>在js中，如果想获取html节点，方法是document.documentElement<br>如果想获取body节点，方法是docuemt.body 二者不要混淆<br>事件冒泡：鼠标点击一个按钮，同样这个事件会在所有父元素上被触发。<br>通俗来讲，冒泡指的是：子元素的事件被触发时，父盒子的同样的事件也会被触发。取消冒泡就是取消这种机制。<br>冒泡顺序：<br>一般的浏览器: （除IE6.0之外的浏览器）<br>div -&gt; body -&gt; html -&gt; document -&gt; window<br>IE6.0：<br>div -&gt; body -&gt; html -&gt; document<br>不是所有的事件都能冒泡：<br>以下事件不冒泡：blur,focus,load,unload,onmouseenter,onmouseleave,意思是事件不会向父元素那里传递。<br>检查一个元素是否会冒泡，可以通过事件的如下参数：event.bubbles.<br>阻止冒泡的方法(火狐，谷歌，IE11)event.stopPropagation();<br>IE10以下则是event.cancelBubble = true;<br>事件委托：事件委托：通俗来说，就是把一个元素响应事件函数委托到另一个元素上<br>window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的 也可称为window子对象<br>window对象是js中的顶级对象，全局变量，自定义函数也是window对象的属性和方法<br>alert(1);confirm(1) prompt()不推荐使用 弹出框<br>打开窗口window.open(url,target,param)<br>url:打开地址 target:新窗口位置_blank _self _parent<br>param:新窗口的一些设置<br>返回值：新窗口的句柄<br>window.location简写成location,locaton相当于浏览器地址栏，可以将url解析成独立的字段<br>href:跳转 hash:返回url中#后面的内容 host:主机名 hostname:主机名 protocol 协议 一般是http、https<br>使用href的作用就是调用assign<br>window.location.assign(“<a href="https://www.baidu.com&quot;)" target="_blank" rel="noopener">https://www.baidu.com&quot;)</a>;<br>设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。assign会记录到历史记录中去<br>location.replace()：替换浏览器地址栏的地址，不会记录到历史中<br>navigator对象会获取客户端的一些信息<br>console.log(navigator.userAgent);<br>history.back() 表示后退 history.go(-1) 0是刷新<br>与普通函数相比，构造函数有以下明显特点：<br>用new关键字调用，不需要return显示返回值的，默认为返回this。建议函数名首字母大写，与普通函数区分开。<br>原型规则<br>规则1 所有的引用类型(数组，对象，函数)都具有对象特性，都可以自由扩展属性。null除外。<br>所有的引用类型(数组，对象，函数)都有<strong>proto</strong>属性，属性值是一个普通的对象。<em>proto</em>的含义是隐式原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p>
<p>所有的构造函数都有prototype类型 指向原型对象<br>通过for…in循环遍历对象，针对上面的那个fn对象，它自身有两个属性：name、printName，另外从原型中找到了第三个属性alertName。现在，如果我们对fn进行遍历，能遍历到两个属性还是三个属性呢？<br>答案：2个，因为高级浏览器已经屏蔽了来自原型的属性，。但是，为了保证代码的健壮性，我们最好自己加上判断，手动将第三个属性屏蔽掉：</p>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>这2个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call和apply时，函数会立即执行<br>都可以用来改变函数的this对象的指向<br>第一个参数都是this要指向的对象(函数执行时，this将指向这个对象)<br>thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。<br>传递一个别的函数名时，函数中的this将指向<strong>这个函数的引用。</strong><br>传递值为数字，布尔值，字符串时,this会指向这些基本类型的包装对象Number,Boolean,String<br>传递一个对象时，函数中的this则指向传递的这个对象。<br>call和apply的区别，<strong>call后面的实参和say方法中是一一对应的，而apply在传递实参时，要封装成一个数组，</strong>数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>call()和apply()的作用<br>改变this的指向<br>实现继承。Father.call(this)<br>bind()<br>都能改变this的指向<br>call()/apply()是<strong>立即调用函数</strong><br>bind()是将函数返回，因此后面还需要加()才能调用。<br>bind传参 xw.say.bind(xh,”实验”,”六年级”)();<br>或者xw.say.bind(xh)(“实验”,”小学”);<br>apply方法xw.say.apply(xh,[“实验小学”,”六年级”]);<br>call方法xw.say.call(xh,”实验小学”,”六年级”);<br>函数赋值给变量时，this指向window<br>var foo1 = args.getInfo;<br>foo1()<br>var foo2 = function() {};<br>foo2();<br>//this都是指向window<br>执行上下文主要有2种情况：<br>全局代码，一段script标签内，有一个全局的执行上下文。所做的事情是：变量定义，函数声明<br>函数代码：每个函数里面有一个上下文，所做的事情是：变量定义、函数声明、this,arguments<br>var定义的为全局变量 =&gt; undefined<br>function声明的全局变量 ===&gt; 赋值fun 添加为window的方法<br>this =&gt; 赋值(window)(<br>函数执行上下文：调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象，(虚拟的，存在于栈中)<br>对局部数据进行预处理<br>形参变量 ===&gt; 赋值(实参) 添加为执行上下文的属性<br>arguments ===&gt; 赋值(实参列表) 添加为执行上下文的属性<br>var 定义的局部变量 ===&gt; undefined 添加为执行上下文的属性<br>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法<br>this ===&gt; 赋值(调用函数的对象)<br>执行上下文栈：<br>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象<br>在全局执行上下文window确定后，将其添加到栈中<br>在函数执行上下文创建之后，将其添加到栈中<br>在当前函数执行完后，将栈顶的对象移除<br>当所有的代码执行完后，栈中只剩下window<br>this指的是，调用函数的那个对象。this永远指向函数运行时所在的对象。<br>解析器在调用函数的时候每次都会向函数内部传递一个隐藏的参数，这个隐藏的参数就是this<br>以函数形式调用,this会指向window<br>以构造函数创建，this是新创建的那个对象<br>使用call和apply调用时，this指向那个对象<br>作用域指一个变量的作用范围，是静态的(相对于上下文对象)<br>全局作用域 函数作用域<br>调用函数时会创建函数作用域，函数执行完毕以后，函数作用域会销毁。<br>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。<br>在函数作用域中可以访问到全局作用域中的变量，在全局作用域中无法访问到函数作用域中的变量。<br><strong>使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明</strong><br>在函数作用域中有效，而且会在函数中所有代码执行前会被声明。<br>全局执行上下文是在全局作用域确定之后，js代码马上执行之前就创建了。<br>函数执行上下文实在调用函数时，<strong>函数体代码执行之前创建</strong><br>作用域是静态的，只要函数定义好就一直存在,且不再变化<br>执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放<br>执行上下文(对象)是从属于所在的作用域<br>全局上下文环境 ===&gt; 全局作用域<br>函数上下文环境 ===&gt; 对应的函数使用域<br>闭包：能够读取其他函数内部数据(变量/函数)的函数<br>因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>object.prototype.toString.call(‘’) 检测类型[object:string]<br>this的值是在执行的时候才能确认，但是不能在定义的时候确认<br>箭头函数this指向：箭头函数没有自己的this,看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this,<br>如果没有，this就是window<br>执行栈认为是一个存储函数调用的结构，遵循先进后出原则。</p>
<h2 id="手写实现ajax"><a href="#手写实现ajax" class="headerlink" title="手写实现ajax"></a>手写实现ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;/api&quot;,false);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<h2 id="动态创建DOM元素的3种方式"><a href="#动态创建DOM元素的3种方式" class="headerlink" title="动态创建DOM元素的3种方式"></a>动态创建DOM元素的3种方式</h2><p>document.write()不常用 因为容易覆盖掉原来的页面<br>innerHTML = () 用的比较多，绑定属性和内容比较方便<br>document.createElement() 用的也比较多，，指定数量的时候一般用它。<br>vue双向绑定原理：通过数据劫持结合发布者-订阅者模式的方式来实现<br>利用object.defineProperty()这个方法重新定义了对象获取属性值(get)和设置属性值(set)。<br>jquery是事件驱动 而其余是数据驱动<br>jquery业务和UI更改混杂在一起，UI里面还涉及交互逻辑，让本来混乱的逻辑更加混乱<br>node js借助事件驱动，非阻塞I/O模型变得更加轻量和高效，非常适合于运行在分布式设备的数据密集型实时应用。<br>offsetWidth和offsetHight<br>offsetWitdh用于检测盒子<strong>自身的宽高+padding+border</strong><br>offsetWidth = width + padding + border;<br>offsetLeft 可以返回没有定位盒子的距离左侧的位置。如果父系盒子中都没有定位，以body为准。<br>style.left 只能获取行内式，如果没有，则返回””（意思是，返回空）;<br>scrollWidth = width + padding;<br>scrollHeight = height + padding;<br>client家族的形成<br>clientWidth:获取盒子区域宽度(padding + width)<br>clientHeight:获取盒子区域高度(padding + height)<br>body/html调用时，<br>clientWidth获取网页可视区域宽度<br>clientHeight获取网页可视区域高度</p>
<p>clientX:event调用：鼠标距离可视区域左侧距离<br>clientY:event调用：鼠标距离可视区域上侧距离</p>
<p>clientTop：盒子的上border。<br>clientLeft：盒子的左border。</p>
<p>宽高：<br>offsetWidth = width + padding + border;<br>offsetHeight = height + padding + border;</p>
<p>window.onresize事件指的是：在窗口或框架被调整大小时发生：<br>window.onscroll()屏幕滑动<br>window.onresize()浏览器大小变化<br><strong>window.onload()页面加载完毕</strong><br>div.onmousemove()鼠标在盒子上移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onresize = function() &#123;</span><br><span class="line">    document.title = window.screen.width + window.screen.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取显示屏的分辨率1920 * 1080<br>jQuery的两大特点 链式编程比如.show和.html可以连写成.show().html()<br>通常情况下：只有设置操作才能把链式编程延续下去，因为获取操作的时候，会返回获取到的相应值，无法返回this.<br>隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。<br>jquery加载完<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dom树生成即可</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>//文档加载完毕，图片不用加载完 写下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>onload是网页全部加载完毕，包括图片,ready只需要dom加载完毕，生成dom树即可</strong><br>通过jquery获取的元素是一个数组 数组中包含着原生JS中的DOM对象<br>通过原生js获取这些元素节点的方式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myBox = document.getElementById(&quot;box&quot;);           //通过 id 获取单个元素</span><br><span class="line">var boxArr = document.getElementsByClassName(&quot;box&quot;);  //通过 class获取的是数组</span><br><span class="line">var divArr = document.getElementsByTagName(&quot;div&quot;);    //通过标签获取的是数组</span><br></pre></td></tr></table></figure></p>
<p>总结：jquery就是把dom对象重新包装了一下，让其具有了jquery方法<br>子代选择器 &gt; 表示儿子 后代选择器  表示全部的都会被选中<br>属性选择器:$(“a[href]”) $(“a[href = ‘itcast’]”)<br>添加类样式<br>$(selector).addClass(“listItem”);<br>删除类样式<br>$(selector).removeClass(“listItem”);<br>判断是否有样式<br>$(selector).hasClass(“listItem”);<br>切换类样式<br>$(selector).toggleClass(“listItem”);<br>有则移除 没有则添加<br>jquery设置和获取属性<br>设置属性attr(“title”,”生命一号”);<br>获取属性attr(“title”);<br>val() 设置或返回form表单元素中的value值<br>$(selector).val();<br>获取文本内容<br>$(selector).text();<br>jquery设置宽度和高度<br>$(selector).height();//不带参数表示获取高度<br>$(selector).height(200);//带参数表示设置高度</p>
<p>$(selector).width();     //不带参数表示获取宽度<br>$(selector).width(200);  //带参数表示设置高宽度</p>
<p>$(“div”).css() //返回的是string类型，例如30px<br>$(“div”).height() 返回的是number类型,30常用于数学计算<br>click是单击事件 blur失去焦点 mouseenter鼠标进入 mouseleave 鼠标离开等<br>解除匹配元素的所有事件<br>$(selector).off()<br>阻止事件冒泡<br>event.stopProgation()<br>阻止默认行为<br>event.preventDefault()<br>$(selector).each(function(index,element){</p>
<p>})<br>参数一表示当前元素所在匹配元素中的索引号，<br>参数而表示当前元素<br>多库共存指的是：jquery占用了$和jquery两个变量，当在同一个页面引用了jquery和其他库时，恰好其他库也使用了jquery或者$<br>,那么要保证多库共用，<br>获取jquery库的版本号console.log($.fn.jquery);<br>办法一：让jquery放弃对$的使用权<br>$.noConflict();<br>办法二：同时放弃2个符号的使用权，并定义一个新的使用权<br>$.noConflict(true);<br>zepto库介绍<br>zepto是轻量级js库，专门为移动端定制<br>与jquery有类似的API,俗称：会jquery就会zepto<br>css3现状<br>浏览器支持程度不够好，有些需要添加私有前缀<br>移动端支持优于PC端<br>不断改进中<br>应用相对广泛<br>过渡:transition 2D转换:transform 3D转换:transform 动画:animation<br>实现不同状态间的平滑过渡<br>transition-property: all; 如果希望所有的属性都发生过渡，就使用all。<br>transition-duration:1s;过渡的持续时间<br>transition-timing-function: linear; 运动曲线<br>transition:all 3s linear 0s;<br>缩放：scale<br>transform:scale(x,y);x轴的缩放和y轴的缩放<br> x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。<br> translate 参数为百分比，表示相对于自身移动<br> 正值：向右和向下 负值：向左和向上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">width:600px;</span><br><span class="line">height:60px;</span><br><span class="line">background-color:red;</span><br><span class="line">position:absolute; 绝对定位</span><br><span class="line">left:50%; 让左边线居中</span><br><span class="line">top:0;</span><br><span class="line">transform:translate(-50%); 然后利用translate,往左走自己一半的宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform:rotate(角度);rotate(45deg); 正值：顺时针 负值：逆时针<br>3D旋转 rotateX,rotateY,rotateZ<br>动画可通过设置多个节点，来精确控制一个或一组动画，常用来实现复杂的动画效果。<br>@keyframes 动画名{<br>    from{初始状态}<br>    to{结束状态}<br>}</p>
<p>@keyframes move1 {<br>            from {<br>                transform: translateX(0px) rotate(0deg);<br>            }<br>            to {<br>                transform: translateX(500px) rotate(555deg);<br>            }<br>        }</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向，从左向右。<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。<br>flex-direction:row;reverse-row; column; reverse-column<br>justify-content:设置子元素在主轴上的对齐方式<br>justify-content:flex-start flex-end center space-around space-between<br>align-items：设置子元素在侧轴上的对齐方式。</p>
<p>align-items:flex-start; 设置子元素在侧轴上的对齐方式。属性值可以是：<br>flex-start 从侧轴开始的方向对齐<br>flex-end 从侧轴结束的方向对齐<br>baseline 基线 默认同flex-start<br>center 中间对齐<br>stretch 拉伸<br>通过window.online来检测用户当前的网络状况，返回一个布尔值。另外：<br>window.online用户网络连接时被调用 window.offline用户网络断开时被调用<br>boostrap标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta = http-equiv = &quot;X-UA-Compatible&quot; content = &quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>解释：设置浏览器的兼容模式版本，表示如果在IE浏览器下则使用最新的标准，渲染当前文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name = &quot;viewport&quot; content = &quot;width=device-width,inital-scale=1.0,user-scalable=no&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>解释：声明当前网页在移动端浏览器中展示的相关位置，我们在做移动 web 开发时，就用上面这行代码设置 viewport。<br>视口的作用：在移动浏览器中，当页面超出设备时，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示。<br>目前大多数手机浏览器视口：宽度都是980<br>此属性为移动端页面视口设置，上方代码设置的值，表示在移动端页面的宽度为设备的宽度，并且不缩放(缩放级别为1)<br>width:设置viewport的宽度 initial-scale:初始化缩放比例 minimum-scale:最小缩放比例 maximum-scale:最大缩放比例<br>user-scalable:是否允许用户手动缩放（值可以写成yes/no，也可以写成1/0）<br>C/S架构和B/S架构<br>是Client/Server这两个单词的首字母，指的是客户端和服务器<br>优点：<br>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可。<br>界面酷炫:客户端可以使用更多系统提供的效果,做出更为炫目的效果。<br>缺点:<br>更新软件：如果有新的功能，就要推出新的版本。<br>不同设备访问：如果使用其他的电脑，没有安装客户端的话就无法登陆软件。<br>B/S架构：浏览器/服务器类型<br>优点：<br>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容，对用户而言只需要刷新浏览器即可。<br>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用。<br>缺点:<br>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小。<br>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一。移动设备兼容性较好，ie6已经越来越少人用了。<br> php代码执行方式：在服务器端执行，然后返回给用户结果，如果直接使用浏览器打开，则会是一串文本<br> 意思：需要浏览器通过http请求，才能够执行php页面。<br> ajax:可以在不刷新页面的情况下，通过ajax方式去获取一些新的内容<br> ajax的核心是js对象：XMLHttpRequest<br> 发送请求<br> open(method,url,async);<br> method 请求的类型 get或post<br> url:文件在服务器上的位置<br> async:true(异步) 或 false(同步)<br> send(string)仅用于post请求<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.php&quot;, true);</span><br><span class="line"></span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line"></span><br><span class="line">xmlhttp.send(&quot;name=smyhvae&amp;age=27&quot;);</span><br></pre></td></tr></table></figure></p>
<p>注册onreadystatechange事件，每当readyState属性改变时，就会调用该事件<br>readyState:0请求未初始化 1服务器建立连接 2请求已接收<br>3请求处理中 4请求已完成<br>200 “OK” 404 “未找到页面”<br>jquery已经封装好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;01.php&quot;,</span><br><span class="line">    data:&quot;name=fox&amp;age=18&apos;,</span><br><span class="line">    type:&quot;GET&quot;,</span><br><span class="line">    success:function()&#123;</span><br><span class="line">     &#125;,</span><br><span class="line">    beforeSend:function()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同源策略：是浏览器的一种安全策略，指的是域名，协议，端口完全相同<br>jsonp 带补丁的json,本质是利用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>标签具有可跨域性，由服务端返回一个预先定义好的js函数的调用，并且将服务器数据以该函数参数的形式传递过来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;  src=&apos;http://192.168.141.137/2018-02-28/myData.php&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/BFC笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/BFC笔记/" itemprop="url">BFC笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T13:16:17+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>formatting context是w3c css2.1规范中的一个概念，是页面中的一块渲染区域，并且有一套渲染规则，他决定了其子元素如何定位，以及和其他元素的关系和相互作用。最常见的便是BFC(块级格式化上下文)<br>是一个独立的渲染区域，只有block-level box参与，规定了内部的block-level box如何布局，并且与这个区域外部毫不相干，通俗的讲，bfc是一个容器，用于管理块级元素。<br>如何创建<br>float为left|right overflow为hidden|auto|display display为table-cell position为absolute 根元素<br>BFC布局规则：内部box在垂直方向，一个一个排列。<br>BFC的区域不会与float box重叠(利用这点可以实现自适应两栏布局)。<br>内部垂直方向距离有margin决定。属于同一个bfc的2个相邻box会发生margin重叠。<br>margin重叠3个条件：同属于一个bfc,相邻，块级元素<br>计算bfc高度时，浮动元素也参与运算。<br>bfc是页面上的一个独立容器，容器内部的子元素不会影响到外部。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/面试笔记-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/面试笔记-1/" itemprop="url">公众号文章-面试经验-面试官需要什么样的人才</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T19:05:14+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面试相关/" itemprop="url" rel="index">
                    <span itemprop="name">面试相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我在阿里做技术面试官的一些经验<br>言川  前端技术优选  3天前<br>戳蓝字「前端技术优选」关注我们哦！</p>
<p>我可能是在同龄人中做面试官经验比较丰富的，在某乎实习的时候就参与了前端的技术面试。后来在阿里以及另一家公司也面试过不少候选人，校招、社招、外包都有面试过。这里以一个面试官的角度来给大家谈谈在面试的时候怎么能给面试官留下更好的印象，更容易拿到大厂的Offer。为了不造成任何面试题泄露，这里我不会涉及到任何具体的面试题。</p>
<p>社招和校招的面试重点<br>社招其实和校招的面试重点有一些区别，以前端为例，社招更看重对前端技术体系的深入理解，以及解决问题的能力。比如对React的实现原理的理解，性能、安全等方面问题。为了避免泄题嫌疑这里就不举具体例子，具体大家可以自行搜索一下。</p>
<p>社招的通常简历中会有很多项目经历，面试官也会挑一两个项目问的比较深入，所以写在简历上的项目一定要自己有比较深的理解，不然面试的时候深入问一下答不上来就会非常不好。</p>
<p>相对的，校招更看重的其实是基本功和学习能力（或者说是潜力）。前端知识更多会考一些基础的JS和CSS，框架的原理方面不会问的很深，数据结构和算法、网络协议等会问的比较多，如果有靠谱的项目/比赛经历也会是考察重点。</p>
<p>还有比较敏感的学历问题，坦白说，如果一个HR/面试官要从成百上千的简历中初步筛选，是没有精力一个个认真看的，学历作为一个重要指标这个时候非常值得参考。而实际情况也是高学历的候选人大部分时候会明显强于低学历的候选人，即使一些人的简历看起来非常华丽。</p>
<p>大厂的面试流程<br>一般阿里腾讯这样的大公司，校招面试的流程是一轮统一笔试+三轮技术面试+一轮HR面试，如果对候选人的水平有争议，技术面试有可能会增加一轮，以2019年春招（实习生招聘）为例：</p>
<p>统一的笔试。</p>
<p>技术初面，一般这一轮都是由你将来同一个团队的比较资深的同事来面试</p>
<p>技术二面，一般是由你的未来主管面试</p>
<p>技术交叉面，一般是其他事业部的主管面试</p>
<p>HR终面，非技术问题</p>
<p>对应届生来说，大厂统一校招前，如果你想进哪一个，一定要关注一下他们的内推信息。内推一般都不用笔试，可以直接参加面试。而且一般内推和统一招聘是分开的，也就是内推挂了依然可以参加统一招聘，多一次机会。当然内推具体会不会影响统招，还是要让内推人确认下。</p>
<p>这里说一下实习生的春招和秋招，春招和秋招都是招第二年毕业的学生，区别是春招签的是实习Offer，秋招会签正式Offer，所以区别大家应该懂得（春招不一定能转正）。</p>
<p>社招一般也是三/四轮技术面+一轮HR面，不过社招很多时候会有一轮是级别比较高的人（总监级）人来面试。</p>
<p>面试前准备<br>首先在面试前一定要花一些时间进行准备，特别是常见的比较典型的面试题要准备一下，避免由于长时间没有接触某一类知识而在面试的时候发挥失常，比如计算机网络、常见的算法等。大部分面试问题都能在网上找到相同类型的，但是想全部找到原题一边不太现实，很多面试官都会有自己准备的题目。比如我在每一次大规模招聘开始的时候，都会花一些时间自己准备几个题目。</p>
<p>然后就是简历一定要认真写，重点突出，最好一页就能写完。三四页的长篇大论一般我都不会认真看。简历中写上去的东西，一定要诚实，不懂得别乱写。技术面试至少有一轮面试官会对着你的简历来问的，如果写的精通实际却解释不清楚，会给面试官非常差的印象，降低整个人的信用。所以简历中写道的项目，如果是很久以前的最好自己再回忆整理一下。</p>
<p>既然简历不能写的太长，那么哪些东西写上去会让面试官特别感兴趣呢？</p>
<p>大型比赛获奖</p>
<p>靠谱的项目/实习经历</p>
<p>开源项目经历</p>
<p>相对的，有一类简历写法会让人比较反感，就是把各种技术名词罗列出来写成一长列，全是熟悉/精通xxxx。不是不能这么写，而是不能写的特别多。没有哪个人是能全部都精通的，如果你这么写了，面试官随便挑两个问一问结果答得不好，那么会觉得你精通的都这个水平，其他肯定更不怎么样。</p>
<p>面试的时候的一些建议<br>面试官和候选人从来不是对立关系，作为面试官非常希望候选人特别优秀，最好面一个人就能直接通过，没有人想在低质量的候选人身上不断浪费时间。所以面试的时候一定要心态放好，不是去被刁难，而是平等的交流。这里说几个我认为比较重要的点：</p>
<p>诚实，确实完全不懂的就直接说不知道，不要装也不要编，面试官的水平一般远高于你，很多时候你以为忽悠过去了，其实面试官只是懒得跟你解释太多而已。</p>
<p>主动发问，如果解决一个问题的时候有一些疑问或者不懂的地方，可以主动问面试官，一般都会给你一些提示。甚至有的题目专门会留一个模棱两可的条件就是希望你能问出来的。发现并提出问题的能力也很重要</p>
<p>不怕错误，不要放弃，即使上一个题目完全错的离谱下一题也要认真对待</p>
<p>不要刻意套近乎，我就很反感上来一口一个“哥”，甚至打听面试官私人问题的</p>
<p>作为面试官，绝大多数人一般都是非常友好的。很多时候一些比较难的问题，都会先抛出一个相对简单的，候选人解决完之后会提出下一个要求，比如限制条件再解决这个问题，或者指出你的实现方式存在的问题然后问你怎么解决。好的面试题通常不是一上来就特别难，而是看起来不算太难，但是随着面试官逐步引导追问会变得越来越难。</p>
<p>很多时候一个复杂的问题在面试的时候本来就很难用一两句话描述清楚，这个时候面试官很可能会故意只进行粗略的描述，希望候选人在读题的时候能自己发现问题并提出来。如果你感觉一个面试题有模棱两可的地方，一定要主动提出来，能给面试官留下很好的印象。</p>
<p>面试的时候不要因为某个题目犯了严重错误就自暴自弃，后面不专心答题了。一个题目结束后调整好心态进行下一题。没有哪一个面试官会因为某一个题目而一票否决候选人，都是面试结束后根据候选人的综合表现来评价的。所以心态放好，即使个别题目错误的离谱，整体评价依然可以做到比较好。</p>
<p>面试结束的时候应该问点什么<br>一般面试快结束的时候，面试官都会问你有没有什么问题想问他的？很多人在这个时候手足无措不知道问些什么好。其实很多问题都可以问，比如：</p>
<p>团队的一些技术栈和所承担的业务</p>
<p>如果通过了未来的工作主要是做什么？</p>
<p>有师兄师姐带我么？公司有没有一些系统的培训？</p>
<p>甚至可以问一些学习的方法</p>
<p>但是切记有一个问题不要问，就是“我能通过这次面试么”，这个问题非常不适合在这里问，不通过的一般也不好当面说，能通过这一轮面试的一般也会其他候选人综合对比，或者有下一轮。</p>
<p>面试结果？<br>面试结束后，如果通过了，正常都会在一周内有回复的，如果等了一周也没有见到回复，那么最好问一下面试你的人，虽然八成是没戏了。如果没有通过面试也不要太灰心，可以加一下面试官的微信，或者让他帮你拉群。很多团队自己为了以后方面抢人，都会有一些招聘群，加进去方便下一次有机会的时候能获得第一手信息。</p>
<p>面试官面试的时候在干嘛<br>这个比较有意思，其实技术面试官都是比较资深的员工，大家平时都很忙的，很多时候面试其实是额外的任务。所以面试的时候，除了和候选人沟通之外，面试官有可能还在同时做自己的事。比如在线编程环节，沟通完题目要求之后，如果候选人埋头写题目不说话，我有时候就会去干别的事，15分钟后才回来看。所以即使写代码的时候最好和面试官保持沟通，说说自己的思路，不懂的地方提出来。不然面试官无聊了可能就去干别的去了。</p>
<p>还有很多面试官在开头会让候选人自我介绍，其实这个时候你只要保持镇定简单说下就好，他八成没听你说的话，正在抓紧时间看你的简历呢。所以我从来不会让人自我介绍，我会在面试开始前先花两分钟看完简历，标记重点要问的问题。甚至个别自己记不清的还要google一下。</p>
<p>最后说一句，无论多少人在说工作难找，优秀的人才总是每个公司都要抢的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/Web前端入门和进阶学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/Web前端入门和进阶学习笔记/" itemprop="url">html,css restful相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-13T22:22:11+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/html相关/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>h1标签有什么作用：<br>正确答案：给文本增加主标题的语义<br>错误答案：给文字加粗，加黑，放大<br>标记：</p><p>称为开始标记 ，</p>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。<br>元素：<p>内容</p>称为元素.<br>属性：给每一个标签所做的辅助信息。<br>xhtml： 符合XML语法标准的HTML。<br>dhtml：dynamic，动态的。javascript + css + html合起来的页面就是一个dhtml。<br>http：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，ftp：文件传输协议。<br>避免乱码：我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型相同，否则乱码(重点)<br>html结构<br>1.声明部分：主要作用是用来告诉浏览器这个页面使用的是哪个标准。&lt;!doctype html&gt;是HTML5标准。<br>2.head部分：将页面的一些额外信息告诉服务器。不会显示在页面上。<br>3.body部分：我们所写的代码必须放在此标签內。<br>1.文档声明头<br>&lt;!DOCTYPE&gt; 文档声明头 DocType Declaration 简称DTD，此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<br>2.头标签<br>title base meta body link<p></p>
<p><title>：指定整个网页的标题，在浏览器最上方显示。</title></p>
<p><base>：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标。</p>
<p><meta>：提供有关页面的基本信息</p>
<p><body>：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。</body></p>
<p><link>：定义文档与外部资源的关系。<br>meta中设置description 即百度搜索结果，就能显示这些语句，表示引擎优化SEO<br>文本级标签p span a b i u em 里面只能放文字，图片，表单元素<br>容器级标签 div h系列，里面能放任何东西<br>div 把标签中的内容当做一个块来对待，必须独占一行<br>span 是不换行的<br>center 代表是一个标签，而不是一个属性值，只要是这个标签的内容，都会居中于浏览器<br>pre 预格式化标签 含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行） 说明：真正排网页过程中，<pre>标签几乎用不着。但在PHP中用于打印一个数组时使用。<br>锚链接：指定超链接起一个名字 作用是在本地或者其他页面的不同位置进行跳转。<br>列表标签<ul> unordered list 表示无序列表 没有1 2 3 只有点<br>有序列表<ol> 有1.2.3标签<br>定义列表dl dl的子元素只能是dt或者dd dt表示标题,dd表示内容<br>表格table 表格由行组成，行由列组成<br>表单标签<form> 用于与服务器的交互，表单就是收集用户信息的，就是让用户填写的、选择的。<br>属性：<br>name：表单的名称，用于JS来操作或控制表单时使用；<br>id：表单的名称，用于JS来操作或控制表单时使用；<br>action：指定表单数据的处理程序，一般是PHP，如：action=“login.php”<br>method：表单数据的提交方式，一般取值：get(默认)和post<br>get提交和post提交的区别：</form></ol></ul></pre></p>
<p>GET方式： 将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。 特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。</p>
<p>POST方式： 将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。 特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。</p>
<p>Enctype： 表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</p>
<p>Application/x-www-form-urlencoded：默认加密方式，除了上传文件之外的数据都可以<br>Multipart/form-data：上传附件时，必须使用这种编码方式。</p>
<h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><p>html的单位只有一种，那就是像素px,所以单位是可以省略的，但是css不一样，css的单位是必须写的，因为它没有默认单位<br>绝对单位<br>1 in = 2.54 cm = 25.4 mm = 72pt = 6 pc<br>in 英寸 pt 点points 或者叫英镑 pc 皮卡<br>相对单位： px：像素<br>em：印刷单位相当于12个点<br> %：百分比，相对周围的文字的大小<br> 单行文本垂直居中<br> 行高 = 盒子搞 默认文字是居中显示的 在行元素内<br> 比如行高24px 字体大小14px 所以padding会计算出来是5px<br> font-family的设置<br> font-family: “Times New Roman”,”微软雅黑”,”宋体”;<br>英语字体放在最前面，所有的中文，就不能匹配英文字体，匹配后面的中文字体<br>行高可以用百分比，表示自豪的百分之多少 一般是大于100%的 因为行高一定大于字号<br>滤镜：让图片变成灰度图的效果<br><img src="3.jpg" style="filter:gray()"><br>常见背景属性有如下几种<br>background-color:#ff99ff;background-image:url(image/2.gif)<br>background-repeat:no-repeat 设置背景图片是否重复以及如何重复 <strong>默认平铺满</strong><br>no-repeat 不要平铺 repeat-x 横向平铺 repeat-y 纵向平铺<br>background-color属性的设置 red rgb(255,0,0) #ff0000<br>css和html结合的3种方式：行内样式表 内嵌样式表 外部样式表<br>外部引入 必须卸载<style>标签中 必须是第一句 @import url(a.css)<br>css 3种基本选择器：标签，类，ID，通用选择器<br>css几种扩展选择器：后代，交集，并集选择器<br>css样式优先级<br>html：超文本标记语言 从语义的角度描述页面<strong>结构</strong><br>css:层叠样式表 从审美的角度负责页面<strong>样式</strong><br>js:从交互的角度描述页面<strong>行为</strong><br>css的注释 /**/ 没有//这种注释</p>
<p><link rel = 'stylesheet'> stylesheet：定义的样式表<br>alternate stylesheet：候选的样式表 表示可以切换 切换成第2种样式 或者第3种<br>标签选择器：针对一类标签 ID选择器：针对某一个特定的标签使用 类选择器：针对你所要的所有标签<br>通用选择器(通配符):针对所有标签都适用(不建议)<br>通配符<em> 匹配任何标签
</em>{<br>    margin-left:0px;<br>    margin-top:0px;<br>}<br>1.后代选择器：定义的时候用空格隔开<br>E F这种格式 表示所有属于E元素的后代的F元素 <strong>选择的是后代 不一定是儿子</strong><br>.div1 p{<br>    color:red;<br>}<br>2.交集选择器<br>h3.special<br>表示必须是h3标签，然后必须是special标签<br>h3.special{<br>    color:red;<br>}</p>
<p><h3 class = "special">标题</h3><br>3种基本选择器都可以放进去<br>3.并集选择器<br>p,h1,#myTitle,.one{<br>    color:red;<br>}<br>IE6的兼容问题(面试要问)<br>1.子代选择器<br>div &gt; p{<br>    color:red;<br>}<br>表示div的儿子P，和后代p完全不同<br>2.序选择器<br>ul找那个的第一个为红色<br>ul li:first-child{<br>    color:red;<br>}<br>3.下一个兄弟选择器<br>+表示选择下一个兄弟<br>h3+p{<br>    color:red;<br>}<br>伪类：同一个标签，根据其不同的状态，有不同的样式，这叫做伪类，伪类用冒号来表示<br>静态伪类：只能用于超链接<br>:link :visited<br>动态伪类:针对所有标签 :hover 悬停 :active 激活 鼠标点击标签，但是不松手时。<br> :focus  某个标签获得焦点 :visited 访问过的 :link 访问之前的<br>css的继承性<br>关于文字的样式，都有继承性，这些属性包括：color、 text-开头的、line-开头的、font-开头的。<br>关于盒子，定位，布局的属性，都不能继承。<br>css的层叠性<br>层叠性：就是处理css处理冲突的能力 所谓权重问题，没有任何兼容问题<br>当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：<br>id &gt; 类 &gt; 标签<br>数权重(id的数量，类的数量，标签的数量)1个个比较下来<br>没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。<br><strong>重要 如果不能直接选中某个元素，而是通过继承性影响的话，那么权重为0</strong><br>将css属性设置为important 来给一个属性提高权重，这个属性的权重就是无限大<br> font-size:60px !important;<br> 只提升一个属性，而不是提升整个选择器的值<br> !important 不能提升权重为0的继承性的值<br> 盒子模型 英文即box model 无论是div span 还是a都是盒子<br>但是图片，表单元素一律看做是文本，它们不是盒子， ，一张图片里并不能放东西，它自己就是自己的内容。<br>盒子:width height内容的高度和宽度<br>padding:内边距 border边框 margin外边框<br>IE盒子模型的content部分包含了border和padding<br>body标签也有margin 整个网页最大的盒子是document 即浏览器 而body是document的儿子 。浏览器给<body>默认的margin大小是8个像素，<br>padding区域也是有颜色的 内边距 和内容区域颜色相同，background-color将填充所有border内部的区域<br>padding的顺序 上右下左 顺时针<br>写3个值 上 右 下 左和右一样<br>写2个值 上和下一样 左和右一样<br>ul自带有40px的padding-left, 使用<em>进行清除
</em>{<br>    margin:0;<br>    padding:0;<br>}<br>body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{<br>    margin:0;<br>    padding:0;<br>}<br>border有3个要素，像素(粗细)，线型，颜色<br>border:10px ridge red;<br>border-witdh,border-style,border-color 一个border属性是由3个小属性组成的。<br>标准文档流<br>特性<br>(1)空白折叠现象 无论多少个空格，换行，tab都会被折叠为一个空格<br>行内元素和块级元素<br>行内元素：1.与其他行内元素并排2.不能设置宽高，默认的宽度，就是文字的宽度<br>块级元素：霸占一行，不能与其他任何元素并列，<br>能接受宽高，如果不设置宽度，宽度默认为父亲的100%<br>文本级:p span a b<br>容器级标签 div h<br>从css角度划分行内元素和块级元素<br>行内元素：除了p之外，所有的文本级标签<br>块级元素：所有的容器级标签都是块级元素 还有p标签<br>将块级元素转化为行内元素<br>display:inline<br>将行内元素转化为块级元素<br>display:block<br>css中一共有3种手段，使一个元素脱离标准文档流<br>(1)浮动(2)绝对定位(3)固定定位<br>float:left表示脱离了文档流<br>行内元素不能设置宽高，但是一旦变成浮动元素，就能设置宽高了<br>清除浮动<br>clear:both 同时清除左边和右边的浮动<br>浏览器hack hack就是黑客，就是使用浏览器提供的后门，针对某一种浏览器做兼容<br>IE6留了一个后面，只要给css属性之前，加上下划线，这个属性就是IE的专有属性<br>背景颜色加上下划线 _background-color:green 所以只有IE才能渲染。<br>margin塌陷/margin重叠<br>标准文档流中，竖直方向的margin不叠加。取较大的<strong>作为margin 水平方向margin是可以叠加的，即水平方向没有塌陷现象。<br>盒子居中的简写:<br>margin:0 auto;表示上下的margin都为0,左右margin尽可能大，于是就居中了。<br>标准流中才能用，脱离的不能用。必须要有width<br>css定位属性有3种，absolute(绝对定位) relative(相对定位) fixed(固定定位)<br>相对定位：让元素相对于自己原来的位置，进行位置调整<br>position:relative;top:50px;left:50px;<br>相对定位：不脱标，老家留坑，别人不会把它的位置挤走。<br>也就是说，</strong>真实位置还在老家，但是影子在到处飘<br>left:盒子右移 right:盒子左移 top:盒子下移 bottom:盒子上移<br>绝对定位：定义横纵坐标，原点在父容器的左上角或者左下角，横坐标用left表示，纵坐标用top或者bottom表示。<br>position:absolute;left:10px;top:20px;<br>绝对定位的盒子脱离了标准文档流。<br>标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。<br>固定定位：就是相对于浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。<br>position:fixed;botton:100px;right:30px;width:60px;height:60px;<br>5.z-index属性，表示谁压着谁，数值大的压盖住数值小的<br>有如下特性：属性值大的位于上层，属性值小的位于下层。<br>超链接<a>的href跳转<br>一个空白的超链接如下<br><a href = ""></a><br>当点击超链接的时候，由于href属性值的不同，可能会产生多种情况<br>href = “” //刷新页面<br>href = “#” //跳转到当前页面的顶部，不会刷新页面<br>href = “javascript:void(0)”//什么都不做<br>href = “javascript:;”//什么都不做<br>sass:css的升级版，可以自定义变量，可以有if语句，还可以嵌套等等，很神奇吧！那下面我们就来介绍返个神奇的 Sass。<br>less/sass是语法，compass是框架，css是目标<br>sass与compass的好处：写出更加优秀的css,解决css编写过程中的痛点问题，<br>compass将sass编译成css<br>.sass 对空格敏感，不使用大括号和分号，所以每个属性通过换行来分割。<br>h1<br>   color:#000<br>   background:#fff<br>.scss的语法 是css语法的超级，可以使用大括号和分号<br>h1{<br>    color:#000;<br>    background:#fff;<br>}<br>sass通过$符号来声明变量<br>$font1:Arial;<br>@import “variables”;<br>.div1{<br>    font-family:$font1;<br>}<br>.div2{<br>    font-family:$font2;<br>}<br>mixin sass中可用mixin定义一些代码片段，且可以传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。<br>@mixin box-sizing($sizing){<br>    -webkit-box-sizing:$sizing;<br>    -moz-box-sizing:$sizing;<br>    box-sizing:$sizing;<br>}<br>.box-border{<br>    border:1px solid #ccc;<br>    @include box-sizing(border-box);<br>}</p>
</style></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/jquery面试题目/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/jquery面试题目/" itemprop="url">jquery面试题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T10:04:25+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/" itemprop="url" rel="index">
                    <span itemprop="name">jquery相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jquery判断页面是否加载完毕<br>原生js方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jquery的ready方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.onreadystatechange = function() &#123;</span><br><span class="line">    if(document.readyState == &apos;complete&apos;)&#123;</span><br><span class="line">        document.getElementById(&quot;#div&quot;).style.display = &quot;none&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ready函数在文档进入ready状态时执行代码，当dom完全加载完，jquery允许执行代码，它适用于所有的浏览器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>window.onload与jquery的ready函数区别<br>window.onload除了要等待dom被创建还需要等待包括图片，音频，视频内的所有外部资源都被完全加载，<br>如果加载图片和媒体资源内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。<br>另一方面，jquery ready函数只需要dom树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快，使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。<br><a href="https://www.cnblogs.com/mehjb/p/6095230.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.imooc.com/code/3247" target="_blank" rel="noopener">慕课地址</a><br><a href="https://www.cnblogs.com/hrw3c/p/5304849.html" target="_blank" rel="noopener">jquery源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/jquery源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/jquery源码解析/" itemprop="url">jquery源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T09:47:32+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/" itemprop="url" rel="index">
                    <span itemprop="name">jquery相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jquery2.0以及后续版本将不再支持IE 6/7/8浏览器<br>jquery采用一个匿名构造函数立即执行的方法<br>整个模块化便是如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function(global, factory)&#123;</span><br><span class="line">    if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) &#123;</span><br><span class="line">    //模块化环境</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        factory( global );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(typeof window !== &quot;undefined&quot; ? window: this, function(window, noGlobal) &#123;</span><br><span class="line">    //回调函数</span><br><span class="line"></span><br><span class="line">    if ( typeof noGlobal === strundefined ) &#123;</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    return jQuery;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>接收2个参数，global(当前执行作用域链的对象),factory(回调)<br>匿名函数：本身做了一个初始化的判断，判断当前js是否使用了模块化开发，。如果是再做一些相应的逻辑处理<br>回调函数：factory所有的jquery方法属性都是在这个回调函数里面实现的最后一行代码，就是向外暴露接口。<br>整体架构如下:<br><img src="/images/jquery1.jpg" width="50%" height="50%"><br>如今jQuery库，一共13个模块，模块不是单一的<br>jquery采用AMD进行模块化开发<br>可以分为五大模块，选择器，DOM操作，事件，ajax与动画，<br>jquery可以抽出共同的特性并且使之模块化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/移动端适配问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/移动端适配问题/" itemprop="url">移动端适配问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T09:33:35+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端适配问题/" itemprop="url" rel="index">
                    <span itemprop="name">移动端适配问题</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端适配问题/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>移动端的适配问题 主要有以下几个<br>1.1px问题<br>2.UI图完美适配方案<br>3.iPhoneX适配访问<br>4.横屏适配<br>5.高清屏图片模糊问题<br>像素，分辨率，PPI,DPI,DP,DIP,DPR,视口等概念</p>
<h2 id="1-英寸"><a href="#1-英寸" class="headerlink" title="1.英寸"></a>1.英寸</h2><p>一般用英寸描述屏幕的物理大小，例如电脑的17,22英寸，手机显示的4.8,5.7英寸等。<br>需要注意，<strong>上面的尺寸是屏幕对角线的长度</strong><br>1英寸 = 2.54厘米<br><img src="/shipei/01.png" width="50%" height="50%"> </p>
<h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2.分辨率"></a>2.分辨率</h2><p>像素即一个小方块，具有特定的位置和颜色。<br>图片，电子屏幕等就是由无数个具有特定位置的小方块组成的。</p>
<h3 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h3><p>一个屏幕具体由多少个像素点组成<br>iphone xs max 为2688 <em> 1242<br>iphone se 为 1136 </em> 640</p>
<h3 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h3><p>图像分辨率也指图片含有的像素数</p>
<h3 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h3><p>PPI指的是每英寸包括的像素数<br>PPI可以用于描述屏幕的清晰度以及一张图片的质量。<br>使用PPI描述时，PPI越高，图片质量越高。<br><a href="https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ" target="_blank" rel="noopener">超链接</a><br>常用有flexible布局，媒体查询和vw,vh方案</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KevinSwift">
            
              <p class="site-author-name" itemprop="name">KevinSwift</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinSwift</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
