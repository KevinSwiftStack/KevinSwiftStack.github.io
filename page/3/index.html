<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="KevinSwift">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="KevinSwift">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KevinSwift">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>KevinSwift</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KevinSwift</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
            相册
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/14/面试笔记-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/14/面试笔记-1/" itemprop="url">公众号文章-面试经验-面试官需要什么样的人才</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-14T19:05:14+08:00">
                2019-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/面试相关/" itemprop="url" rel="index">
                    <span itemprop="name">面试相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我在阿里做技术面试官的一些经验<br>言川  前端技术优选  3天前<br>戳蓝字「前端技术优选」关注我们哦！</p>
<p>我可能是在同龄人中做面试官经验比较丰富的，在某乎实习的时候就参与了前端的技术面试。后来在阿里以及另一家公司也面试过不少候选人，校招、社招、外包都有面试过。这里以一个面试官的角度来给大家谈谈在面试的时候怎么能给面试官留下更好的印象，更容易拿到大厂的Offer。为了不造成任何面试题泄露，这里我不会涉及到任何具体的面试题。</p>
<p>社招和校招的面试重点<br>社招其实和校招的面试重点有一些区别，以前端为例，社招更看重对前端技术体系的深入理解，以及解决问题的能力。比如对React的实现原理的理解，性能、安全等方面问题。为了避免泄题嫌疑这里就不举具体例子，具体大家可以自行搜索一下。</p>
<p>社招的通常简历中会有很多项目经历，面试官也会挑一两个项目问的比较深入，所以写在简历上的项目一定要自己有比较深的理解，不然面试的时候深入问一下答不上来就会非常不好。</p>
<p>相对的，校招更看重的其实是基本功和学习能力（或者说是潜力）。前端知识更多会考一些基础的JS和CSS，框架的原理方面不会问的很深，数据结构和算法、网络协议等会问的比较多，如果有靠谱的项目/比赛经历也会是考察重点。</p>
<p>还有比较敏感的学历问题，坦白说，如果一个HR/面试官要从成百上千的简历中初步筛选，是没有精力一个个认真看的，学历作为一个重要指标这个时候非常值得参考。而实际情况也是高学历的候选人大部分时候会明显强于低学历的候选人，即使一些人的简历看起来非常华丽。</p>
<p>大厂的面试流程<br>一般阿里腾讯这样的大公司，校招面试的流程是一轮统一笔试+三轮技术面试+一轮HR面试，如果对候选人的水平有争议，技术面试有可能会增加一轮，以2019年春招（实习生招聘）为例：</p>
<p>统一的笔试。</p>
<p>技术初面，一般这一轮都是由你将来同一个团队的比较资深的同事来面试</p>
<p>技术二面，一般是由你的未来主管面试</p>
<p>技术交叉面，一般是其他事业部的主管面试</p>
<p>HR终面，非技术问题</p>
<p>对应届生来说，大厂统一校招前，如果你想进哪一个，一定要关注一下他们的内推信息。内推一般都不用笔试，可以直接参加面试。而且一般内推和统一招聘是分开的，也就是内推挂了依然可以参加统一招聘，多一次机会。当然内推具体会不会影响统招，还是要让内推人确认下。</p>
<p>这里说一下实习生的春招和秋招，春招和秋招都是招第二年毕业的学生，区别是春招签的是实习Offer，秋招会签正式Offer，所以区别大家应该懂得（春招不一定能转正）。</p>
<p>社招一般也是三/四轮技术面+一轮HR面，不过社招很多时候会有一轮是级别比较高的人（总监级）人来面试。</p>
<p>面试前准备<br>首先在面试前一定要花一些时间进行准备，特别是常见的比较典型的面试题要准备一下，避免由于长时间没有接触某一类知识而在面试的时候发挥失常，比如计算机网络、常见的算法等。大部分面试问题都能在网上找到相同类型的，但是想全部找到原题一边不太现实，很多面试官都会有自己准备的题目。比如我在每一次大规模招聘开始的时候，都会花一些时间自己准备几个题目。</p>
<p>然后就是简历一定要认真写，重点突出，最好一页就能写完。三四页的长篇大论一般我都不会认真看。简历中写上去的东西，一定要诚实，不懂得别乱写。技术面试至少有一轮面试官会对着你的简历来问的，如果写的精通实际却解释不清楚，会给面试官非常差的印象，降低整个人的信用。所以简历中写道的项目，如果是很久以前的最好自己再回忆整理一下。</p>
<p>既然简历不能写的太长，那么哪些东西写上去会让面试官特别感兴趣呢？</p>
<p>大型比赛获奖</p>
<p>靠谱的项目/实习经历</p>
<p>开源项目经历</p>
<p>相对的，有一类简历写法会让人比较反感，就是把各种技术名词罗列出来写成一长列，全是熟悉/精通xxxx。不是不能这么写，而是不能写的特别多。没有哪个人是能全部都精通的，如果你这么写了，面试官随便挑两个问一问结果答得不好，那么会觉得你精通的都这个水平，其他肯定更不怎么样。</p>
<p>面试的时候的一些建议<br>面试官和候选人从来不是对立关系，作为面试官非常希望候选人特别优秀，最好面一个人就能直接通过，没有人想在低质量的候选人身上不断浪费时间。所以面试的时候一定要心态放好，不是去被刁难，而是平等的交流。这里说几个我认为比较重要的点：</p>
<p>诚实，确实完全不懂的就直接说不知道，不要装也不要编，面试官的水平一般远高于你，很多时候你以为忽悠过去了，其实面试官只是懒得跟你解释太多而已。</p>
<p>主动发问，如果解决一个问题的时候有一些疑问或者不懂的地方，可以主动问面试官，一般都会给你一些提示。甚至有的题目专门会留一个模棱两可的条件就是希望你能问出来的。发现并提出问题的能力也很重要</p>
<p>不怕错误，不要放弃，即使上一个题目完全错的离谱下一题也要认真对待</p>
<p>不要刻意套近乎，我就很反感上来一口一个“哥”，甚至打听面试官私人问题的</p>
<p>作为面试官，绝大多数人一般都是非常友好的。很多时候一些比较难的问题，都会先抛出一个相对简单的，候选人解决完之后会提出下一个要求，比如限制条件再解决这个问题，或者指出你的实现方式存在的问题然后问你怎么解决。好的面试题通常不是一上来就特别难，而是看起来不算太难，但是随着面试官逐步引导追问会变得越来越难。</p>
<p>很多时候一个复杂的问题在面试的时候本来就很难用一两句话描述清楚，这个时候面试官很可能会故意只进行粗略的描述，希望候选人在读题的时候能自己发现问题并提出来。如果你感觉一个面试题有模棱两可的地方，一定要主动提出来，能给面试官留下很好的印象。</p>
<p>面试的时候不要因为某个题目犯了严重错误就自暴自弃，后面不专心答题了。一个题目结束后调整好心态进行下一题。没有哪一个面试官会因为某一个题目而一票否决候选人，都是面试结束后根据候选人的综合表现来评价的。所以心态放好，即使个别题目错误的离谱，整体评价依然可以做到比较好。</p>
<p>面试结束的时候应该问点什么<br>一般面试快结束的时候，面试官都会问你有没有什么问题想问他的？很多人在这个时候手足无措不知道问些什么好。其实很多问题都可以问，比如：</p>
<p>团队的一些技术栈和所承担的业务</p>
<p>如果通过了未来的工作主要是做什么？</p>
<p>有师兄师姐带我么？公司有没有一些系统的培训？</p>
<p>甚至可以问一些学习的方法</p>
<p>但是切记有一个问题不要问，就是“我能通过这次面试么”，这个问题非常不适合在这里问，不通过的一般也不好当面说，能通过这一轮面试的一般也会其他候选人综合对比，或者有下一轮。</p>
<p>面试结果？<br>面试结束后，如果通过了，正常都会在一周内有回复的，如果等了一周也没有见到回复，那么最好问一下面试你的人，虽然八成是没戏了。如果没有通过面试也不要太灰心，可以加一下面试官的微信，或者让他帮你拉群。很多团队自己为了以后方面抢人，都会有一些招聘群，加进去方便下一次有机会的时候能获得第一手信息。</p>
<p>面试官面试的时候在干嘛<br>这个比较有意思，其实技术面试官都是比较资深的员工，大家平时都很忙的，很多时候面试其实是额外的任务。所以面试的时候，除了和候选人沟通之外，面试官有可能还在同时做自己的事。比如在线编程环节，沟通完题目要求之后，如果候选人埋头写题目不说话，我有时候就会去干别的事，15分钟后才回来看。所以即使写代码的时候最好和面试官保持沟通，说说自己的思路，不懂的地方提出来。不然面试官无聊了可能就去干别的去了。</p>
<p>还有很多面试官在开头会让候选人自我介绍，其实这个时候你只要保持镇定简单说下就好，他八成没听你说的话，正在抓紧时间看你的简历呢。所以我从来不会让人自我介绍，我会在面试开始前先花两分钟看完简历，标记重点要问的问题。甚至个别自己记不清的还要google一下。</p>
<p>最后说一句，无论多少人在说工作难找，优秀的人才总是每个公司都要抢的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/13/Web前端入门和进阶学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/Web前端入门和进阶学习笔记/" itemprop="url">html,css restful相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-13T22:22:11+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/html相关/css相关/" itemprop="url" rel="index">
                    <span itemprop="name">css相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>h1标签有什么作用：<br>正确答案：给文本增加主标题的语义<br>错误答案：给文字加粗，加黑，放大<br>标记：</p><p>称为开始标记 ，</p>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。<br>元素：<p>内容</p>称为元素.<br>属性：给每一个标签所做的辅助信息。<br>xhtml： 符合XML语法标准的HTML。<br>dhtml：dynamic，动态的。javascript + css + html合起来的页面就是一个dhtml。<br>http：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，ftp：文件传输协议。<br>避免乱码：我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型相同，否则乱码(重点)<br>html结构<br>1.声明部分：主要作用是用来告诉浏览器这个页面使用的是哪个标准。&lt;!doctype html&gt;是HTML5标准。<br>2.head部分：将页面的一些额外信息告诉服务器。不会显示在页面上。<br>3.body部分：我们所写的代码必须放在此标签內。<br>1.文档声明头<br>&lt;!DOCTYPE&gt; 文档声明头 DocType Declaration 简称DTD，此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。<br>2.头标签<br>title base meta body link<p></p>
<p><title>：指定整个网页的标题，在浏览器最上方显示。</title></p>
<p><base>：为页面上的所有链接规标题栏显示的内容定默认地址或默认目标。</p>
<p><meta>：提供有关页面的基本信息</p>
<p><body>：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。</body></p>
<p><link>：定义文档与外部资源的关系。<br>meta中设置description 即百度搜索结果，就能显示这些语句，表示引擎优化SEO<br>文本级标签p span a b i u em 里面只能放文字，图片，表单元素<br>容器级标签 div h系列，里面能放任何东西<br>div 把标签中的内容当做一个块来对待，必须独占一行<br>span 是不换行的<br>center 代表是一个标签，而不是一个属性值，只要是这个标签的内容，都会居中于浏览器<br>pre 预格式化标签 含义：将保留其中的所有的空白字符(空格、换行符)，原封不动的输出结果（告诉浏览器不要忽略空格和空行） 说明：真正排网页过程中，<pre>标签几乎用不着。但在PHP中用于打印一个数组时使用。<br>锚链接：指定超链接起一个名字 作用是在本地或者其他页面的不同位置进行跳转。<br>列表标签<ul> unordered list 表示无序列表 没有1 2 3 只有点<br>有序列表<ol> 有1.2.3标签<br>定义列表dl dl的子元素只能是dt或者dd dt表示标题,dd表示内容<br>表格table 表格由行组成，行由列组成<br>表单标签<form> 用于与服务器的交互，表单就是收集用户信息的，就是让用户填写的、选择的。<br>属性：<br>name：表单的名称，用于JS来操作或控制表单时使用；<br>id：表单的名称，用于JS来操作或控制表单时使用；<br>action：指定表单数据的处理程序，一般是PHP，如：action=“login.php”<br>method：表单数据的提交方式，一般取值：get(默认)和post<br>get提交和post提交的区别：</form></ol></ul></pre></p>
<p>GET方式： 将表单数据，以”name=value”形式追加到action指定的处理程序的后面，两者间用”?”隔开，每一个表单的”name=value”间用”&amp;”号隔开。 特点：只适合提交少量信息，并且不太安全(不要提交敏感数据)、提交的数据类型只限于ASCII字符。</p>
<p>POST方式： 将表单数据直接发送(隐藏)到action指定的处理程序。POST发送的数据不可见。Action指定的处理程序可以获取到表单数据。 特点：可以提交海量信息，相对来说安全一些，提交的数据格式是多样的(Word、Excel、rar、img)。</p>
<p>Enctype： 表单数据的编码方式(加密方式)，取值可以是：application/x-www-form-urlencoded、multipart/form-data。Enctype只能在POST方式下使用。</p>
<p>Application/x-www-form-urlencoded：默认加密方式，除了上传文件之外的数据都可以<br>Multipart/form-data：上传附件时，必须使用这种编码方式。</p>
<h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><p>html的单位只有一种，那就是像素px,所以单位是可以省略的，但是css不一样，css的单位是必须写的，因为它没有默认单位<br>绝对单位<br>1 in = 2.54 cm = 25.4 mm = 72pt = 6 pc<br>in 英寸 pt 点points 或者叫英镑 pc 皮卡<br>相对单位： px：像素<br>em：印刷单位相当于12个点<br> %：百分比，相对周围的文字的大小<br> 单行文本垂直居中<br> 行高 = 盒子搞 默认文字是居中显示的 在行元素内<br> 比如行高24px 字体大小14px 所以padding会计算出来是5px<br> font-family的设置<br> font-family: “Times New Roman”,”微软雅黑”,”宋体”;<br>英语字体放在最前面，所有的中文，就不能匹配英文字体，匹配后面的中文字体<br>行高可以用百分比，表示自豪的百分之多少 一般是大于100%的 因为行高一定大于字号<br>滤镜：让图片变成灰度图的效果<br><img src="3.jpg" style="filter:gray()"><br>常见背景属性有如下几种<br>background-color:#ff99ff;background-image:url(image/2.gif)<br>background-repeat:no-repeat 设置背景图片是否重复以及如何重复 <strong>默认平铺满</strong><br>no-repeat 不要平铺 repeat-x 横向平铺 repeat-y 纵向平铺<br>background-color属性的设置 red rgb(255,0,0) #ff0000<br>css和html结合的3种方式：行内样式表 内嵌样式表 外部样式表<br>外部引入 必须卸载<style>标签中 必须是第一句 @import url(a.css)<br>css 3种基本选择器：标签，类，ID，通用选择器<br>css几种扩展选择器：后代，交集，并集选择器<br>css样式优先级<br>html：超文本标记语言 从语义的角度描述页面<strong>结构</strong><br>css:层叠样式表 从审美的角度负责页面<strong>样式</strong><br>js:从交互的角度描述页面<strong>行为</strong><br>css的注释 /**/ 没有//这种注释</p>
<p><link rel = 'stylesheet'> stylesheet：定义的样式表<br>alternate stylesheet：候选的样式表 表示可以切换 切换成第2种样式 或者第3种<br>标签选择器：针对一类标签 ID选择器：针对某一个特定的标签使用 类选择器：针对你所要的所有标签<br>通用选择器(通配符):针对所有标签都适用(不建议)<br>通配符<em> 匹配任何标签
</em>{<br>    margin-left:0px;<br>    margin-top:0px;<br>}<br>1.后代选择器：定义的时候用空格隔开<br>E F这种格式 表示所有属于E元素的后代的F元素 <strong>选择的是后代 不一定是儿子</strong><br>.div1 p{<br>    color:red;<br>}<br>2.交集选择器<br>h3.special<br>表示必须是h3标签，然后必须是special标签<br>h3.special{<br>    color:red;<br>}</p>
<p><h3 class = "special">标题</h3><br>3种基本选择器都可以放进去<br>3.并集选择器<br>p,h1,#myTitle,.one{<br>    color:red;<br>}<br>IE6的兼容问题(面试要问)<br>1.子代选择器<br>div &gt; p{<br>    color:red;<br>}<br>表示div的儿子P，和后代p完全不同<br>2.序选择器<br>ul找那个的第一个为红色<br>ul li:first-child{<br>    color:red;<br>}<br>3.下一个兄弟选择器<br>+表示选择下一个兄弟<br>h3+p{<br>    color:red;<br>}<br>伪类：同一个标签，根据其不同的状态，有不同的样式，这叫做伪类，伪类用冒号来表示<br>静态伪类：只能用于超链接<br>:link :visited<br>动态伪类:针对所有标签 :hover 悬停 :active 激活 鼠标点击标签，但是不松手时。<br> :focus  某个标签获得焦点 :visited 访问过的 :link 访问之前的<br>css的继承性<br>关于文字的样式，都有继承性，这些属性包括：color、 text-开头的、line-开头的、font-开头的。<br>关于盒子，定位，布局的属性，都不能继承。<br>css的层叠性<br>层叠性：就是处理css处理冲突的能力 所谓权重问题，没有任何兼容问题<br>当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：<br>id &gt; 类 &gt; 标签<br>数权重(id的数量，类的数量，标签的数量)1个个比较下来<br>没有选择上，通过继承影响的，就近原则，谁描述的近听谁的。如果描述的一样近，比如选择器权重，如果权重再一样重，谁写在后面听谁的。<br><strong>重要 如果不能直接选中某个元素，而是通过继承性影响的话，那么权重为0</strong><br>将css属性设置为important 来给一个属性提高权重，这个属性的权重就是无限大<br> font-size:60px !important;<br> 只提升一个属性，而不是提升整个选择器的值<br> !important 不能提升权重为0的继承性的值<br> 盒子模型 英文即box model 无论是div span 还是a都是盒子<br>但是图片，表单元素一律看做是文本，它们不是盒子， ，一张图片里并不能放东西，它自己就是自己的内容。<br>盒子:width height内容的高度和宽度<br>padding:内边距 border边框 margin外边框<br>IE盒子模型的content部分包含了border和padding<br>body标签也有margin 整个网页最大的盒子是document 即浏览器 而body是document的儿子 。浏览器给<body>默认的margin大小是8个像素，<br>padding区域也是有颜色的 内边距 和内容区域颜色相同，background-color将填充所有border内部的区域<br>padding的顺序 上右下左 顺时针<br>写3个值 上 右 下 左和右一样<br>写2个值 上和下一样 左和右一样<br>ul自带有40px的padding-left, 使用<em>进行清除
</em>{<br>    margin:0;<br>    padding:0;<br>}<br>body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{<br>    margin:0;<br>    padding:0;<br>}<br>border有3个要素，像素(粗细)，线型，颜色<br>border:10px ridge red;<br>border-witdh,border-style,border-color 一个border属性是由3个小属性组成的。<br>标准文档流<br>特性<br>(1)空白折叠现象 无论多少个空格，换行，tab都会被折叠为一个空格<br>行内元素和块级元素<br>行内元素：1.与其他行内元素并排2.不能设置宽高，默认的宽度，就是文字的宽度<br>块级元素：霸占一行，不能与其他任何元素并列，<br>能接受宽高，如果不设置宽度，宽度默认为父亲的100%<br>文本级:p span a b<br>容器级标签 div h<br>从css角度划分行内元素和块级元素<br>行内元素：除了p之外，所有的文本级标签<br>块级元素：所有的容器级标签都是块级元素 还有p标签<br>将块级元素转化为行内元素<br>display:inline<br>将行内元素转化为块级元素<br>display:block<br>css中一共有3种手段，使一个元素脱离标准文档流<br>(1)浮动(2)绝对定位(3)固定定位<br>float:left表示脱离了文档流<br>行内元素不能设置宽高，但是一旦变成浮动元素，就能设置宽高了<br>清除浮动<br>clear:both 同时清除左边和右边的浮动<br>浏览器hack hack就是黑客，就是使用浏览器提供的后门，针对某一种浏览器做兼容<br>IE6留了一个后面，只要给css属性之前，加上下划线，这个属性就是IE的专有属性<br>背景颜色加上下划线 _background-color:green 所以只有IE才能渲染。<br>margin塌陷/margin重叠<br>标准文档流中，竖直方向的margin不叠加。取较大的<strong>作为margin 水平方向margin是可以叠加的，即水平方向没有塌陷现象。<br>盒子居中的简写:<br>margin:0 auto;表示上下的margin都为0,左右margin尽可能大，于是就居中了。<br>标准流中才能用，脱离的不能用。必须要有width<br>css定位属性有3种，absolute(绝对定位) relative(相对定位) fixed(固定定位)<br>相对定位：让元素相对于自己原来的位置，进行位置调整<br>position:relative;top:50px;left:50px;<br>相对定位：不脱标，老家留坑，别人不会把它的位置挤走。<br>也就是说，</strong>真实位置还在老家，但是影子在到处飘<br>left:盒子右移 right:盒子左移 top:盒子下移 bottom:盒子上移<br>绝对定位：定义横纵坐标，原点在父容器的左上角或者左下角，横坐标用left表示，纵坐标用top或者bottom表示。<br>position:absolute;left:10px;top:20px;<br>绝对定位的盒子脱离了标准文档流。<br>标签就不区分所谓的行内元素、块级元素了，不需要display:block就可以设置宽、高了。<br>固定定位：就是相对于浏览器窗口进行定位。无论页面如何滚动，这个盒子显示的位置不变。<br>position:fixed;botton:100px;right:30px;width:60px;height:60px;<br>5.z-index属性，表示谁压着谁，数值大的压盖住数值小的<br>有如下特性：属性值大的位于上层，属性值小的位于下层。<br>超链接<a>的href跳转<br>一个空白的超链接如下<br><a href = ""></a><br>当点击超链接的时候，由于href属性值的不同，可能会产生多种情况<br>href = “” //刷新页面<br>href = “#” //跳转到当前页面的顶部，不会刷新页面<br>href = “javascript:void(0)”//什么都不做<br>href = “javascript:;”//什么都不做<br>sass:css的升级版，可以自定义变量，可以有if语句，还可以嵌套等等，很神奇吧！那下面我们就来介绍返个神奇的 Sass。<br>less/sass是语法，compass是框架，css是目标<br>sass与compass的好处：写出更加优秀的css,解决css编写过程中的痛点问题，<br>compass将sass编译成css<br>.sass 对空格敏感，不使用大括号和分号，所以每个属性通过换行来分割。<br>h1<br>   color:#000<br>   background:#fff<br>.scss的语法 是css语法的超级，可以使用大括号和分号<br>h1{<br>    color:#000;<br>    background:#fff;<br>}<br>sass通过$符号来声明变量<br>$font1:Arial;<br>@import “variables”;<br>.div1{<br>    font-family:$font1;<br>}<br>.div2{<br>    font-family:$font2;<br>}<br>mixin sass中可用mixin定义一些代码片段，且可以传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。<br>@mixin box-sizing($sizing){<br>    -webkit-box-sizing:$sizing;<br>    -moz-box-sizing:$sizing;<br>    box-sizing:$sizing;<br>}<br>.box-border{<br>    border:1px solid #ccc;<br>    @include box-sizing(border-box);<br>}</p>
</style></p>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/jquery面试题目/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/jquery面试题目/" itemprop="url">jquery面试题目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T10:04:25+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/" itemprop="url" rel="index">
                    <span itemprop="name">jquery相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jquery判断页面是否加载完毕<br>原生js方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>jquery的ready方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.onreadystatechange = function() &#123;</span><br><span class="line">    if(document.readyState == &apos;complete&apos;)&#123;</span><br><span class="line">        document.getElementById(&quot;#div&quot;).style.display = &quot;none&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ready函数在文档进入ready状态时执行代码，当dom完全加载完，jquery允许执行代码，它适用于所有的浏览器，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>window.onload与jquery的ready函数区别<br>window.onload除了要等待dom被创建还需要等待包括图片，音频，视频内的所有外部资源都被完全加载，<br>如果加载图片和媒体资源内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。<br>另一方面，jquery ready函数只需要dom树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快，使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。<br><a href="https://www.cnblogs.com/mehjb/p/6095230.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://www.imooc.com/code/3247" target="_blank" rel="noopener">慕课地址</a><br><a href="https://www.cnblogs.com/hrw3c/p/5304849.html" target="_blank" rel="noopener">jquery源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/jquery源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/jquery源码解析/" itemprop="url">jquery源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T09:47:32+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/" itemprop="url" rel="index">
                    <span itemprop="name">jquery相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery相关/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jquery2.0以及后续版本将不再支持IE 6/7/8浏览器<br>jquery采用一个匿名构造函数立即执行的方法<br>整个模块化便是如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function(global, factory)&#123;</span><br><span class="line">    if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) &#123;</span><br><span class="line">    //模块化环境</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        factory( global );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(typeof window !== &quot;undefined&quot; ? window: this, function(window, noGlobal) &#123;</span><br><span class="line">    //回调函数</span><br><span class="line"></span><br><span class="line">    if ( typeof noGlobal === strundefined ) &#123;</span><br><span class="line">        window.jQuery = window.$ = jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    return jQuery;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>接收2个参数，global(当前执行作用域链的对象),factory(回调)<br>匿名函数：本身做了一个初始化的判断，判断当前js是否使用了模块化开发，。如果是再做一些相应的逻辑处理<br>回调函数：factory所有的jquery方法属性都是在这个回调函数里面实现的最后一行代码，就是向外暴露接口。<br>整体架构如下:<br><img src="/images/jquery1.jpg" width="50%" height="50%"><br>如今jQuery库，一共13个模块，模块不是单一的<br>jquery采用AMD进行模块化开发<br>可以分为五大模块，选择器，DOM操作，事件，ajax与动画，<br>jquery可以抽出共同的特性并且使之模块化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/移动端适配问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/移动端适配问题/" itemprop="url">移动端适配问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T09:33:35+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端适配问题/" itemprop="url" rel="index">
                    <span itemprop="name">移动端适配问题</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/移动端适配问题/html相关/" itemprop="url" rel="index">
                    <span itemprop="name">html相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>移动端的适配问题 主要有以下几个<br>1.1px问题<br>2.UI图完美适配方案<br>3.iPhoneX适配访问<br>4.横屏适配<br>5.高清屏图片模糊问题<br>像素，分辨率，PPI,DPI,DP,DIP,DPR,视口等概念</p>
<h2 id="1-英寸"><a href="#1-英寸" class="headerlink" title="1.英寸"></a>1.英寸</h2><p>一般用英寸描述屏幕的物理大小，例如电脑的17,22英寸，手机显示的4.8,5.7英寸等。<br>需要注意，<strong>上面的尺寸是屏幕对角线的长度</strong><br>1英寸 = 2.54厘米<br><img src="/shipei/01.png" width="50%" height="50%"> </p>
<h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2.分辨率"></a>2.分辨率</h2><p>像素即一个小方块，具有特定的位置和颜色。<br>图片，电子屏幕等就是由无数个具有特定位置的小方块组成的。</p>
<h3 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h3><p>一个屏幕具体由多少个像素点组成<br>iphone xs max 为2688 <em> 1242<br>iphone se 为 1136 </em> 640</p>
<h3 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h3><p>图像分辨率也指图片含有的像素数</p>
<h3 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h3><p>PPI指的是每英寸包括的像素数<br>PPI可以用于描述屏幕的清晰度以及一张图片的质量。<br>使用PPI描述时，PPI越高，图片质量越高。<br><a href="https://mp.weixin.qq.com/s/oF6oAjdzguv9OwE9cdLrPQ" target="_blank" rel="noopener">超链接</a><br>常用有flexible布局，媒体查询和vw,vh方案</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/牛客前端面试笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/牛客前端面试笔记/" itemprop="url">牛客前端面经笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T22:35:59+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="http与浏览器1"><a href="#http与浏览器1" class="headerlink" title="http与浏览器1"></a>http与浏览器1</h3><p>http的ssl加密是在<strong>传输层</strong>实现的<br>http 超文本传输协议。客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>https:以安全为目标的http通道。http的安全版。http加入了ssl层。<br>区别：<br>http传输的数据都是明文的，未加密的。https由http和ssl构成。<br>ssl进行加密传输和身份认证。<br>https需要ca证书。<br><strong> 端口不一致 http是80端口,https是443端口。<br>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。<br>https优点：认证用户和服务器。确保数据安全的传送。<br>缺点:握手阶段较费时。缓存不高。<br>重点掌握 </strong><br><strong>tcp三次握手</strong><br>tcp和udp区别。<br>tcp面向连接。udp是无连接的。<br>tcp提供可靠服务，udp尽最大努力交付。<br>websocket:html5协议。支持持久连接。http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个,http1.1有keep-alive属性。一次http连接，发送多次request,接收多次response.<br>400状态码：请求无效<br>前端提交数据的字段名称和字段类型与后台的实体没有保持一致：<br>401：当前请求需要用户验证<br>403：服务器已经得到请求，但是拒绝执行。<br>Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）<br>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）<br>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）<br><strong>html语义化是指正确的标签包含了正确的内容。结构良好，便于阅读，例如nav标签,aside标签。</strong><br>iframe元素会创建包含另一个文档的内联框架<br>提示：可以将提示文字放在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p>之间，来提示某些不支持iframe的浏览器<br>Doctype作用?严格模式与混杂模式如何区分？它们有何意义?<br>位于文档最前面，告诉浏览器以何种方式渲染页面，有混杂模式和标准模式。<br>严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。<br>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p>
<h3 id="http与浏览器2"><a href="#http与浏览器2" class="headerlink" title="http与浏览器2"></a>http与浏览器2</h3><p>cookie和session区别<br>cookie数据放在客户浏览器上，session放在服务器上。<br>cookie不是很安全，可以分析本地cookie进行欺骗。<br>session在一定时间内保存在服务器上。<br>cookie保存数据不能超过4k.<br>http 常用请求头<br>accept 可接受的响应内容。accept-encoding<br>authorization验证等。<br>origin:发起一个针对跨域资源共享的请求（该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源）。<br>user-agent:浏览器身份识别</p>
<h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><p>降低请求量，合并资源。<br>加快请求速度，预解析dns,减少域名数。<br>get和post区别<br>get参数通过url传递.post放在request body中。<br>get在url中传递参数长度是有限制的。post没有。<br>get请求不安全。</p>
<h2 id="浏览器的缓存"><a href="#浏览器的缓存" class="headerlink" title="浏览器的缓存"></a>浏览器的缓存</h2><p>缓存分为强缓存和协商缓存，根据响应header来决定。<br>强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。</p>
<p><strong>协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match</strong><br>url输入发生了什么，天龙八部<br>浏览器在生成页面的时候，会生成那两颗树？<br>构造2颗树，dom数和cssom树<br>接收到服务器响应的html文档后，遍历文档节点，生成dom树。<br>cssom规则有浏览器解析css文件生成。</p>
<h3 id="http与浏览器3"><a href="#http与浏览器3" class="headerlink" title="http与浏览器3"></a>http与浏览器3</h3><h3 id="各种攻击方式"><a href="#各种攻击方式" class="headerlink" title="各种攻击方式"></a>各种攻击方式</h3><p>CSRF:跨站请求伪造。可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个tab页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的话：使用验证码，检查https头部的refer，使用token<br>XSS:跨站脚本攻击，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie,或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中，防御的话为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤</p>
<p>304：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。</p>
<h3 id="get和post区别"><a href="#get和post区别" class="headerlink" title="get和post区别"></a>get和post区别</h3><p>GET - 从指定的资源请求数据。<br>POST - 向指定的资源提交要被处理的数据。</p>
<p>GET：不同的浏览器和服务器不同，一般限制在2~8K之间，更加常见的是1k以内。</p>
<p>GET和POST的底层也是TCP/IP，GET/POST都是TCP链接。</p>
<p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<h3 id="js基础-1"><a href="#js基础-1" class="headerlink" title="js基础(1)"></a>js基础(1)</h3><p>eval的功能，<br><strong>是将对应的字符串解析成js并执行，应该避免使用</strong><br>js前端模块化<br>是将复杂的文件编程为一个个独立的模块，例如js文件等。<br>一个模块是实现特定功能的文件，有了模块就可以方便引用别人的代码。想要什么功能就加载什么模块。<br>common.js 导出使用module.exports 引入采用 require(“”);<br>AMD:中文名是异步模块定义的意思。<br>实现一个once函数 传入函数参数只执行一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function ones(funcs) &#123;</span><br><span class="line">    var tag = true;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if(tag == true)&#123;</span><br><span class="line">            funcs.apply(null,arguments);</span><br><span class="line">            tag = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return undefined;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="js监听对象属性的变化"><a href="#js监听对象属性的变化" class="headerlink" title="js监听对象属性的变化"></a>js监听对象属性的变化</h2><p>es5中可以采用object.defineProperty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(user,&apos;name&apos;,&#123;</span><br><span class="line">    set:function(key,value)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>es6中采用proxy来实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var user = new Proxy(&#123;&#125;,&#123;</span><br><span class="line">    set:function(target,key,value,receiver)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>通过函数的形式创建私有变量，getName来访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Product() &#123;</span><br><span class="line">    var name = &quot;ckq&quot;;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new Product();</span><br></pre></td></tr></table></figure></p>
<p>Object.is()来判断值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(+0 === -0); //true</span><br><span class="line">console.log(null === undefined); //false</span><br><span class="line">console.log(Object.is(+0,-0));//false</span><br><span class="line">console.log(NaN == NaN);//false</span><br><span class="line">console.log(Object.is(NaN,NaN));//true</span><br></pre></td></tr></table></figure></p>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>跨域问题的解决方法：<br>什么叫跨域：是指浏览器不能执行其他网站的脚本，是由浏览器的同源策略造成的，浏览器对js的安全限制，只要协议，域名，端口，有一个不同，<br>都被当做是不同的域，跨域原理，通过各种方式，避开浏览器的安全限制。<br>jsonp方式：通过动态创建script,再请求一个带参网址实现跨域通信。<br>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。<br>jsonp缺点：只能实现get请求。<br>2.document.domain + iframe跨域<br>此方案仅限主域相同，子域不同的跨域应用场景。<br>实现原理：两个页面都通过js强行设置document.domain为基础主域，就实现了同域。<br>3.location.hash + iframe跨域<br>实现原理:<strong>a域与b域相互通信，通过中间页c来实现</strong>,3个页面，不同域之间通过iframe的location.hash传值，相同域之间通过js直接访问，<br>4.window.name + iframe跨域<br>window.name属性的独特之处，name值在不同的页面，甚至不同域名加载后依旧存在，并且可以支持非常长的name,<br>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。<br>5.postMessage跨域<br>h5 xmlHttpRequest level2中的API，且是为数不多可以跨域操作的window属性之一。<br>cors 跨域资源共享，服务端设置access-control-allow-orgin即可。前端无需设置。<br>6.nginx跨域请求。<br><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">跨域总结链接</a></p>
<h2 id="new运算过程"><a href="#new运算过程" class="headerlink" title="new运算过程"></a>new运算过程</h2><p>1.以构造器的prototype属性为原型，创建新对象<br>2.将this和调用参数传给构造器，执行；<br>3.如果构造器返回的是对象，则返回，否则返回第一步创建的对象。<br>JSDOM事件存在如下3个阶段：<br>1.事件捕获阶段<br>2.处于目标阶段<br>3.事件冒泡阶段<br>先捕获再冒泡，点击dom节点后，事件捕获，从上往下传播，然后到达目标节点，随后是冒泡，从下往上传播。<br>event.stopPropagation 阻止捕获或者冒泡，当前事件的进一步传播<br>event.stopImmediatePropagetion 阻止调用相同事件的其他侦听器<br>event.preventDefault取消该事件，而不停止事件的进一步传播<br>event.target 指向触发事件的元素，在事件冒泡过程中这个值不变<br>event.currentTarget = this;事件帮顶的当前元素，只有被点击时目标元素的target才会等于currentTarget，<br>最后，对于执行顺序的问题，如果DOM节点同时绑定了2个事件监听函数，一个用于捕获，一个用于监听，那么两个事件的执行顺序真的是先捕获在冒泡吗，答案是否定的，绑定在被点击元素的事件是按照代码添加的顺序执行的，其他函数是先捕获再冒泡。<br>函数作用域，如果在函数内部我们给未定义的一个变量赋值，这个变量会转变成为一个全局变量，<br>块作用域：块作用域吧标识符限制在{}中。<br>改变函数作用域的方法：<br>eval（），这个方法接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码，<br>with关键字：通常被当做重复引用同一个对象的多个属性的快捷方式<br><strong>JS采用的是词法作用域，也就是静态作用域，所以函数的作用域在函数定义的时候就决定了</strong><br>js对象分类<br>1.宿主对象：由js宿主环境提供的对象，它们的行为完全由宿主环境确定<br>2.内置对象:有js语言提供<br>2.1.固有对象 由标准规定，随着js运行时创建而自动创建的对象实例<br>2.2.原生对象 可以有用户通过Array,RegExp等内置构造器和特殊语法构造<br>2.3.普通对象,由{}语法，object构造器或者class关键字定义类的创建的对象<br>宿主对象:浏览器宿主对象，windows上有很多属性<br>内置对象:例如类，固有对象一种<br>原生对象:能够通过语言本身的构造器创建的对象称为原生对象。提供了30多个构造器，例如Array,Boolean,Date等。<br>在js中，微任务的执行高于宏观任务的执行，因此promise的执行高于setTimeout的执行。</p>
<h3 id="实现一个ajax"><a href="#实现一个ajax" class="headerlink" title="实现一个ajax"></a>实现一个ajax</h3><p>ajax创建异步对象XMLHttpRequest<br>操作XMLHttpRequest对象<br>(1)设置请求参数(请求方式，请求页面的相对路径，是否异步等)<br>(2)设置回调函数 一个处理器响应的函数 使用onreadystatechange 类似于函数指针<br>(3)获取异步对象的readyState属性，该属性存有服务器响应的状态信息。每当readyState改变时，onreadystatechange 函数就会被执行<br>(4)判断响应报文的状态，若为200则说明服务器正常响应并且返回<br>(5)读取数据 可以通过responseText属性来取回服务器返回的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;aabb.php&quot;,true);</span><br><span class="line">xhr.send(null);</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pwa全称为progressive web app,即渐进式web应用，一个pwa首先是一个网页，随后通过web技术编写成一个网页应用，随后添加上App Manifest和Service Worker来实现PWA的安装和离线等功能。<br>函数节流：当调整浏览器大小的时候，onresize事件可能会连续触发，在onresize事件处理程序内部如果尝试进行DOM操作的话，其高频率的操作可能导致浏览器崩溃，可以使用定时器对函数进行节流；<br>节流的思想：某些代码不可以在没有间断的情况下连续执行，第一次调用函数，创建一个定时器，在指定的时间间隔后再运行代码，第二次调用该函数时，它会清除前一次的定时器并且设置另一个。如果前一个定时器已经执行了，这个操作没有任何意义，然而，如果前一个定时器没有执行，其实就是替换为一个新的计时器，目的是只有在执行函数的请求停止了一段时间后才执行。<br>防抖：做多次函数的一段时间内操作，只有最后一次才是最有效的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/es6学习-3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/es6学习-3/" itemprop="url">es6学习-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T19:52:54+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>es6箭头函数<br>1.如果只有一个参数,()可以省略<br>2.如果只有一个return {}可以省略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let show = a =&gt; a * 2;</span><br></pre></td></tr></table></figure></p>
<p>剩余参数 args是剩余参数<br>参数扩展：收集剩余参数 …args 这个必须是最后一个。<br>不仅用于收集参数，也可以用于展开数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(a,b,...args)&#123;</span><br><span class="line">    console.log(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>展开运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,3];</span><br><span class="line">show(a,b,c) =&gt; &#123;</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">//调用的时候</span><br><span class="line">show(...arr);</span><br></pre></td></tr></table></figure></p>
<p>既可以展开，调用。<br>解构赋值<br>1.左右两边结构必须相同<br>2.右边必须是一个东西<br>3.声明和赋值是不能分开的，不能let[a,b] 随后再[a,b] = 这种事不合法的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [12,13,14];</span><br><span class="line">let &#123;a,b,c&#125; = &#123;a:12,b:13,c:14&#125;; //对象对应的值必须是相同的。a 对应字典里的a,b对应字典里的b，c对应字典里的c.</span><br></pre></td></tr></table></figure></p>
<p>字符串的模板语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p = 12;</span><br><span class="line">let str2 = `&lt;div&gt;</span><br><span class="line">$&#123;p&#125;</span><br><span class="line">&lt;/div&gt;`;</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure></p>
<p>用<code></code>来套进去，可以用$符号将外部的值传入嵌进去。可以多次换行。</p>
<p>类的使用 class关键字，专门的构造器 constructor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User&#123;</span><br><span class="line">    constructor(name,pass)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.pass = pass; //属性的定义</span><br><span class="line">    &#125;</span><br><span class="line">    //函数的定义</span><br><span class="line">    showName()&#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类中继承的作用<br>原先的继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function VipUser(name,pass,level)&#123;</span><br><span class="line">    User.call(this,name,pass);</span><br><span class="line">    this.level = level;</span><br><span class="line">&#125;</span><br><span class="line">VipUser.prototype = new User();</span><br><span class="line">VipUser.prototype.constructor = VipUser;</span><br><span class="line">VipUser.prototype.showLevel = function() &#123;</span><br><span class="line">    alert(this.level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过prototype的方法进行改变等。指定原型，随后指定自己的等。<br>es6中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class VipUser extends User&#123;</span><br><span class="line">    constructor(name,pass,level)&#123;</span><br><span class="line">       super(name,pass); //父级的 超类</span><br><span class="line">       this.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    //方法</span><br><span class="line">    showLevel()&#123;</span><br><span class="line">        alert(this.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>json拼接到url字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let json = &#123;a:12,b:5&#125;;</span><br><span class="line">let str = &quot;www.baidu.com&quot; +</span><br></pre></td></tr></table></figure></p>
<p>json的标准写法<br>json中的key必须用”“包起来，若是没有包起来就是js对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a:12,b:5&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是js对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;a&quot;:12,&quot;b&quot;:5&#125;</span><br></pre></td></tr></table></figure></p>
<p>这才是json对象。 而且不能用单引号。<br>json的简写：<strong>注意 以下说的都是对象的简写。而不是json</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = 12;</span><br><span class="line">let b = 5;</span><br><span class="line">let json = &#123;a,b,c:55&#125;;</span><br><span class="line">console.log(json);</span><br></pre></td></tr></table></figure></p>
<p>函数的简写 function可以去掉，直接加括号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    show()&#123;</span><br><span class="line">        console.log(223);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>promise的使用 all必须全部成功<br>promise中的all方法，当全部promise执行完毕，并且成功返回的时候，才执行then方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.all([</span><br><span class="line">    p1,p2</span><br><span class="line">]).then(function(object)&#123;</span><br><span class="line">let [res1,res2] = object; //解析构值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>promise中的race主要其中有一个返回就可以，不用管其中所有成功。<br>yield 可以让函数暂时停止在某个地方 等到next再进行下面的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//generator函数</span><br><span class="line">function *show()&#123;</span><br><span class="line">//代码1</span><br><span class="line">yield ajax(xxx)； //中间能够停</span><br><span class="line">//代码2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同generator函数生成了许多小函数。 next进行下一步。yield是停止暂停。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = show();</span><br><span class="line">obj.next();</span><br><span class="line">obj.next();</span><br></pre></td></tr></table></figure></p>
<p>generator可以向内部传参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *show() &#123;</span><br><span class="line">    alert(&quot;a&quot;);</span><br><span class="line">  let a =  yield ; //yield还能返回东西</span><br><span class="line">    alert(a);</span><br><span class="line">    return a;</span><br><span class="line">&#125;;</span><br><span class="line">let gen = show();</span><br><span class="line">gen.next(12); //对于传参来说是费的 这里的next执行的是从show到第一个yield之间的代码</span><br><span class="line">gen.next(5);</span><br></pre></td></tr></table></figure></p>
<p>如上所示 gen.next(12)这个可以说是无用的，因为第一步的参数是要用过show()方法的直接调用传入的。<br>后续gen.next(5)表示向yield的第二个代码块传入了参数5 所以可以通过let a = yield 获取到5 并进行接下来的操作</p>
<p>generator也可返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> function *show() &#123;</span><br><span class="line">      alert(&quot;a&quot;);</span><br><span class="line">      //半路返回</span><br><span class="line">      yield 12;</span><br><span class="line">      alert(&quot;b&quot;);</span><br><span class="line">      //最后一道靠return完成</span><br><span class="line">      return 16;</span><br><span class="line">  &#125;</span><br><span class="line">  let gen = show();</span><br><span class="line">  let res1 = gen.next(); //返回的是一个json对象&#123;value:12,done:false&#125; 表示没有做完</span><br><span class="line">  let res2 = gen.next(); //返回的是undefined done是true</span><br><span class="line">console.log(res2);</span><br></pre></td></tr></table></figure></p>
<p>yield 12 表示从函数开始到第一个代码块返回的是12，通过打印res1可以知道，还没有做完，当前取得的值时12<br>第二个res2拿到的是undefined,done为true,表示已经完成。最后的返回只能通过return返回，此时表示已经完成。<br>promise涉及到逻辑操作的时候，与普通回调的嵌套并没有什么差别。<br>所以用generator更适合。当第一个完成后，再执行逻辑，执行第二个。<br>js由ecmscript,dom,和bom组成。<br>string,number,undefined,boolean,null.<br>基本数据类型放在栈区，复杂数据类型放在堆区。堆区存储量大。<br>es6汇总<br>1.变量<br> var 重复声明，函数级别。<br> let 不能重复声明。块级变量。<br> const 不能重复声明，块级常量。<br>2.箭头函数<br> 1.方便 如果只有一个参数，()可以省略。<br> 2.如果只有一个return,{}也可以省。<br> 3.修正this问题。<br>   this相对正常点。<br>3.参数扩展<br>…<br>收集或者扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认参数function(a,b = 5)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.数组方法<br>map映射,reduce汇总 一堆,filter 过滤(删选)forEach循环.<br>5.字符串<br>startWith/endWith<br>字符串模板 换行。$(a)xxx$(b)<br>6.promise方法<br>对数据分钟<br>promise.all<br>7.generator执行到一半可以暂停。<br>8.json对象。stringfy,parse.<br>9.解构赋值<br>左右结构一样<br>右边是个合法东西<br>声明和赋值一次性完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [12,5,8];</span><br></pre></td></tr></table></figure></p>
<p>10.面向对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Text&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.xxx = </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class class2 exnteds Text</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/window对象高度取值问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/window对象高度取值问题/" itemprop="url">window对象高度取值问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T15:34:08+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/面试相关/" itemprop="url" rel="index">
                    <span itemprop="name">面试相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>浏览器窗口的尺寸，就是内容部分，是可以看见的大小，但不包括工具栏和滚动条。<br>对于IE,CHROME,FIREFOX,OPERA和Safari<br>window.innerHeight 浏览器窗口的可见宽度。<br>window.innerWidth 浏览器的可见宽度</p>
<p>IE 8 7 6 5<br>document.documentElement.clientHeight<br>document.documentElement.clientWidth<br>或者<br>document.body.clientHeight和document.body.clientWidth<br>兼容所有浏览器的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/26/js事件运行机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/26/js事件运行机制/" itemprop="url">js事件运行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-26T18:40:16+08:00">
                2019-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js是单线程的"><a href="#js是单线程的" class="headerlink" title="js是单线程的"></a>js是单线程的</h3><p>js是单线程的，也就是说，同一个时间只能做一件事情。<br>原因：作为浏览器的脚本语言，js的主要用途是与用户进行交互，以及操作dom,所以如果有多线程的话，一个线程在某个节点上操作dom,另外一个节点在删除dom,就不知道以哪个线程为准。<br>单线程意味着<strong>所有任务都需要排队</strong>,前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。例如ajax请求，需要等到网络有响应了才返回数据(IO操作)。<br>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面<br>的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。<br>同步任务进入主线程，而异步任务进入<strong>任务队列</strong>,不进入主线程，只有任务队列通知了主线程，某个异步任务执行完成了，该任务才会进入主线程。<br>执行流程如下：<br>1.所有同步任务都在主线程上执行，形成一个<strong>执行栈</strong>,<br>2.主线程之外，还存在一个<strong>任务队列</strong>，只要异步任务有了结果，就在任务队列中放置一个事件。<br>3一旦执行栈中所有同步任务都执行完毕后，系统就会读取”任务队列“，看看里面有些什么事件，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4.主线程不断重复上面的第三步。<br>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。</p>
<h3 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h3><p>任务队列是一个事件的队列，IO设备(用户产生事件，例如鼠标点击等)，只要指定了回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。<br>回调函数的含义：(被主线程挂起来的代码),异步任务必须指定回调函数，当主线程执行异步任务，就会执行对应的回调函数。<br>“任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p>
<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h3><p>主线程运行的时候，产生堆和栈。栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。<br>setTimeOut的含义：指定某个任务在主线程得到的最早空闲时间执行，也就是说，尽可能早的执行，任务队列的尾部添加一个事件，因此等到同步任务和任务队列所有事件处理完，才会得到执行。<br>node的后续再说<br>(参考链接)[<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html]" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html]</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/js事件冒泡和委托机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/js事件冒泡和委托机制/" itemprop="url">js事件冒泡和委托机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T09:58:10+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="js事件冒泡"><a href="#js事件冒泡" class="headerlink" title="js事件冒泡"></a>js事件冒泡</h3><p>js所谓的事件冒泡就是子级元素的某个事件被触发，他的上级元素的该事件也会被递归的执行。<br>有如下html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul data-type=&quot;cityPick&quot;&gt;</span><br><span class="line">&lt;li data-id = &quot;0&quot;&gt;全部&lt;/li&gt;</span><br><span class="line">    &lt;li data-id = &quot;1&quot;&gt;纽约&lt;/li&gt;</span><br><span class="line">    &lt;li data-id = &quot;2&quot;&gt;洛杉矶&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script src = &quot;event.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>js代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ul[data-type = &apos;cityPick&apos;]&quot;).on(&apos;click&apos;,function () &#123;</span><br><span class="line">  alert(&quot;父元素被点击&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;ul[data-type = &apos;cityPick&apos;]&quot;).on(&apos;click&apos;,&apos;li&apos;,function () &#123;</span><br><span class="line">    alert(&quot;子元素被点击&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当点击子元素时，父元素的alert事件也会被触发。<br>而在某些时候，我们不希望他冒泡，<br>可以用stopPropagation()方法阻止对父元素的冒泡传递。<br>某些事件的默认事件不能被触发，例如点击a的href 链接跳转时，不进行跳转<br>可以用e.preventDefault()事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ul[data-type = &apos;cityPick&apos;]&quot;).on(&apos;click&apos;,&apos;li&apos;,function (e) &#123;</span><br><span class="line">    e.stopPropagation();//阻止事件冒泡</span><br><span class="line">    alert(&quot;子元素被点击&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="js事件委托"><a href="#js事件委托" class="headerlink" title="js事件委托"></a>js事件委托</h3><p>事件委托实际上利用了冒泡的原理，从点击的元素开始，递归方式的向父元素传播事件，好处是不用为每一个子元素设置click事件，而只需为父元素上绑定一次即可。<br>如下代码html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;btnGroup&quot;&gt;</span><br><span class="line">    &lt;div class = &quot;btn&quot;&gt;按钮1&lt;/div&gt;</span><br><span class="line">    &lt;div class = &quot;btn&quot;&gt;按钮2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#btnGroup&quot;).on(&apos;click&apos;,&apos;.btn&apos;,function () &#123;</span><br><span class="line">    alert($(this).html());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>由于事件委托是通过事件冒泡实现的，所以如果子级的元素阻止了事件冒泡，那么事件委托也将失效！</strong><br>(参考链接)[<a href="https://www.cnblogs.com/alsy/p/4915912.html]" target="_blank" rel="noopener">https://www.cnblogs.com/alsy/p/4915912.html]</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KevinSwift">
            
              <p class="site-author-name" itemprop="name">KevinSwift</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      
 
           <div>
              <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="50" height="60" src="//music.163.com/outchain/player?type=2&id=34532273&auto=1&height=66"></iframe>
           </div>
 
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinSwift</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
