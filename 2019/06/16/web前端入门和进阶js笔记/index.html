<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="面试,前端大杂烩,">










<meta name="description" content="js和esmscript的关系js和ecmscrpit的关系ecmscript是一种有ecma国际制定和发布的脚本语言规范ecmscript不是一门语言，而是一种标准js包括ecmpscript(语言核心功能基于ES规范)DOM js需要支持对DOM的维护，通过document elementBOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的提一下nodejs.">
<meta name="keywords" content="面试,前端大杂烩">
<meta property="og:type" content="article">
<meta property="og:title" content="web前端入门和进阶js笔记">
<meta property="og:url" content="http://yoursite.com/2019/06/16/web前端入门和进阶js笔记/index.html">
<meta property="og:site_name" content="KevinSwift">
<meta property="og:description" content="js和esmscript的关系js和ecmscrpit的关系ecmscript是一种有ecma国际制定和发布的脚本语言规范ecmscript不是一门语言，而是一种标准js包括ecmpscript(语言核心功能基于ES规范)DOM js需要支持对DOM的维护，通过document elementBOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的提一下nodejs.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/nowcoder/webjs.jpg">
<meta property="og:updated_time" content="2019-08-14T12:01:23.801Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="web前端入门和进阶js笔记">
<meta name="twitter:description" content="js和esmscript的关系js和ecmscrpit的关系ecmscript是一种有ecma国际制定和发布的脚本语言规范ecmscript不是一门语言，而是一种标准js包括ecmpscript(语言核心功能基于ES规范)DOM js需要支持对DOM的维护，通过document elementBOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的提一下nodejs.">
<meta name="twitter:image" content="http://yoursite.com/nowcoder/webjs.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/16/web前端入门和进阶js笔记/">





  <title>web前端入门和进阶js笔记 | KevinSwift</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KevinSwift</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/web前端入门和进阶js笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KevinSwift">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KevinSwift">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">web前端入门和进阶js笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T17:44:09+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/js相关/" itemprop="url" rel="index">
                    <span itemprop="name">js相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="js和esmscript的关系"><a href="#js和esmscript的关系" class="headerlink" title="js和esmscript的关系"></a>js和esmscript的关系</h2><p>js和ecmscrpit的关系<br>ecmscript是一种有ecma国际制定和发布的脚本语言规范<br>ecmscript不是一门语言，而是一种标准<br>js包括ecmpscript(语言核心功能基于ES规范)<br>DOM js需要支持对DOM的维护，通过document element<br>BOM js需要支持对BOM的维护，通过window对象实现，这些都是在es6中没有的<br>提一下nodejs.nodejs是基于chrome V8引擎。上文提到V8引擎是用来解析执行JS，并且V8是基于ECMAscirpt标准实现的.换个角度说,nodejs里头没有DOM和BOM的操作,只保留的javascript的语法核心(ES),并且增加了事件驱动的非阻塞I/O模型，使其轻量级和高效。nodejs作为服务运行在linux,mac,window,把javascipt的角色从前台开发,转移到了后台开发。<br><a href="https://www.jianshu.com/p/10cfcb536d4a" target="_blank" rel="noopener">js与ecmscript的关系</a><br>js是<strong>弱变量</strong>类型的语言，变量声明用var来实现。而java中必须带类型<br>var a;</p>
<h2 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h2><p><img src="/nowcoder/webjs.jpg" width="50%" height="50%"><br>1、User Interface 用户界面，我们所看到的浏览器</p>
<p>2、Browser engine 浏览器引擎，用来查询和操作渲染引擎</p>
<p>3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS</p>
<p>4、Networking 网络，负责发送网络请求</p>
<p>5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码</p>
<p>6、UI Backend UI后端，用来绘制类似组合框和弹出窗口</p>
<p>7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage</p>
<p>js分为3部分组成<br>ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。<br>DOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。<br>BOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。<br>PS：JS机械重复性的劳动几乎为0，基本都是创造性的劳动。而不像HTML、CSS中margin、padding都是机械重复劳动。<br>js是解释型语言，事先不需要被编译成机器码再执行，逐行执行，无需进行严格的变量声明。<br>解释型语言：边解析边执行，不需要事先编译。例如：JavaScript、php。</p>
<p>编译型语言：事先把所有的代码翻译成计算机能够执行的指令，然后整体执行。例如：c、c++。<br>分号不是必须加的，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源。<br>用户输入<br>prompt()就是专门用来弹出能够让用户输入的对话框，用得少，测试的时候会用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = prompt(&quot;请随便输入点东西&quot;); //不管是什么语句 输入都是字符串</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<h2 id="基本对象和引用对象"><a href="#基本对象和引用对象" class="headerlink" title="基本对象和引用对象"></a>基本对象和引用对象</h2><p>基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。<br>引用数据类型（引用类型）：Object 对象。<br>注意：内置对象function、Array、Date、RegExp、Error等都是属于Object类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。<br>面试问：引用数据类型有几种？<br>面试题：只有一种，即object类型。<br>基本数据类型：参数赋值的时候，传数值<br>引用数据类型：参数赋值的时候，传地址<br>（2）引号不能嵌套：双引号里不能再放双引号，单引号里不能再放单引号。但是单引号里可以嵌套双引号。<br>\” \’ \n换行<br>无穷大 Infinity 无穷小 -Infinity<br>注意：typeof Infinity的返回结果是number。<br>NaN:是一个特殊的数字，表示Not a Number<br>typeof NaN返回的是number<br>null和undefined有最大的相似性。看看null == undefined的结果(true)也就更加能说明这点。<br>其他数据类型 -&gt; Number<br>字符串 -&gt; 数字<br>1.字符串是纯数字 则将其转化为数字<br>2.字符串有非数字的内容，则转化为NaN,<br>3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0。<br>null -&gt; 数字 0 undefined -&gt; 数字 NaN<br>parseInt的作用，将字符串中有效的整数内容转化为数字<br>console.log(parseInt(“2017.01在公众号上写了6篇文章”));  //打印结果仍是：2017   （说明只会取整数）<br>只能取开头的，中间的不能截取<br>对非String使用parseInt()或者parseFloat() 先转换成string再操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = true;</span><br><span class="line">console.log(parseInt(a));</span><br></pre></td></tr></table></figure></p>
<p>转化为字符串”true”,然后再操作，打印出来NaN<br>转化为Boolean<br>数字 -&gt; 布尔 除了0和NaN 其余都转化为true<br>字符串 -&gt; 布尔 除了空串 其余都是true<br>null和undefined 转化为false<br>对象转化为true<br>布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，<strong>但返回结果是原值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result = 5 &amp;&amp; 6;</span><br><span class="line">console.log(&apos;result&apos; + result);</span><br></pre></td></tr></table></figure></p>
<p>与运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则必然返回第二个值（所以说，如果所有的值都为true，则返回的是最后一个值）</p>
<p>如果第一个值为false，则直接返回第一个值</p>
<p>或运算的返回结果：（以两个非布尔值的运算为例）</p>
<p>如果第一个值为true，则直接返回第一个值</p>
<p>如果第一个值为false，则返回第二个值<br>== 这个符号并不严谨，会将不同类型的东西，转为相同类型进行比较（大部分情况下，都是转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> console.log(&quot;6&quot; == 6);		// 打印结果：true。这里的字符串&quot;6&quot;会先转换为数字6，然后再进行比较</span><br><span class="line">console.log(true == &quot;1&quot;);   // 打印结果：true</span><br><span class="line">console.log(0 == -0);       // 打印结果：true</span><br><span class="line"></span><br><span class="line">console.log(null == 0);   // 打印结果：true</span><br><span class="line">   console.log(undefined == null) //打印true</span><br><span class="line">   console.log(NaN == NaN) //false</span><br></pre></td></tr></table></figure></p>
<p>如果要保证完全等于，我们就要用三个等号===。全等不会做类型转换。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;6&quot; === 6);		//false</span><br><span class="line">console.log(6 === 6);</span><br></pre></td></tr></table></figure></p>
<h2 id="js中的代码块"><a href="#js中的代码块" class="headerlink" title="js中的代码块"></a>js中的代码块</h2><p>js中的代码块，只具有分组的作用，没有其他用途<br>代码块中的内容，在外部是完全可见的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	var a = 2;</span><br><span class="line">&#125;	</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<p>switch语句，条件分支语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case 1:</span><br><span class="line">	break;</span><br><span class="line">	case 2:</span><br><span class="line">	break;</span><br><span class="line">	default:</span><br><span class="line">	breeak;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>break语句一般建议不要省略，否则会出现<strong>case穿透现象</strong><br>continue用来跳过当次循环<br>基本数据类型是直接保存在<strong>栈内存</strong>中，值与值之间是独立存在的，修改一个变量不会影响其他变量。<br>对象：只要不是那5种基本数据类型，就全都是对象。<br>如果使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体。<br>对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。<br>对象是保存到<strong>堆内存</strong>中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间，变量保存的是对象的内存地址(对象的引用)<br>换言之，对象的值是保存在堆内存里的，但是对象的引用是保存在栈内存中的<br>对象的分类：内置对象，由ES标准定义的对象，在任何的ES的实现中都可以使用<br>比如Math,String,Number,Boolean,Function,Object<br>宿主对象：由js运行环境提供的对象，就是主要由浏览器提供的对象<br>比如DOM,BOM,console document等<br>自定义对象 由开发人员自己创建的<br>in运算符，通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true,没有返回false<br>“属性名” in 对象<br>console.log(“name” in obj);<br>js中 所有的<strong>变量</strong>都是保存在栈中的。<br>基本数据类型:基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。<br>引用数据类型:对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟一块新的空间，<strong>而变量保存了对象的地址</strong>,对象的引用，如果两个变量保存了同一个对象的引用，当一个通过变量去修改属性时，另一个也会修改。<br>函数的介绍：将一些功能语句进行封装 函数也是一个对象 使用typeof检查一个函数对象时，返回<strong>function</strong><br>函数表达式:<strong>将匿名函数赋值给一个变量</strong><br>fn()与fn的区别<br>fn()调用函数，相当于获取了函数的返回值<br>fn:函数对象，相当于直接获取了函数对象<br>在js中，只有2种作用域：全局作用域和函数作用域<br>直接编写在script标签中的JS代码，都在全局作用域。</p>
<p>全局作用域在页面打开时创建，在页面关闭时销毁。</p>
<p>在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用。</p>
<p>在全局作用域中：</p>
<p>创建的变量都会作为window对象的属性保存。</p>
<p>创建的函数都会作为window对象的方法保存。</p>
<p>全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到<br>变量的声明提前(变量提升)<br>使用var关键字声明的变量var = 1 <strong>会在所有代码执行之前声明(但不赋值)</strong><br>但是如果声明时不用var 比如a = 1 则变量不会被声明提前<br>函数声明：下面就为函数声明的过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fn1() &#123;</span><br><span class="line">	console.log(&quot;我是函数fn1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以函数的声明会提前，也就是说，整个函数会在所有的代码执行之前就被创建完成，所以我们可以在函数声明之前，调用函数。<br>fn1()后再声明函数<br>函数表达式不会提前<br>在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。<br>当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁。参考链接：<br>this:解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数便是this,this指向的是一个对象，这个对象我们称之为函数的执行<strong>上下文对象</strong>,<br>以函数形式调用,this指向window,比如func()<br>以方法形式调用，this是调用方法的那个对象<br>以构造函数形式调用，this是新创建的那个对象<br>使用call和apply调用，this指定的是那个对象</p>
<h2 id="箭头函数中this的指向"><a href="#箭头函数中this的指向" class="headerlink" title="箭头函数中this的指向"></a>箭头函数中this的指向</h2><p>es6的箭头函数中并不会使用上面4条标准的绑定规则，而是会继承外层函数调用的this绑定(无论this绑定到什么)<br>在调用函数式，浏览器每次都会传递2个隐含参数,this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	console.log(typeof arguments);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p>
<p>arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。<br>arguments代表的是<strong>实参</strong>,我们所传递的实参都会在arguments中保存。有个讲究的地方是：arguments只在函数中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">	console.log(fn.length);//获取形参个数</span><br><span class="line">	console.log(arguments.length);//获取实参个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、arguments可以修改元素<br>之所以说arguments是伪数组，是因为：arguments可以修改元素，但不能改变数组的长短。举例：<br>new 一个构造函数的执行流程<br>(1)开辟内存空间，存储新创建的对象<br>(2)将新建的对象设置为构造函数中的this,在构造函数中可以使用this来引用新对象。<br>(3)执行函数中的代码，(包括设置对象属性和方法等)。<br>(4)将新建的对象作为返回值返回<br><strong>所有的对象都是Object的后代</strong>，因此，任何对象instanceof Object返回的结果都是true.<br>JSON:json的属性必须用双引号来括起来，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            &quot;name&quot; : &quot;zs&quot;,</span><br><span class="line">            &quot;age&quot; : 18,</span><br><span class="line">            &quot;sex&quot; : true,</span><br><span class="line">            &quot;sayHi&quot; : function() &#123;</span><br><span class="line">                console.log(this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>json的遍历与对象的遍历一样，用for…in…来进行遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myJson = &#123;</span><br><span class="line">       &quot;name&quot;: &quot;smyhvae&quot;,</span><br><span class="line">       &quot;aaa&quot;: 111,</span><br><span class="line">       &quot;bbb&quot;: 222</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   //json遍历的方法：for...in...</span><br><span class="line">   for (var key in myJson) &#123;</span><br><span class="line">       console.log(key);   //获取 键</span><br><span class="line">       console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法）</span><br><span class="line">       console.log(&quot;------&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><p>原型prototype的概念：<br>认识1：我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype,这个属性对应着一个对象，这个对象就是我们所谓的原型对象，<br>如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型，我们可以通过<strong>proto</strong>来访问该属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">	var per1 = new Person();</span><br><span class="line">	var per2 = new Person();</span><br><span class="line">console.log(Person.prototype); //打印结果[object object]</span><br><span class="line">console.log(per1.__proto__ == Person.prototype); //相等</span><br></pre></td></tr></table></figure></p>
<p>原型对象相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。<br>使用in来检查，如果对象中没有但是原型中有，也会返回true.<br>可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。</p>
<h2 id="JS的垃圾回收机制"><a href="#JS的垃圾回收机制" class="headerlink" title="JS的垃圾回收机制"></a>JS的垃圾回收机制</h2><p>当一个对象没有任何的变量或者属性对他进行引用时，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理。<br>在堆内存中：如果堆内存中的对象，没有任何变量指向它时，这个堆内存里的对象就会成为垃圾。<br>js中有自动的垃圾回收机制，会自动回收这些垃圾。如果你不再使用这些对象，将其置为null即可。<br>数组Array是属于内置对象。<br>数组和普通对象的功能类似，也是用来存储一些值的。不同的是：<br>普通对象是使用字符串来作为属性名的，而数组是使用数字来作为索引来操作元素。<br>数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据，使用频率非常高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(&quot;参数&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>如果修改的length大于原长度，则多出来部分会空出来，置为null.<br>如果修改的length小于原长度，则多出来部分会被删除，数组将从后面删除元素。<br>数组的基本方法<br>unshift(),在数组最前面插入一个或多个元素，返回结果为数组新的长度。<br>shift(),删除数组的第一个元素，返回结果为被删除的元素<br>forEach()没有返回值，也就是说，返回值是undefined.<br>filter()返回结果是true的项，将组成新的数组，可以起到过滤的作用。<br>map()对原数组中的每一项进行加工<br>every()如果有一项返回false,则停止遍历<br>some()只要有一项返回true,则停止遍历<br>注意：这几个方法不会修改原数组。都会组成新的数组等。<br>forEach循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;网一&quot;,&quot;网二&quot;];</span><br><span class="line">arr.forEach(function(item,index,obj)&#123;</span><br><span class="line">	console.log(item);</span><br><span class="line">	console.log(index);</span><br><span class="line">	console.log(obj);</span><br><span class="line">&#125;)</span><br><span class="line">//表示当前正在遍历的元素，正在遍历元素的索引，和正在遍历的数组</span><br><span class="line">//filter函数</span><br><span class="line">var arr1 = [1,2,3,4,5,6];</span><br><span class="line">var arr2 = arr1.filter(function(item,index)&#123;</span><br><span class="line">	if(item &gt; 2)</span><br><span class="line">	return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;)</span><br><span class="line">//map方法 解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。</span><br><span class="line"></span><br><span class="line">  var arr1 = [1, 3, 6, 2, 5, 6];</span><br><span class="line"></span><br><span class="line">    var arr2 = arr1.map(function (item, index) &#123;</span><br><span class="line">        return item + 10;  //让arr1中的每个元素加10</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(arr2);</span><br><span class="line">	//every方法 只有全部返回true,才返回true</span><br><span class="line">	 var arr1 = [&quot;千古&quot;, &quot;宿敌&quot;, &quot;南山忆&quot;, &quot;素颜&quot;];</span><br><span class="line">    var bool1 = arr1.every(function (element, index, array) &#123;</span><br><span class="line">        if (element.length &gt; 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(bool1);  //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false</span><br><span class="line"></span><br><span class="line">some()方法</span><br><span class="line">解释：对数组中每一项运行回调函数，只要有一项返回true，则停止遍历，此方法返回true。</span><br><span class="line">如果都返回false,则返回值是false。如果有一项返回true,则停止遍历，返回true.</span><br></pre></td></tr></table></figure></p>
<p>数组的常用方法<br>slice 从数组中提取指定的一个或多个元素，返回新的数组，不会改变原数组<br>splice从数组中删除指定的一个或多个元素，返回新的数组，会改变原数组<br>concat连接两个或多个数组，返回新的数组，不会改变原数组<br>jon将数组转化为字符串，返回转换后的字符串，不会改变原数组<br>reverse反转数组，返回翻转后的数组，会改变原数组<br>sort,对数组元素，按unicode编码，从小到大排序，会改变原数组。<br>slice<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var result1 = arr.slice(2);//从第二个位置开始提取</span><br><span class="line">var result2 = arr.slice(-2);//提取最后2个元素</span><br><span class="line">var result3 = arr.slice(2,4);//提取从第二个到第四个 不包含4</span><br></pre></td></tr></table></figure></p>
<h2 id="将伪数组转化为真数组"><a href="#将伪数组转化为真数组" class="headerlink" title="将伪数组转化为真数组"></a>将伪数组转化为真数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array = Array.from(arrayLike);</span><br></pre></td></tr></table></figure>
<p>splice 删除一个或多个元素，返回新的数组，会改变原数组<br>新数组 = 原数组.splice(起始索引index,需要删除的个数,第三个参数，第四个参数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];</span><br><span class="line">   var result1 = arr1.splice(1);</span><br><span class="line">   console.log(arr1); //第1个删除后返回arr1</span><br><span class="line">   console.log(result1); //原数组的第一个删除了 给result</span><br></pre></td></tr></table></figure></p>
<p>从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr4 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];</span><br><span class="line"></span><br><span class="line">//从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素</span><br><span class="line">var result4 = arr4.splice(1, 3, &quot;千古壹号&quot;, &quot;vae&quot;);</span><br></pre></td></tr></table></figure></p>
<p>concat连接 arr1.concat(arr2);将arr2中的元素追加到arr1的尾部<br>join方法指定一个字符串作为参数，这个字符串将会成为数组元素连接的连接符，如果不指定连接符，则默认使用’,’作为连接符，此时和 toString()的效果是一致的。<br>reverse反转字符串<br>sort函数中的自定义方法，<br><strong>如果返回一个大于0的值，则元素会交换位置，</strong><br><strong>如果返回一个小于0的值，则元素位置不变</strong><br>如果返回0，则认为2个元素相等，则不交换位置。<br>var result = arr3.sort(function(a,b){<br>    if(a &gt; b){<br>        return a - b; //升序排列<br>        return b - a;//降序排列<br>        return 1;//如果a &gt; b则交换a和b的位置，就是进行升序排列<br>    }else if(a &lt; b){<br>        return -1; //元素位置保持不变<br>    }else<br>return 0;<br>})<br>indexOf,lastIndexOf获取数据的索引<br>从后往前索引，获取 value 在数组中的最后一个下标    从后往前，找到最后一次出现的，也就是排在最后的出现的那位。<br>find(function (item, index){</p>
<p>})<br>Array.from将伪数组转化为真数组<br>伪数组的原型链中没有Array.prototype,而真数组的原型链中有Array.prototype<br>Array.of(1,’abc’,true);//将一系列值转化成数组<br>isArray 判断是否是数组<br>valueOf,返回数组本身 数组本身 = 数组.valueOf();<br>内置对象简介：内置对象就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用的或是最基本而必要的功能。<br>内置对象    对象说明<br>Arguments 函数参数组合<br>Array    数组<br>Boolean    布尔对象<br>Date    日期时间<br>Error    异常对象<br>Function    函数构造器<br>Math    数学对象<br>Number    数值对象<br>Object    基础对象<br>RegExp    正则表达式对象<br>String    字符串对象<br>Date对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure></p>
<p>传递一个表示时间的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var date2 = new Date(&quot;2017/09/06 09:00:00&quot;);</span><br><span class="line">console.log(date2);</span><br></pre></td></tr></table></figure></p>
<h2 id="Date和Math方法"><a href="#Date和Math方法" class="headerlink" title="Date和Math方法"></a>Date和Math方法</h2><p>获取日期和时间<br>getDate() //获取日子 1-31<br>getDay() //获取星期0-6 0代表周末 1代表周一<br>getMonth() //获取月份0-11 0代表1月<br>getTime() //获取时间戳<br>时间戳指的是从格林威治标准时间的1970.1.1号0时0分0秒到现在日期所花费的毫秒数(1s = 1000 ms)<br>内置对象Math的常见方法<br>Math.abs()返回绝对值<br>Math.floor()向下取整(向小取)<br>Math.ceil()向上取整(向大取)<br>Math.round()四舍五入(正数四舍五入,负数五舍六入)<br>Math.random()生成0-1之间的随机数<br>Math.max(x,y,z)返回多个数中的最大值<br>Math.min(x,y,z)返回多个数中的最小值<br>生成0-x之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * x);</span><br></pre></td></tr></table></figure></p>
<p>生成x-y之间的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round(Math.random() * (y - x) + x);</span><br></pre></td></tr></table></figure></p>
<h2 id="url编码和解码"><a href="#url编码和解码" class="headerlink" title="url编码和解码"></a>url编码和解码</h2><p>URI 通用资源标识符，进行编码，以便发送给浏览器，有效的URI编码不能包含某些字符，例如空格，而这URI编码方法就可以对URL进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent();   //把字符串作为 URI 组件进行编码</span><br></pre></td></tr></table></figure></p>
<p>包装类的介绍：<br>js中的数据类型包括以下几种，<br>基本数据类型：string,number,boolean,null,undefined<br>引用数据类型：object<br><strong>js为我们提供了3个包装类</strong><br>String(),将基本数据类型字符串，转化为String对象<br>Number(),将基本数据类型数字，转化为Number对象。<br>Boolean()：将基本数据类型的布尔值，转换为Boolean对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num = new Number(3);</span><br><span class="line">var str = new String(&quot;hello&quot;);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：我们在实际应用中不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。<br>方法和属性只能添加给对象，不能添加给基本数据类型。<br>slice方法 从字符串中截取指定的内容，不会修改原字符串 而是将截取到的内容返回<br>(2,5)截取时，包左不包右<br>字符串 = str.slice(开始索引,结束索引);<br>(2)表示<strong>从指定的索引位置开始，截取到最后</strong><br>(-3)表示从倒数第几个开始，截取到最后<br>(1,-1)表示从第一个截取到倒数第一个<br>(5,2)表示前面的大，后面的小，返回值为空<br>substring,不能接受负值作为参数，如果传递了一个负值，默认使用0<br>substring还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。<br>substr从字符串中截取指定的内容，不会修改原来的字符串，而是将及截取到的内容返回。<br>  字符串 = str.substr(开始索引, 截取的长度);<br>  开始所以，截取的长度<br>  用逗号来隔开字符串，split<br>  trim去除字符串前后的空白。replace替换所有的<br>  toLowerCase()转换成小写<br>  定义：正则表达式用于定义一些字符串的规则。</p>
<p>作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var 变量 = new RegExp(&quot;正则表达式&quot;,&quot;匹配模式&quot;);</span><br><span class="line">console.log(reg.test(str1));</span><br></pre></td></tr></table></figure></p>
<p>来进行测试，检查是否符合。</p>
<h2 id="let-var-function，eval的区别"><a href="#let-var-function，eval的区别" class="headerlink" title="let var function，eval的区别"></a>let var function，eval的区别</h2><p>let变量不存在变量提升问题，在我们声明(初始化)他们之前，他们是不可访问的。这被称为<strong>暂时死区</strong><br>let 的「创建」过程被提升了，但是初始化没有提升。<br>var 的「创建」和「初始化」都被提升了。<br>function 的「创建」「初始化」和「赋值」都被提升了。<br>eval会为字符串传递的代码求值，如果它是一个表达式，就像如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sum = eval(&quot;10 * 10 + 5&quot;);</span><br></pre></td></tr></table></figure></p>
<p>sum为105 先计算出来 再赋值<br>所有对象键：(不包括Symbol)都会被存储为字符串形式，即使你没有给定字符串类型的键。<br>默认情况下：事件处理程序在冒泡阶段执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">console.log(typeof a);//返回function</span><br><span class="line">console.log*typeof null)//返回object</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1], [2, 3]].reduce(</span><br><span class="line">  (acc, cur) =&gt; &#123;</span><br><span class="line">    return acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [1, 2]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>[1,2]是初始值，随后第一轮连接上[1,2,0,1]，第二轮连接上[1,2,0,1,2,3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function aaa(...args) &#123;</span><br><span class="line">      console.log(args);</span><br><span class="line">  &#125;</span><br><span class="line">  aaa(2,34);</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，将会把传入的数据全都组装成一个数组。<br>所以，打印出的args为[2,34];<br>事件的三要素：事件源，事件，事件驱动程序<br>事件源：应发后续事件的html标签<br>事件：js已经定义好的<br>事件驱动程序：对样式和html的操作，也就是DOM<br>获取事件源：document.getElementById(“box”);<br>绑定事件：box.onclick = function(){}<br>书写事件驱动程序：关于DOM的操作<br>js的加载和html是同步加载的，因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。<br>建议是：整个页面上所有元素加载完毕之后执行js内容。<br>所以,window.onload可以预防使用标签在预定义之前。<br>DOM:文档对象模型，DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构，目的其实是为了能让js操纵DOM形成一种规范。<br>渲染引擎将把内存中把HTML文档，生成一个DOM树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = document.getElementsByTagName(&quot;div&quot;);     //方式二：通过 标签名 获得 标签数组，所以有s</span><br><span class="line"></span><br><span class="line">	var arr2 = document.getElementsByClassName(&quot;hehe&quot;);  //方式三：通过 类名 获得 标签数组，所以有s</span><br><span class="line">//返回数组</span><br><span class="line"> var div1 = document.getElementById(&quot;box1&quot;);      //方式一：通过id获取单个标签</span><br><span class="line">//返回object</span><br></pre></td></tr></table></figure></p>
<p>下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling<br>获取父节点：节点.parentNode获取到父节点<br>前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling<br>childNodes:标准属性，返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）<br>子节点数组 = 父节点.childNodes;<br>创建一个li标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a1 = document.createElement(&quot;li&quot;);</span><br></pre></td></tr></table></figure></p>
<p>插入节点<br>appendChild(新的子节点);<br>逐一获取属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myNode.getAttribute(&quot;src&quot;);</span><br></pre></td></tr></table></figure></p>
<p>设置属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(&quot;src&quot;,&quot;imgs&quot;);</span><br></pre></td></tr></table></figure></p>
<p>删除节点属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeAttributes(属性名);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id = &quot;box&quot; value = &quot;111&quot;&gt;</span><br><span class="line">声明</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面这个标签就包含了3种标签，元素节点(标签) 属性节点 文本节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var element = document.getElementById(&quot;box1&quot;);  //获取元素节点（标签）</span><br><span class="line">  var attribute = element.getAttributeNode(&quot;id&quot;); //获取box1的属性节点</span><br><span class="line">  var txt = element.firstChild;                   //获取box1的文本节点</span><br><span class="line"></span><br><span class="line">  var value = element.getAttribute(&quot;id&quot;);         //获取id的属性值</span><br></pre></td></tr></table></figure></p>
<p>nodeType = 1表示的是元素节点<br>nodeType = 2 表示属性节点<br>nodeType = 3表示文本节点<br>nodeName表示名称，nodeValue表示值<br>添加事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&apos;click&apos;,function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure></p>
<p>参数1：事件名(注意，没有on)<br>参数2：事件名（执行函数)<br>参数3：true表示捕获阶段触发，false表示冒泡阶段触发，如果不写，默认为false<br> //addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行<br>//第二种事件绑定的方法不会出现层叠。（更适合团队开发）<br>第二件添加的事件不会覆盖第一件的<br>DOM事件流：<br>事件传播的3个阶段：事件捕获，事件目标，事件冒泡<br>事件捕获：事件从上一级标签开始往下寻找，直到捕获到事件目标 target，从祖元素到子元素，DOM树结构，在这个过程中，事件相应的监听函数不会被触发。<br>事件目标：当到达目标元素之后，执行目标元素事件对应的处理函数，如果没有绑定监听函数，那就不执行。<br>事件冒泡：事件从事件目标target开始，网上逐渐冒泡到页面最上层一级。<br>在js中，如果想获取html节点，方法是document.documentElement<br>如果想获取body节点，方法是docuemt.body 二者不要混淆<br>事件冒泡：鼠标点击一个按钮，同样这个事件会在所有父元素上被触发。<br>通俗来讲，冒泡指的是：子元素的事件被触发时，父盒子的同样的事件也会被触发。取消冒泡就是取消这种机制。<br>冒泡顺序：<br>一般的浏览器: （除IE6.0之外的浏览器）<br>div -&gt; body -&gt; html -&gt; document -&gt; window<br>IE6.0：<br>div -&gt; body -&gt; html -&gt; document<br>不是所有的事件都能冒泡：<br>以下事件不冒泡：blur,focus,load,unload,onmouseenter,onmouseleave,意思是事件不会向父元素那里传递。<br>检查一个元素是否会冒泡，可以通过事件的如下参数：event.bubbles.<br>阻止冒泡的方法(火狐，谷歌，IE11)event.stopPropagation();<br>IE10以下则是event.cancelBubble = true;<br>事件委托：事件委托：通俗来说，就是把一个元素响应事件函数委托到另一个元素上<br>window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的 也可称为window子对象<br>window对象是js中的顶级对象，全局变量，自定义函数也是window对象的属性和方法<br>alert(1);confirm(1) prompt()不推荐使用 弹出框<br>打开窗口window.open(url,target,param)<br>url:打开地址 target:新窗口位置_blank _self _parent<br>param:新窗口的一些设置<br>返回值：新窗口的句柄<br>window.location简写成location,locaton相当于浏览器地址栏，可以将url解析成独立的字段<br>href:跳转 hash:返回url中#后面的内容 host:主机名 hostname:主机名 protocol 协议 一般是http、https<br>使用href的作用就是调用assign<br>window.location.assign(“<a href="https://www.baidu.com&quot;)" target="_blank" rel="noopener">https://www.baidu.com&quot;)</a>;<br>设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。assign会记录到历史记录中去<br>location.replace()：替换浏览器地址栏的地址，不会记录到历史中<br>navigator对象会获取客户端的一些信息<br>console.log(navigator.userAgent);<br>history.back() 表示后退 history.go(-1) 0是刷新<br>与普通函数相比，构造函数有以下明显特点：<br>用new关键字调用，不需要return显示返回值的，默认为返回this。建议函数名首字母大写，与普通函数区分开。<br>原型规则<br>规则1 所有的引用类型(数组，对象，函数)都具有对象特性，都可以自由扩展属性。null除外。<br>所有的引用类型(数组，对象，函数)都有<strong>proto</strong>属性，属性值是一个普通的对象。<em>proto</em>的含义是隐式原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__);</span><br></pre></td></tr></table></figure></p>
<p>所有的构造函数都有prototype类型 指向原型对象<br>通过for…in循环遍历对象，针对上面的那个fn对象，它自身有两个属性：name、printName，另外从原型中找到了第三个属性alertName。现在，如果我们对fn进行遍历，能遍历到两个属性还是三个属性呢？<br>答案：2个，因为高级浏览器已经屏蔽了来自原型的属性，。但是，为了保证代码的健壮性，我们最好自己加上判断，手动将第三个属性屏蔽掉：</p>
<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>这2个方法都是函数对象的方法，需要通过函数对象来调用<br>当函数调用call和apply时，函数会立即执行<br>都可以用来改变函数的this对象的指向<br>第一个参数都是this要指向的对象(函数执行时，this将指向这个对象)<br>thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。<br>传递一个别的函数名时，函数中的this将指向<strong>这个函数的引用。</strong><br>传递值为数字，布尔值，字符串时,this会指向这些基本类型的包装对象Number,Boolean,String<br>传递一个对象时，函数中的this则指向传递的这个对象。<br>call和apply的区别，<strong>call后面的实参和say方法中是一一对应的，而apply在传递实参时，要封装成一个数组，</strong>数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>call()和apply()的作用<br>改变this的指向<br>实现继承。Father.call(this)<br>bind()<br>都能改变this的指向<br>call()/apply()是<strong>立即调用函数</strong><br>bind()是将函数返回，因此后面还需要加()才能调用。<br>bind传参 xw.say.bind(xh,”实验”,”六年级”)();<br>或者xw.say.bind(xh)(“实验”,”小学”);<br>apply方法xw.say.apply(xh,[“实验小学”,”六年级”]);<br>call方法xw.say.call(xh,”实验小学”,”六年级”);<br>函数赋值给变量时，this指向window<br>var foo1 = args.getInfo;<br>foo1()<br>var foo2 = function() {};<br>foo2();<br>//this都是指向window<br>执行上下文主要有2种情况：<br>全局代码，一段script标签内，有一个全局的执行上下文。所做的事情是：变量定义，函数声明<br>函数代码：每个函数里面有一个上下文，所做的事情是：变量定义、函数声明、this,arguments<br>var定义的为全局变量 =&gt; undefined<br>function声明的全局变量 ===&gt; 赋值fun 添加为window的方法<br>this =&gt; 赋值(window)(<br>函数执行上下文：调用函数时，准备执行函数体之前，创建对应的函数执行上下文对象，(虚拟的，存在于栈中)<br>对局部数据进行预处理<br>形参变量 ===&gt; 赋值(实参) 添加为执行上下文的属性<br>arguments ===&gt; 赋值(实参列表) 添加为执行上下文的属性<br>var 定义的局部变量 ===&gt; undefined 添加为执行上下文的属性<br>function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法<br>this ===&gt; 赋值(调用函数的对象)<br>执行上下文栈：<br>在全局代码执行前，JS引擎会创建一个栈来存储管理所有的执行上下文对象<br>在全局执行上下文window确定后，将其添加到栈中<br>在函数执行上下文创建之后，将其添加到栈中<br>在当前函数执行完后，将栈顶的对象移除<br>当所有的代码执行完后，栈中只剩下window<br>this指的是，调用函数的那个对象。this永远指向函数运行时所在的对象。<br>解析器在调用函数的时候每次都会向函数内部传递一个隐藏的参数，这个隐藏的参数就是this<br>以函数形式调用,this会指向window<br>以构造函数创建，this是新创建的那个对象<br>使用call和apply调用时，this指向那个对象<br>作用域指一个变量的作用范围，是静态的(相对于上下文对象)<br>全局作用域 函数作用域<br>调用函数时会创建函数作用域，函数执行完毕以后，函数作用域会销毁。<br>每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。<br>在函数作用域中可以访问到全局作用域中的变量，在全局作用域中无法访问到函数作用域中的变量。<br><strong>使用var关键字声明的变量，是在函数作用域内有效，而且会在函数中所有的代码执行之前被声明</strong><br>在函数作用域中有效，而且会在函数中所有代码执行前会被声明。<br>全局执行上下文是在全局作用域确定之后，js代码马上执行之前就创建了。<br>函数执行上下文实在调用函数时，<strong>函数体代码执行之前创建</strong><br>作用域是静态的，只要函数定义好就一直存在,且不再变化<br>执行上下文是动态的，调用函数时创建，函数调用结束时就会自动释放<br>执行上下文(对象)是从属于所在的作用域<br>全局上下文环境 ===&gt; 全局作用域<br>函数上下文环境 ===&gt; 对应的函数使用域<br>闭包：能够读取其他函数内部数据(变量/函数)的函数<br>因此可以把闭包简单理解成”定义在一个函数内部的函数”。<br>object.prototype.toString.call(‘’) 检测类型[object:string]<br>this的值是在执行的时候才能确认，但是不能在定义的时候确认<br>箭头函数this指向：箭头函数没有自己的this,看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this,<br>如果没有，this就是window<br>执行栈认为是一个存储函数调用的结构，遵循先进后出原则。</p>
<h2 id="手写实现ajax"><a href="#手写实现ajax" class="headerlink" title="手写实现ajax"></a>手写实现ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState == 4)&#123;</span><br><span class="line">        if(xhr.status == 200)&#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;/api&quot;,false);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
<h2 id="动态创建DOM元素的3种方式"><a href="#动态创建DOM元素的3种方式" class="headerlink" title="动态创建DOM元素的3种方式"></a>动态创建DOM元素的3种方式</h2><p>document.write()不常用 因为容易覆盖掉原来的页面<br>innerHTML = () 用的比较多，绑定属性和内容比较方便<br>document.createElement() 用的也比较多，，指定数量的时候一般用它。<br>vue双向绑定原理：通过数据劫持结合发布者-订阅者模式的方式来实现<br>利用object.defineProperty()这个方法重新定义了对象获取属性值(get)和设置属性值(set)。<br>jquery是事件驱动 而其余是数据驱动<br>jquery业务和UI更改混杂在一起，UI里面还涉及交互逻辑，让本来混乱的逻辑更加混乱<br>node js借助事件驱动，非阻塞I/O模型变得更加轻量和高效，非常适合于运行在分布式设备的数据密集型实时应用。<br>offsetWidth和offsetHight<br>offsetWitdh用于检测盒子<strong>自身的宽高+padding+border</strong><br>offsetWidth = width + padding + border;<br>offsetLeft 可以返回没有定位盒子的距离左侧的位置。如果父系盒子中都没有定位，以body为准。<br>style.left 只能获取行内式，如果没有，则返回””（意思是，返回空）;<br>scrollWidth = width + padding;<br>scrollHeight = height + padding;<br>client家族的形成<br>clientWidth:获取盒子区域宽度(padding + width)<br>clientHeight:获取盒子区域高度(padding + height)<br>body/html调用时，<br>clientWidth获取网页可视区域宽度<br>clientHeight获取网页可视区域高度</p>
<p>clientX:event调用：鼠标距离可视区域左侧距离<br>clientY:event调用：鼠标距离可视区域上侧距离</p>
<p>clientTop：盒子的上border。<br>clientLeft：盒子的左border。</p>
<p>宽高：<br>offsetWidth = width + padding + border;<br>offsetHeight = height + padding + border;</p>
<p>window.onresize事件指的是：在窗口或框架被调整大小时发生：<br>window.onscroll()屏幕滑动<br>window.onresize()浏览器大小变化<br><strong>window.onload()页面加载完毕</strong><br>div.onmousemove()鼠标在盒子上移动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onresize = function() &#123;</span><br><span class="line">    document.title = window.screen.width + window.screen.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取显示屏的分辨率1920 * 1080<br>jQuery的两大特点 链式编程比如.show和.html可以连写成.show().html()<br>通常情况下：只有设置操作才能把链式编程延续下去，因为获取操作的时候，会返回获取到的相应值，无法返回this.<br>隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。<br>jquery加载完<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dom树生成即可</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>//文档加载完毕，图片不用加载完 写下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(function() &#123;</span><br><span class="line">    alert(1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>onload是网页全部加载完毕，包括图片,ready只需要dom加载完毕，生成dom树即可</strong><br>通过jquery获取的元素是一个数组 数组中包含着原生JS中的DOM对象<br>通过原生js获取这些元素节点的方式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myBox = document.getElementById(&quot;box&quot;);           //通过 id 获取单个元素</span><br><span class="line">var boxArr = document.getElementsByClassName(&quot;box&quot;);  //通过 class获取的是数组</span><br><span class="line">var divArr = document.getElementsByTagName(&quot;div&quot;);    //通过标签获取的是数组</span><br></pre></td></tr></table></figure></p>
<p>总结：jquery就是把dom对象重新包装了一下，让其具有了jquery方法<br>子代选择器 &gt; 表示儿子 后代选择器  表示全部的都会被选中<br>属性选择器:$(“a[href]”) $(“a[href = ‘itcast’]”)<br>添加类样式<br>$(selector).addClass(“listItem”);<br>删除类样式<br>$(selector).removeClass(“listItem”);<br>判断是否有样式<br>$(selector).hasClass(“listItem”);<br>切换类样式<br>$(selector).toggleClass(“listItem”);<br>有则移除 没有则添加<br>jquery设置和获取属性<br>设置属性attr(“title”,”生命一号”);<br>获取属性attr(“title”);<br>val() 设置或返回form表单元素中的value值<br>$(selector).val();<br>获取文本内容<br>$(selector).text();<br>jquery设置宽度和高度<br>$(selector).height();//不带参数表示获取高度<br>$(selector).height(200);//带参数表示设置高度</p>
<p>$(selector).width();     //不带参数表示获取宽度<br>$(selector).width(200);  //带参数表示设置高宽度</p>
<p>$(“div”).css() //返回的是string类型，例如30px<br>$(“div”).height() 返回的是number类型,30常用于数学计算<br>click是单击事件 blur失去焦点 mouseenter鼠标进入 mouseleave 鼠标离开等<br>解除匹配元素的所有事件<br>$(selector).off()<br>阻止事件冒泡<br>event.stopProgation()<br>阻止默认行为<br>event.preventDefault()<br>$(selector).each(function(index,element){</p>
<p>})<br>参数一表示当前元素所在匹配元素中的索引号，<br>参数而表示当前元素<br>多库共存指的是：jquery占用了$和jquery两个变量，当在同一个页面引用了jquery和其他库时，恰好其他库也使用了jquery或者$<br>,那么要保证多库共用，<br>获取jquery库的版本号console.log($.fn.jquery);<br>办法一：让jquery放弃对$的使用权<br>$.noConflict();<br>办法二：同时放弃2个符号的使用权，并定义一个新的使用权<br>$.noConflict(true);<br>zepto库介绍<br>zepto是轻量级js库，专门为移动端定制<br>与jquery有类似的API,俗称：会jquery就会zepto<br>css3现状<br>浏览器支持程度不够好，有些需要添加私有前缀<br>移动端支持优于PC端<br>不断改进中<br>应用相对广泛<br>过渡:transition 2D转换:transform 3D转换:transform 动画:animation<br>实现不同状态间的平滑过渡<br>transition-property: all; 如果希望所有的属性都发生过渡，就使用all。<br>transition-duration:1s;过渡的持续时间<br>transition-timing-function: linear; 运动曲线<br>transition:all 3s linear 0s;<br>缩放：scale<br>transform:scale(x,y);x轴的缩放和y轴的缩放<br> x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。<br> translate 参数为百分比，表示相对于自身移动<br> 正值：向右和向下 负值：向左和向上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">width:600px;</span><br><span class="line">height:60px;</span><br><span class="line">background-color:red;</span><br><span class="line">position:absolute; 绝对定位</span><br><span class="line">left:50%; 让左边线居中</span><br><span class="line">top:0;</span><br><span class="line">transform:translate(-50%); 然后利用translate,往左走自己一半的宽度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform:rotate(角度);rotate(45deg); 正值：顺时针 负值：逆时针<br>3D旋转 rotateX,rotateY,rotateZ<br>动画可通过设置多个节点，来精确控制一个或一组动画，常用来实现复杂的动画效果。<br>@keyframes 动画名{<br>    from{初始状态}<br>    to{结束状态}<br>}</p>
<p>@keyframes move1 {<br>            from {<br>                transform: translateX(0px) rotate(0deg);<br>            }<br>            to {<br>                transform: translateX(500px) rotate(555deg);<br>            }<br>        }</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向，从左向右。<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向，从上往下。<br>flex-direction:row;reverse-row; column; reverse-column<br>justify-content:设置子元素在主轴上的对齐方式<br>justify-content:flex-start flex-end center space-around space-between<br>align-items：设置子元素在侧轴上的对齐方式。</p>
<p>align-items:flex-start; 设置子元素在侧轴上的对齐方式。属性值可以是：<br>flex-start 从侧轴开始的方向对齐<br>flex-end 从侧轴结束的方向对齐<br>baseline 基线 默认同flex-start<br>center 中间对齐<br>stretch 拉伸<br>通过window.online来检测用户当前的网络状况，返回一个布尔值。另外：<br>window.online用户网络连接时被调用 window.offline用户网络断开时被调用<br>boostrap标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta = http-equiv = &quot;X-UA-Compatible&quot; content = &quot;IE=edge&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>解释：设置浏览器的兼容模式版本，表示如果在IE浏览器下则使用最新的标准，渲染当前文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name = &quot;viewport&quot; content = &quot;width=device-width,inital-scale=1.0,user-scalable=no&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>解释：声明当前网页在移动端浏览器中展示的相关位置，我们在做移动 web 开发时，就用上面这行代码设置 viewport。<br>视口的作用：在移动浏览器中，当页面超出设备时，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示。<br>目前大多数手机浏览器视口：宽度都是980<br>此属性为移动端页面视口设置，上方代码设置的值，表示在移动端页面的宽度为设备的宽度，并且不缩放(缩放级别为1)<br>width:设置viewport的宽度 initial-scale:初始化缩放比例 minimum-scale:最小缩放比例 maximum-scale:最大缩放比例<br>user-scalable:是否允许用户手动缩放（值可以写成yes/no，也可以写成1/0）<br>C/S架构和B/S架构<br>是Client/Server这两个单词的首字母，指的是客户端和服务器<br>优点：<br>性能较高：可以将一部分的计算工作放在客户端上,这样服务器只需要处理数据即可。<br>界面酷炫:客户端可以使用更多系统提供的效果,做出更为炫目的效果。<br>缺点:<br>更新软件：如果有新的功能，就要推出新的版本。<br>不同设备访问：如果使用其他的电脑，没有安装客户端的话就无法登陆软件。<br>B/S架构：浏览器/服务器类型<br>优点：<br>更新简洁：如果需要更新内容了,对开发人员而言需要更改服务器的内容，对用户而言只需要刷新浏览器即可。<br>多设备同步：所有数据都在网上,只要能够使用浏览器即可登录使用。<br>缺点:<br>性能较低：相比于客户端应用性能较低,但是随着硬件性能的提升,这个差距在缩小。<br>浏览器兼容：处理低版本的浏览器显示问题一直是前端开发人员头痛的问题之一。移动设备兼容性较好，ie6已经越来越少人用了。<br> php代码执行方式：在服务器端执行，然后返回给用户结果，如果直接使用浏览器打开，则会是一串文本<br> 意思：需要浏览器通过http请求，才能够执行php页面。<br> ajax:可以在不刷新页面的情况下，通过ajax方式去获取一些新的内容<br> ajax的核心是js对象：XMLHttpRequest<br> 发送请求<br> open(method,url,async);<br> method 请求的类型 get或post<br> url:文件在服务器上的位置<br> async:true(异步) 或 false(同步)<br> send(string)仅用于post请求<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.php&quot;, true);</span><br><span class="line"></span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line"></span><br><span class="line">xmlhttp.send(&quot;name=smyhvae&amp;age=27&quot;);</span><br></pre></td></tr></table></figure></p>
<p>注册onreadystatechange事件，每当readyState属性改变时，就会调用该事件<br>readyState:0请求未初始化 1服务器建立连接 2请求已接收<br>3请求处理中 4请求已完成<br>200 “OK” 404 “未找到页面”<br>jquery已经封装好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;01.php&quot;,</span><br><span class="line">    data:&quot;name=fox&amp;age=18&apos;,</span><br><span class="line">    type:&quot;GET&quot;,</span><br><span class="line">    success:function()&#123;</span><br><span class="line">     &#125;,</span><br><span class="line">    beforeSend:function()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>同源策略：是浏览器的一种安全策略，指的是域名，协议，端口完全相同<br>jsonp 带补丁的json,本质是利用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>标签具有可跨域性，由服务端返回一个预先定义好的js函数的调用，并且将服务器数据以该函数参数的形式传递过来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;  src=&apos;http://192.168.141.137/2018-02-28/myData.php&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
            <a href="/tags/前端大杂烩/" rel="tag"># 前端大杂烩</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/15/BFC笔记/" rel="next" title="BFC笔记">
                <i class="fa fa-chevron-left"></i> BFC笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/29/web前端入门和进阶js笔记-node-js笔记/" rel="prev" title="web前端入门和进阶js笔记-node js笔记">
                web前端入门和进阶js笔记-node js笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="KevinSwift">
            
              <p class="site-author-name" itemprop="name">KevinSwift</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#js和esmscript的关系"><span class="nav-number">1.</span> <span class="nav-text">js和esmscript的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器工作原理"><span class="nav-number">2.</span> <span class="nav-text">浏览器工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本对象和引用对象"><span class="nav-number">3.</span> <span class="nav-text">基本对象和引用对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js中的代码块"><span class="nav-number">4.</span> <span class="nav-text">js中的代码块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数中this的指向"><span class="nav-number">5.</span> <span class="nav-text">箭头函数中this的指向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型prototype"><span class="nav-number">6.</span> <span class="nav-text">原型prototype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS的垃圾回收机制"><span class="nav-number">7.</span> <span class="nav-text">JS的垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组常用方法"><span class="nav-number">8.</span> <span class="nav-text">数组常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将伪数组转化为真数组"><span class="nav-number">9.</span> <span class="nav-text">将伪数组转化为真数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date和Math方法"><span class="nav-number">10.</span> <span class="nav-text">Date和Math方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#url编码和解码"><span class="nav-number">11.</span> <span class="nav-text">url编码和解码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#let-var-function，eval的区别"><span class="nav-number">12.</span> <span class="nav-text">let var function，eval的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call和apply"><span class="nav-number">13.</span> <span class="nav-text">call和apply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手写实现ajax"><span class="nav-number">14.</span> <span class="nav-text">手写实现ajax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态创建DOM元素的3种方式"><span class="nav-number">15.</span> <span class="nav-text">动态创建DOM元素的3种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flex布局"><span class="nav-number">16.</span> <span class="nav-text">flex布局</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KevinSwift</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
